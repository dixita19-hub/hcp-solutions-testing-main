<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <title>Test Report</title>
    <link href="assets/style.css" rel="stylesheet" type="text/css"/></head>
  <body onLoad="init()">
    <script>/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */


function toArray(iter) {
    if (iter === null) {
        return null;
    }
    return Array.prototype.slice.call(iter);
}

function find(selector, elem) { // eslint-disable-line no-redeclare
    if (!elem) {
        elem = document;
    }
    return elem.querySelector(selector);
}

function findAll(selector, elem) {
    if (!elem) {
        elem = document;
    }
    return toArray(elem.querySelectorAll(selector));
}

function sortColumn(elem) {
    toggleSortStates(elem);
    const colIndex = toArray(elem.parentNode.childNodes).indexOf(elem);
    let key;
    if (elem.classList.contains('result')) {
        key = keyResult;
    } else if (elem.classList.contains('links')) {
        key = keyLink;
    } else {
        key = keyAlpha;
    }
    sortTable(elem, key(colIndex));
}

function showAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(showExtras);
}

function hideAllExtras() { // eslint-disable-line no-unused-vars
    findAll('.col-result').forEach(hideExtras);
}

function showExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.remove('collapsed');
    expandcollapse.classList.remove('expander');
    expandcollapse.classList.add('collapser');
}

function hideExtras(colresultElem) {
    const extras = colresultElem.parentNode.nextElementSibling;
    const expandcollapse = colresultElem.firstElementChild;
    extras.classList.add('collapsed');
    expandcollapse.classList.remove('collapser');
    expandcollapse.classList.add('expander');
}

function showFilters() {
    const filterItems = document.getElementsByClassName('filter');
    for (let i = 0; i < filterItems.length; i++)
        filterItems[i].hidden = false;
}

function addCollapse() {
    // Add links for show/hide all
    const resulttable = find('table#results-table');
    const showhideall = document.createElement('p');
    showhideall.innerHTML = '<a href="javascript:showAllExtras()">Show all details</a> / ' +
                            '<a href="javascript:hideAllExtras()">Hide all details</a>';
    resulttable.parentElement.insertBefore(showhideall, resulttable);

    // Add show/hide link to each result
    findAll('.col-result').forEach(function(elem) {
        const collapsed = getQueryParameter('collapsed') || 'Passed';
        const extras = elem.parentNode.nextElementSibling;
        const expandcollapse = document.createElement('span');
        if (extras.classList.contains('collapsed')) {
            expandcollapse.classList.add('expander');
        } else if (collapsed.includes(elem.innerHTML)) {
            extras.classList.add('collapsed');
            expandcollapse.classList.add('expander');
        } else {
            expandcollapse.classList.add('collapser');
        }
        elem.appendChild(expandcollapse);

        elem.addEventListener('click', function(event) {
            if (event.currentTarget.parentNode.nextElementSibling.classList.contains('collapsed')) {
                showExtras(event.currentTarget);
            } else {
                hideExtras(event.currentTarget);
            }
        });
    });
}

function getQueryParameter(name) {
    const match = RegExp('[?&]' + name + '=([^&]*)').exec(window.location.search);
    return match && decodeURIComponent(match[1].replace(/\+/g, ' '));
}

function init () { // eslint-disable-line no-unused-vars
    resetSortHeaders();

    addCollapse();

    showFilters();

    sortColumn(find('.initial-sort'));

    findAll('.sortable').forEach(function(elem) {
        elem.addEventListener('click',
            function() {
                sortColumn(elem);
            }, false);
    });
}

function sortTable(clicked, keyFunc) {
    const rows = findAll('.results-table-row');
    const reversed = !clicked.classList.contains('asc');
    const sortedRows = sort(rows, keyFunc, reversed);
    /* Whole table is removed here because browsers acts much slower
     * when appending existing elements.
     */
    const thead = document.getElementById('results-table-head');
    document.getElementById('results-table').remove();
    const parent = document.createElement('table');
    parent.id = 'results-table';
    parent.appendChild(thead);
    sortedRows.forEach(function(elem) {
        parent.appendChild(elem);
    });
    document.getElementsByTagName('BODY')[0].appendChild(parent);
}

function sort(items, keyFunc, reversed) {
    const sortArray = items.map(function(item, i) {
        return [keyFunc(item), i];
    });

    sortArray.sort(function(a, b) {
        const keyA = a[0];
        const keyB = b[0];

        if (keyA == keyB) return 0;

        if (reversed) {
            return keyA < keyB ? 1 : -1;
        } else {
            return keyA > keyB ? 1 : -1;
        }
    });

    return sortArray.map(function(item) {
        const index = item[1];
        return items[index];
    });
}

function keyAlpha(colIndex) {
    return function(elem) {
        return elem.childNodes[1].childNodes[colIndex].firstChild.data.toLowerCase();
    };
}

function keyLink(colIndex) {
    return function(elem) {
        const dataCell = elem.childNodes[1].childNodes[colIndex].firstChild;
        return dataCell == null ? '' : dataCell.innerText.toLowerCase();
    };
}

function keyResult(colIndex) {
    return function(elem) {
        const strings = ['Error', 'Failed', 'Rerun', 'XFailed', 'XPassed',
            'Skipped', 'Passed'];
        return strings.indexOf(elem.childNodes[1].childNodes[colIndex].firstChild.data);
    };
}

function resetSortHeaders() {
    findAll('.sort-icon').forEach(function(elem) {
        elem.parentNode.removeChild(elem);
    });
    findAll('.sortable').forEach(function(elem) {
        const icon = document.createElement('div');
        icon.className = 'sort-icon';
        icon.textContent = 'vvv';
        elem.insertBefore(icon, elem.firstChild);
        elem.classList.remove('desc', 'active');
        elem.classList.add('asc', 'inactive');
    });
}

function toggleSortStates(elem) {
    //if active, toggle between asc and desc
    if (elem.classList.contains('active')) {
        elem.classList.toggle('asc');
        elem.classList.toggle('desc');
    }

    //if inactive, reset all other functions and add ascending active
    if (elem.classList.contains('inactive')) {
        resetSortHeaders();
        elem.classList.remove('inactive');
        elem.classList.add('active');
    }
}

function isAllRowsHidden(value) {
    return value.hidden == false;
}

function filterTable(elem) { // eslint-disable-line no-unused-vars
    const outcomeAtt = 'data-test-result';
    const outcome = elem.getAttribute(outcomeAtt);
    const classOutcome = outcome + ' results-table-row';
    const outcomeRows = document.getElementsByClassName(classOutcome);

    for(let i = 0; i < outcomeRows.length; i++){
        outcomeRows[i].hidden = !elem.checked;
    }

    const rows = findAll('.results-table-row').filter(isAllRowsHidden);
    const allRowsHidden = rows.length == 0 ? true : false;
    const notFoundMessage = document.getElementById('not-found-message');
    notFoundMessage.hidden = !allRowsHidden;
}
</script>
    <h1>Test Results</h1>
    <p>Report generated on 22-Jun-2023 at 11:05:44 by <a href="https://pypi.python.org/pypi/pytest-html">pytest-html</a> v3.1.1</p>
    <h2>Environment</h2>
    <table id="environment">
      <tr>
        <td>Run from</td>
        <td>Local</td></tr>
      <tr>
        <td>Base URL</td>
        <td><a href="https://galaxyqa02-preview.site.pfizer/core/ppc-regression" target="_blank">https://galaxyqa02-preview.site.pfizer/core/ppc-regression</a></td></tr>
      <tr>
        <td>Driver</td>
        <td>Name: Chrome</td></tr>
      <tr>
        <td>Platform</td>
        <td>Windows-10-10.0.19044-SP0</td></tr>
      <tr>
        <td>Plugins</td>
        <td>allure-pytest-bdd: 2.13.2, Faker: 18.10.1, base-url: 2.0.0, bdd: 6.1.1, check: 2.0.0, enhanced-reports: 1.2.2, html: 3.1.1, metadata: 2.0.4, rerunfailures: 11.1.2, selenium: 4.0.0, selenium-enhancer: 1.7.1, variables: 2.0.0, xdist: 3.3.1</td></tr>
      <tr>
        <td>Python</td>
        <td>3.9.12</td></tr></table>
    <h2>Summary</h2>
    <h3 class="red">Pass Rate: 0.0%</h3>
    <p>7 tests ran in 30.91 seconds</p>
    <p class="filter" hidden="true">(Un)check the boxes to filter the results.</p><input checked="true" class="filter" data-test-result="passed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="passed">0 passed</span>, <input checked="true" class="filter" data-test-result="skipped" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="skipped">0 skipped</span>, <input checked="true" class="filter" data-test-result="failed" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="failed">7 failed</span>, <input checked="true" class="filter" data-test-result="error" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="error">0 errors</span>, <input checked="true" class="filter" data-test-result="xfailed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xfailed">0 expected failures</span>, <input checked="true" class="filter" data-test-result="xpassed" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="xpassed">0 unexpected passes</span>, <input checked="true" class="filter" data-test-result="rerun" disabled="true" hidden="true" name="filter_checkbox" onChange="filterTable(this)" type="checkbox"/><span class="rerun">0 rerun</span>
    <h2>Results</h2>
    <table id="results-table">
      <thead id="results-table-head">
        <tr>
          <th class="sortable" col="name">Section</th>
          <th class="sortable" col="name">Tag</th>
          <th class="sortable" col="name">Title</th>
          <th class="sortable result initial-sort" col="result">Result</th>
          <th class="sortable" col="duration">Duration</th>
          <th class="sortable links" col="links">Links</th></tr>
        <tr hidden="true" id="not-found-message">
          <th colspan="6">No results found. Try to check the filters</th></tr></thead>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-section">Galaxy automated regression -&gt; button and anchor components</td>
          <td class="col-tags">TR-C393228</td>
          <td class="col-name">Verify PPC - Buttons and Anchor - Loading Button  locator: helixComponent &gt; loading_button, attribute: background-color, value: rgba(0, 0, 201, 1)</td>
          <td class="col-result">Failed</td>
          <td class="col-duration">00:04.55</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="6">
            <div class="log">self = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7B55B970&gt;<br/><br/>    def start(self):<br/>        &quot;&quot;&quot;<br/>        Starts the Service.<br/>    <br/>        :Exceptions:<br/>         - WebDriverException : Raised either when it can&#x27;t start the service<br/>           or when it can&#x27;t connect to the service<br/>        &quot;&quot;&quot;<br/>        try:<br/>            cmd = [self.path]<br/>            cmd.extend(self.command_line_args())<br/>&gt;           self.process = subprocess.Popen(cmd, env=self.env,<br/>                                            close_fds=system() != &#x27;Windows&#x27;,<br/>                                            stdout=self.log_file,<br/>                                            stderr=self.log_file,<br/>                                            stdin=PIPE,<br/>                                            creationflags=self.creationflags)<br/><br/>venv\lib\site-packages\selenium\webdriver\common\service.py:71: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Popen: returncode: None args: [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--...&gt;<br/>args = [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--port=52296&#x27;, &#x27;--log-path=C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a0\\driver.log&#x27;]<br/>bufsize = -1, executable = None, stdin = -1, stdout = -3, stderr = -3, preexec_fn = None, close_fds = False, shell = False, cwd = None<br/>env = environ({&#x27;__INTELLIJ_COMMAND_HISTFILE__&#x27;: &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\terminal\\..._ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)] (call)&#x27;})<br/>universal_newlines = None, startupinfo = None, creationflags = 0, restore_signals = True, start_new_session = False, pass_fds = ()<br/><br/>    def __init__(self, args, bufsize=-1, executable=None,<br/>                 stdin=None, stdout=None, stderr=None,<br/>                 preexec_fn=None, close_fds=True,<br/>                 shell=False, cwd=None, env=None, universal_newlines=None,<br/>                 startupinfo=None, creationflags=0,<br/>                 restore_signals=True, start_new_session=False,<br/>                 pass_fds=(), *, user=None, group=None, extra_groups=None,<br/>                 encoding=None, errors=None, text=None, umask=-1):<br/>        &quot;&quot;&quot;Create new Popen instance.&quot;&quot;&quot;<br/>        _cleanup()<br/>        # Held while anything is calling waitpid before returncode has been<br/>        # updated to prevent clobbering returncode if wait() or poll() are<br/>        # called from multiple threads at once.  After acquiring the lock,<br/>        # code must re-check self.returncode to see if another thread just<br/>        # finished a waitpid() call.<br/>        self._waitpid_lock = threading.Lock()<br/>    <br/>        self._input = None<br/>        self._communication_started = False<br/>        if bufsize is None:<br/>            bufsize = -1  # Restore default<br/>        if not isinstance(bufsize, int):<br/>            raise TypeError(&quot;bufsize must be an integer&quot;)<br/>    <br/>        if _mswindows:<br/>            if preexec_fn is not None:<br/>                raise ValueError(&quot;preexec_fn is not supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>        else:<br/>            # POSIX<br/>            if pass_fds and not close_fds:<br/>                warnings.warn(&quot;pass_fds overriding close_fds.&quot;, RuntimeWarning)<br/>                close_fds = True<br/>            if startupinfo is not None:<br/>                raise ValueError(&quot;startupinfo is only supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>            if creationflags != 0:<br/>                raise ValueError(&quot;creationflags is only supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>    <br/>        self.args = args<br/>        self.stdin = None<br/>        self.stdout = None<br/>        self.stderr = None<br/>        self.pid = None<br/>        self.returncode = None<br/>        self.encoding = encoding<br/>        self.errors = errors<br/>    <br/>        # Validate the combinations of text and universal_newlines<br/>        if (text is not None and universal_newlines is not None<br/>            and bool(universal_newlines) != bool(text)):<br/>            raise SubprocessError(&#x27;Cannot disambiguate when both text &#x27;<br/>                                  &#x27;and universal_newlines are supplied but &#x27;<br/>                                  &#x27;different. Pass one or the other.&#x27;)<br/>    <br/>        # Input and output objects. The general principle is like<br/>        # this:<br/>        #<br/>        # Parent                   Child<br/>        # ------                   -----<br/>        # p2cwrite   ---stdin---&gt;  p2cread<br/>        # c2pread    &lt;--stdout---  c2pwrite<br/>        # errread    &lt;--stderr---  errwrite<br/>        #<br/>        # On POSIX, the child objects are file descriptors.  On<br/>        # Windows, these are Windows file handles.  The parent objects<br/>        # are file descriptors on both platforms.  The parent objects<br/>        # are -1 when not using PIPEs. The child objects are -1<br/>        # when not redirecting.<br/>    <br/>        (p2cread, p2cwrite,<br/>         c2pread, c2pwrite,<br/>         errread, errwrite) = self._get_handles(stdin, stdout, stderr)<br/>    <br/>        # We wrap OS handles *before* launching the child, otherwise a<br/>        # quickly terminating child could make our fds unwrappable<br/>        # (see #8458).<br/>    <br/>        if _mswindows:<br/>            if p2cwrite != -1:<br/>                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)<br/>            if c2pread != -1:<br/>                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)<br/>            if errread != -1:<br/>                errread = msvcrt.open_osfhandle(errread.Detach(), 0)<br/>    <br/>        self.text_mode = encoding or errors or text or universal_newlines<br/>    <br/>        # How long to resume waiting on a child after the first ^C.<br/>        # There is no right value for this.  The purpose is to be polite<br/>        # yet remain good for interactive users trying to exit a tool.<br/>        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()<br/>    <br/>        self._closed_child_pipe_fds = False<br/>    <br/>        if self.text_mode:<br/>            if bufsize == 1:<br/>                line_buffering = True<br/>                # Use the default buffer size for the underlying binary streams<br/>                # since they don&#x27;t support line buffering.<br/>                bufsize = -1<br/>            else:<br/>                line_buffering = False<br/>    <br/>        gid = None<br/>        if group is not None:<br/>            if not hasattr(os, &#x27;setregid&#x27;):<br/>                raise ValueError(&quot;The &#x27;group&#x27; parameter is not supported on the &quot;<br/>                                 &quot;current platform&quot;)<br/>    <br/>            elif isinstance(group, str):<br/>                if grp is None:<br/>                    raise ValueError(&quot;The group parameter cannot be a string &quot;<br/>                                     &quot;on systems without the grp module&quot;)<br/>    <br/>                gid = grp.getgrnam(group).gr_gid<br/>            elif isinstance(group, int):<br/>                gid = group<br/>            else:<br/>                raise TypeError(&quot;Group must be a string or an integer, not {}&quot;<br/>                                .format(type(group)))<br/>    <br/>            if gid &lt; 0:<br/>                raise ValueError(f&quot;Group ID cannot be negative, got {gid}&quot;)<br/>    <br/>        gids = None<br/>        if extra_groups is not None:<br/>            if not hasattr(os, &#x27;setgroups&#x27;):<br/>                raise ValueError(&quot;The &#x27;extra_groups&#x27; parameter is not &quot;<br/>                                 &quot;supported on the current platform&quot;)<br/>    <br/>            elif isinstance(extra_groups, str):<br/>                raise ValueError(&quot;Groups must be a list, not a string&quot;)<br/>    <br/>            gids = []<br/>            for extra_group in extra_groups:<br/>                if isinstance(extra_group, str):<br/>                    if grp is None:<br/>                        raise ValueError(&quot;Items in extra_groups cannot be &quot;<br/>                                         &quot;strings on systems without the &quot;<br/>                                         &quot;grp module&quot;)<br/>    <br/>                    gids.append(grp.getgrnam(extra_group).gr_gid)<br/>                elif isinstance(extra_group, int):<br/>                    gids.append(extra_group)<br/>                else:<br/>                    raise TypeError(&quot;Items in extra_groups must be a string &quot;<br/>                                    &quot;or integer, not {}&quot;<br/>                                    .format(type(extra_group)))<br/>    <br/>            # make sure that the gids are all positive here so we can do less<br/>            # checking in the C code<br/>            for gid_check in gids:<br/>                if gid_check &lt; 0:<br/>                    raise ValueError(f&quot;Group ID cannot be negative, got {gid_check}&quot;)<br/>    <br/>        uid = None<br/>        if user is not None:<br/>            if not hasattr(os, &#x27;setreuid&#x27;):<br/>                raise ValueError(&quot;The &#x27;user&#x27; parameter is not supported on &quot;<br/>                                 &quot;the current platform&quot;)<br/>    <br/>            elif isinstance(user, str):<br/>                if pwd is None:<br/>                    raise ValueError(&quot;The user parameter cannot be a string &quot;<br/>                                     &quot;on systems without the pwd module&quot;)<br/>    <br/>                uid = pwd.getpwnam(user).pw_uid<br/>            elif isinstance(user, int):<br/>                uid = user<br/>            else:<br/>                raise TypeError(&quot;User must be a string or an integer&quot;)<br/>    <br/>            if uid &lt; 0:<br/>                raise ValueError(f&quot;User ID cannot be negative, got {uid}&quot;)<br/>    <br/>        try:<br/>            if p2cwrite != -1:<br/>                self.stdin = io.open(p2cwrite, &#x27;wb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,<br/>                            line_buffering=line_buffering,<br/>                            encoding=encoding, errors=errors)<br/>            if c2pread != -1:<br/>                self.stdout = io.open(c2pread, &#x27;rb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stdout = io.TextIOWrapper(self.stdout,<br/>                            encoding=encoding, errors=errors)<br/>            if errread != -1:<br/>                self.stderr = io.open(errread, &#x27;rb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stderr = io.TextIOWrapper(self.stderr,<br/>                            encoding=encoding, errors=errors)<br/>    <br/>&gt;           self._execute_child(args, executable, preexec_fn, close_fds,<br/>                                pass_fds, cwd, env,<br/>                                startupinfo, creationflags, shell,<br/>                                p2cread, p2cwrite,<br/>                                c2pread, c2pwrite,<br/>                                errread, errwrite,<br/>                                restore_signals,<br/>                                gid, gids, uid, umask,<br/>                                start_new_session)<br/><br/>C:\Program Files\Python39\lib\subprocess.py:951: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Popen: returncode: None args: [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--...&gt;<br/>args = &#x27;./binaries/webdriver/chromedriver.exe --port=52296 --log-path=C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a0\\driver.log&#x27;<br/>executable = None, preexec_fn = None, close_fds = False, pass_fds = (), cwd = None<br/>env = environ({&#x27;__INTELLIJ_COMMAND_HISTFILE__&#x27;: &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\terminal\\..._ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)] (call)&#x27;})<br/>startupinfo = &lt;subprocess.STARTUPINFO object at 0x0000015C7B55BB80&gt;, creationflags = 0, shell = False, p2cread = Handle(1612), p2cwrite = 16, c2pread = -1<br/>c2pwrite = Handle(1620), errread = -1, errwrite = Handle(1616), unused_restore_signals = True, unused_gid = None, unused_gids = None, unused_uid = None<br/>unused_umask = -1, unused_start_new_session = False<br/><br/>    def _execute_child(self, args, executable, preexec_fn, close_fds,<br/>                       pass_fds, cwd, env,<br/>                       startupinfo, creationflags, shell,<br/>                       p2cread, p2cwrite,<br/>                       c2pread, c2pwrite,<br/>                       errread, errwrite,<br/>                       unused_restore_signals,<br/>                       unused_gid, unused_gids, unused_uid,<br/>                       unused_umask,<br/>                       unused_start_new_session):<br/>        &quot;&quot;&quot;Execute program (MS Windows version)&quot;&quot;&quot;<br/>    <br/>        assert not pass_fds, &quot;pass_fds not supported on Windows.&quot;<br/>    <br/>        if isinstance(args, str):<br/>            pass<br/>        elif isinstance(args, bytes):<br/>            if shell:<br/>                raise TypeError(&#x27;bytes args is not allowed on Windows&#x27;)<br/>            args = list2cmdline([args])<br/>        elif isinstance(args, os.PathLike):<br/>            if shell:<br/>                raise TypeError(&#x27;path-like args is not allowed when &#x27;<br/>                                &#x27;shell is true&#x27;)<br/>            args = list2cmdline([args])<br/>        else:<br/>            args = list2cmdline(args)<br/>    <br/>        if executable is not None:<br/>            executable = os.fsdecode(executable)<br/>    <br/>        # Process startup details<br/>        if startupinfo is None:<br/>            startupinfo = STARTUPINFO()<br/>        else:<br/>            # bpo-34044: Copy STARTUPINFO since it is modified above,<br/>            # so the caller can reuse it multiple times.<br/>            startupinfo = startupinfo.copy()<br/>    <br/>        use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)<br/>        if use_std_handles:<br/>            startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES<br/>            startupinfo.hStdInput = p2cread<br/>            startupinfo.hStdOutput = c2pwrite<br/>            startupinfo.hStdError = errwrite<br/>    <br/>        attribute_list = startupinfo.lpAttributeList<br/>        have_handle_list = bool(attribute_list and<br/>                                &quot;handle_list&quot; in attribute_list and<br/>                                attribute_list[&quot;handle_list&quot;])<br/>    <br/>        # If we were given an handle_list or need to create one<br/>        if have_handle_list or (use_std_handles and close_fds):<br/>            if attribute_list is None:<br/>                attribute_list = startupinfo.lpAttributeList = {}<br/>            handle_list = attribute_list[&quot;handle_list&quot;] = \<br/>                list(attribute_list.get(&quot;handle_list&quot;, []))<br/>    <br/>            if use_std_handles:<br/>                handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]<br/>    <br/>            handle_list[:] = self._filter_handle_list(handle_list)<br/>    <br/>            if handle_list:<br/>                if not close_fds:<br/>                    warnings.warn(&quot;startupinfo.lpAttributeList[&#x27;handle_list&#x27;] &quot;<br/>                                  &quot;overriding close_fds&quot;, RuntimeWarning)<br/>    <br/>                # When using the handle_list we always request to inherit<br/>                # handles but the only handles that will be inherited are<br/>                # the ones in the handle_list<br/>                close_fds = False<br/>    <br/>        if shell:<br/>            startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW<br/>            startupinfo.wShowWindow = _winapi.SW_HIDE<br/>            comspec = os.environ.get(&quot;COMSPEC&quot;, &quot;cmd.exe&quot;)<br/>            args = &#x27;{} /c &quot;{}&quot;&#x27;.format (comspec, args)<br/>    <br/>        if cwd is not None:<br/>            cwd = os.fsdecode(cwd)<br/>    <br/>        sys.audit(&quot;subprocess.Popen&quot;, executable, args, cwd, env)<br/>    <br/>        # Start the process<br/>        try:<br/>&gt;           hp, ht, pid, tid = _winapi.CreateProcess(executable, args,<br/>                                     # no special security<br/>                                     None, None,<br/>                                     int(not close_fds),<br/>                                     creationflags,<br/>                                     env,<br/>                                     cwd,<br/>                                     startupinfo)<br/><span class="error">E                                    FileNotFoundError: [WinError 2] The system cannot find the file specified</span><br/><br/>C:\Program Files\Python39\lib\subprocess.py:1420: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>request = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/>scenario = Scenario(feature=Feature(scenarios=OrderedDict([(&#x27;Verify PPC - Buttons and Anchor - Loading Button&#x27;, ScenarioTemplate(...eyword=&#x27;Then&#x27;, failed=None, scenario=None, background=None, lines=[])], tags={&#x27;TR-C393228&#x27;, &#x27;automated&#x27;, &#x27;regression&#x27;})<br/>step = Step(type=&#x27;given&#x27;, _name=&quot;I am on the page &#x27;/&#x27;&quot;, line_number=5, indent=8, keyword=&#x27;Given&#x27;, failed=True, scenario=None,...closeIcon&#x27;&quot;, line_number=8, indent=8, keyword=&#x27;And&#x27;, failed=None, scenario=None, background=..., lines=[])]), lines=[])<br/>context = StepFunctionContext(type=&#x27;given&#x27;, step_func=&lt;function open_webpage at 0x0000015C7A412820&gt;, parser=&lt;pytest_bdd.parsers....t at 0x0000015C7A40F7C0&gt;, converters={&#x27;page_url&#x27;: &lt;function env_formatted at 0x0000015C78B20700&gt;}, target_fixture=None)<br/><br/>    def _execute_step_function(<br/>        request: FixtureRequest, scenario: Scenario, step: Step, context: StepFunctionContext<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;Execute step function.&quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        kw = {<br/>            &quot;request&quot;: request,<br/>            &quot;feature&quot;: scenario.feature,<br/>            &quot;scenario&quot;: scenario,<br/>            &quot;step&quot;: step,<br/>            &quot;step_func&quot;: context.step_func,<br/>            &quot;step_func_args&quot;: {},<br/>        }<br/>    <br/>        request.config.hook.pytest_bdd_before_step(**kw)<br/>    <br/>        # Get the step argument values.<br/>        converters = context.converters<br/>        kwargs = {}<br/>        args = get_args(context.step_func)<br/>    <br/>        try:<br/>            parsed_args = context.parser.parse_arguments(step.name)<br/>            assert parsed_args is not None, (<br/>                f&quot;Unexpected `NoneType` returned from &quot; f&quot;parse_arguments(...) in parser: {context.parser!r}&quot;<br/>            )<br/>            for arg, value in parsed_args.items():<br/>                if arg in converters:<br/>                    value = converters[arg](value)<br/>                kwargs[arg] = value<br/>    <br/>&gt;           kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}<br/><br/>venv\lib\site-packages\pytest_bdd\scenario.py:154: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>.0 = &lt;list_iterator object at 0x0000015C7B505C70&gt;<br/><br/>&gt;   kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}<br/><br/>venv\lib\site-packages\pytest_bdd\scenario.py:154: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/>argname = &#x27;selenium_generics&#x27;<br/><br/>    def getfixturevalue(self, argname: str) -&gt; Any:<br/>        &quot;&quot;&quot;Dynamically run a named fixture function.<br/>    <br/>        Declaring fixtures via function argument is recommended where possible.<br/>        But if you can only decide whether to use another fixture at test<br/>        setup time, you may use this function to retrieve it inside a fixture<br/>        or test function body.<br/>    <br/>        :raises pytest.FixtureLookupError:<br/>            If the given fixture could not be found.<br/>        &quot;&quot;&quot;<br/>&gt;       fixturedef = self._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:581: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/>argname = &#x27;selenium_generics&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium_generics&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium_generics&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/>argname = &#x27;selenium&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/>argname = &#x27;selenium&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/>argname = &#x27;driver&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>            fixturedef = request._get_active_fixturedef(argname)<br/>            if argname != &quot;request&quot;:<br/>                # PseudoFixtureDef is only for &quot;request&quot;.<br/>                assert isinstance(fixturedef, FixtureDef)<br/>                fixturedef.addfinalizer(functools.partial(self.finish, request=request))<br/>    <br/>        my_cache_key = self.cache_key(request)<br/>        if self.cached_result is not None:<br/>            # note: comparison with `==` can fail (or be expensive) for e.g.<br/>            # numpy arrays (#6497).<br/>            cache_key = self.cached_result[1]<br/>            if my_cache_key is cache_key:<br/>                if self.cached_result[2] is not None:<br/>                    _, val, tb = self.cached_result[2]<br/>                    raise val.with_traceback(tb)<br/>                else:<br/>                    result = self.cached_result[0]<br/>                    return result<br/>            # We have a previous but differently parametrized fixture instance<br/>            # so we need to tear it down before creating a new one.<br/>            self.finish(request)<br/>            assert self.cached_result is None<br/>    <br/>        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)<br/>&gt;       result = hook.pytest_fixture_setup(fixturedef=self, request=request)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1072: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_HookCaller &#x27;pytest_fixture_setup&#x27;&gt;<br/>kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function..._verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;}<br/>firstresult = True<br/><br/>    def __call__(self, **kwargs: object) -&gt; Any:<br/>        assert (<br/>            not self.is_historic()<br/>        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;<br/>        self._verify_all_args_are_provided(kwargs)<br/>        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False<br/>&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_hooks.py:433: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_pytest.config.PytestPluginManager object at 0x0000015C7034A250&gt;, hook_name = &#x27;pytest_fixture_setup&#x27;<br/>methods = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function..._verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _hookexec(<br/>        self,<br/>        hook_name: str,<br/>        methods: Sequence[HookImpl],<br/>        kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        # called from all hookcaller instances.<br/>        # enable_tracing will set its own wrapping function at self._inner_hookexec<br/>&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_manager.py:112: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_name = &#x27;pytest_fixture_setup&#x27;<br/>hook_impls = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>caller_kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function..._verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _multicall(<br/>        hook_name: str,<br/>        hook_impls: Sequence[HookImpl],<br/>        caller_kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        results: list[object] = []<br/>        exception = None<br/>        only_new_style_wrappers = True<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns: list[Teardown] = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    f&quot;hook call must provide argument {argname!r}&quot;<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        only_new_style_wrappers = False<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            wrapper_gen = cast(Generator[None, _Result[object], None], res)<br/>                            next(wrapper_gen)  # first yield<br/>                            teardowns.append((wrapper_gen,))<br/>                        except StopIteration:<br/>                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)<br/>                    elif hook_impl.wrapper:<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            function_gen = cast(Generator[None, object, object], res)<br/>                            next(function_gen)  # first yield<br/>                            teardowns.append(function_gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)<br/>                    else:<br/>                        res = hook_impl.function(*args)<br/>                        if res is not None:<br/>                            results.append(res)<br/>                            if firstresult:  # halt further impl calls<br/>                                break<br/>            except BaseException as exc:<br/>                exception = exc<br/>        finally:<br/>            # Fast path - only new-style wrappers, no _Result.<br/>            if only_new_style_wrappers:<br/>                if firstresult:  # first result hooks return a single value<br/>                    result = results[0] if results else None<br/>                else:<br/>                    result = results<br/>    <br/>                # run all wrapper post-yield blocks<br/>                for teardown in reversed(teardowns):<br/>                    try:<br/>                        if exception is not None:<br/>                            teardown.throw(exception)  # type: ignore[union-attr]<br/>                        else:<br/>                            teardown.send(result)  # type: ignore[union-attr]<br/>                        # Following is unreachable for a well behaved hook wrapper.<br/>                        # Try to force finalizers otherwise postponed till GC action.<br/>                        # Note: close() may raise if generator handles GeneratorExit.<br/>                        teardown.close()  # type: ignore[union-attr]<br/>                    except StopIteration as si:<br/>                        result = si.value<br/>                        exception = None<br/>                        continue<br/>                    except BaseException as e:<br/>                        exception = e<br/>                        continue<br/>                    _raise_wrapfail(teardown, &quot;has second yield&quot;)  # type: ignore[arg-type]<br/>    <br/>                if exception is not None:<br/>                    raise exception.with_traceback(exception.__traceback__)<br/>                else:<br/>                    return result<br/>    <br/>            # Slow path - need to support old-style wrappers.<br/>            else:<br/>                if firstresult:  # first result hooks return a single value<br/>                    outcome: _Result[object | list[object]] = _Result(<br/>                        results[0] if results else None, exception<br/>                    )<br/>                else:<br/>                    outcome = _Result(results, exception)<br/>    <br/>                # run all wrapper post-yield blocks<br/>                for teardown in reversed(teardowns):<br/>                    if isinstance(teardown, tuple):<br/>                        try:<br/>                            teardown[0].send(outcome)<br/>                            _raise_wrapfail(teardown[0], &quot;has second yield&quot;)<br/>                        except StopIteration:<br/>                            pass<br/>                    else:<br/>                        try:<br/>                            if outcome._exception is not None:<br/>                                teardown.throw(outcome._exception)<br/>                            else:<br/>                                teardown.send(outcome._result)<br/>                            # Following is unreachable for a well behaved hook wrapper.<br/>                            # Try to force finalizers otherwise postponed till GC action.<br/>                            # Note: close() may raise if generator handles GeneratorExit.<br/>                            teardown.close()<br/>                        except StopIteration as si:<br/>                            outcome.force_result(si.value)<br/>                            continue<br/>                        except BaseException as e:<br/>                            outcome.force_exception(e)<br/>                            continue<br/>                        _raise_wrapfail(teardown, &quot;has second yield&quot;)<br/>    <br/>&gt;               return outcome.get_result()<br/><br/>venv\lib\site-packages\pluggy\_callers.py:155: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;pluggy._result._Result object at 0x0000015C7B55B700&gt;<br/><br/>    def get_result(self) -&gt; _T:<br/>        &quot;&quot;&quot;Get the result(s) for this hook call.<br/>    <br/>        If the hook was marked as a ``firstresult`` only a single value<br/>        will be returned, otherwise a list of results.<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        exc = self._exception<br/>        if exc is None:<br/>            return cast(_T, self._result)<br/>        else:<br/>&gt;           raise exc.with_traceback(exc.__traceback__)<br/><br/>venv\lib\site-packages\pluggy\_result.py:108: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_name = &#x27;pytest_fixture_setup&#x27;<br/>hook_impls = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>caller_kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function..._verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _multicall(<br/>        hook_name: str,<br/>        hook_impls: Sequence[HookImpl],<br/>        caller_kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        results: list[object] = []<br/>        exception = None<br/>        only_new_style_wrappers = True<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns: list[Teardown] = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    f&quot;hook call must provide argument {argname!r}&quot;<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        only_new_style_wrappers = False<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            wrapper_gen = cast(Generator[None, _Result[object], None], res)<br/>                            next(wrapper_gen)  # first yield<br/>                            teardowns.append((wrapper_gen,))<br/>                        except StopIteration:<br/>                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)<br/>                    elif hook_impl.wrapper:<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            function_gen = cast(Generator[None, object, object], res)<br/>                            next(function_gen)  # first yield<br/>                            teardowns.append(function_gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)<br/>                    else:<br/>&gt;                       res = hook_impl.function(*args)<br/><br/>venv\lib\site-packages\pluggy\_callers.py:80: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fixturedef = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/><br/>    def pytest_fixture_setup(<br/>        fixturedef: FixtureDef[_FixtureValue], request: SubRequest<br/>    ) -&gt; _FixtureValue:<br/>        &quot;&quot;&quot;Execution of fixture setup.&quot;&quot;&quot;<br/>        kwargs = {}<br/>        for argname in fixturedef.argnames:<br/>            fixdef = request._get_active_fixturedef(argname)<br/>            assert fixdef.cached_result is not None<br/>            result, arg_cache_key, exc = fixdef.cached_result<br/>            request._check_scope(argname, request.scope, fixdef.scope)<br/>            kwargs[argname] = result<br/>    <br/>        fixturefunc = resolve_fixture_function(fixturedef, request)<br/>        my_cache_key = fixturedef.cache_key(request)<br/>        try:<br/>&gt;           result = call_fixture_func(fixturefunc, request, kwargs)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1126: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fixturefunc = &lt;function driver at 0x0000015C787C44C0&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/>kwargs = {&#x27;driver_class&#x27;: &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;, &#x27;driver_kwargs&#x27;: {&#x27;desired_capabilities&#x27;: {&#x27;..._verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;}<br/><br/>    def call_fixture_func(<br/>        fixturefunc: &quot;_FixtureFunc[_FixtureValue]&quot;, request: FixtureRequest, kwargs<br/>    ) -&gt; _FixtureValue:<br/>        if is_generator(fixturefunc):<br/>            fixturefunc = cast(<br/>                Callable[..., Generator[_FixtureValue, None, None]], fixturefunc<br/>            )<br/>            generator = fixturefunc(**kwargs)<br/>            try:<br/>&gt;               fixture_result = next(generator)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:925: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/>driver_class = &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;<br/>driver_kwargs = {&#x27;desired_capabilities&#x27;: {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}, &#x27;executable_path&#x27;: &#x27;....\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a0\\driver.log&#x27;}<br/><br/>    @pytest.fixture<br/>    def driver(request, driver_class, driver_kwargs):<br/>        &quot;&quot;&quot;Returns a WebDriver instance based on options and capabilities&quot;&quot;&quot;<br/>    <br/>        retries = int(request.config.getini(&quot;max_driver_init_attempts&quot;))<br/>&gt;       for retry in Retrying(<br/>            stop=stop_after_attempt(retries), wait=wait_exponential(), reraise=True<br/>        ):<br/><br/>venv\lib\site-packages\pytest_selenium\pytest_selenium.py:201: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Retrying object at 0x15c7b55b850 (stop=&lt;tenacity.stop.stop_after_attempt object at 0x0000015C7B55B820&gt;, wait=&lt;tenacit...631370&gt;, before=&lt;function before_nothing at 0x0000015C7861BB80&gt;, after=&lt;function after_nothing at 0x0000015C7862F700&gt;)&gt;<br/><br/>    def __iter__(self):<br/>        self.begin(None)<br/>    <br/>        retry_state = RetryCallState(self, fn=None, args=(), kwargs={})<br/>        while True:<br/>&gt;           do = self.iter(retry_state=retry_state)<br/><br/>venv\lib\site-packages\tenacity\__init__.py:394: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Retrying object at 0x15c7b55b850 (stop=&lt;tenacity.stop.stop_after_attempt object at 0x0000015C7B55B820&gt;, wait=&lt;tenacit...631370&gt;, before=&lt;function before_nothing at 0x0000015C7861BB80&gt;, after=&lt;function after_nothing at 0x0000015C7862F700&gt;)&gt;<br/>retry_state = &lt;tenacity.RetryCallState object at 0x0000015C7B55B8E0&gt;<br/><br/>    def iter(self, retry_state):  # noqa<br/>        fut = retry_state.outcome<br/>        if fut is None:<br/>            if self.before is not None:<br/>                self.before(retry_state)<br/>            return DoAttempt()<br/>    <br/>        is_explicit_retry = retry_state.outcome.failed \<br/>            and isinstance(retry_state.outcome.exception(), TryAgain)<br/>        if not (is_explicit_retry or self.retry(retry_state=retry_state)):<br/>            return fut.result()<br/>    <br/>        if self.after is not None:<br/>            self.after(retry_state=retry_state)<br/>    <br/>        self.statistics[&#x27;delay_since_first_attempt&#x27;] = \<br/>            retry_state.seconds_since_start<br/>        if self.stop(retry_state=retry_state):<br/>            if self.retry_error_callback:<br/>                return self.retry_error_callback(retry_state=retry_state)<br/>            retry_exc = self.retry_error_cls(fut)<br/>            if self.reraise:<br/>&gt;               raise retry_exc.reraise()<br/><br/>venv\lib\site-packages\tenacity\__init__.py:372: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = RetryError(&lt;Future at 0x15c7b55b9d0 state=finished raised WebDriverException&gt;)<br/><br/>    def reraise(self):<br/>        if self.last_attempt.failed:<br/>&gt;           raise self.last_attempt.result()<br/><br/>venv\lib\site-packages\tenacity\__init__.py:189: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = None, timeout = None<br/><br/>    def result(self, timeout=None):<br/>        &quot;&quot;&quot;Return the result of the call that the future represents.<br/>    <br/>        Args:<br/>            timeout: The number of seconds to wait for the result if the future<br/>                isn&#x27;t done. If None, then there is no limit on the wait time.<br/>    <br/>        Returns:<br/>            The result of the call that the future represents.<br/>    <br/>        Raises:<br/>            CancelledError: If the future was cancelled.<br/>            TimeoutError: If the future didn&#x27;t finish executing before the given<br/>                timeout.<br/>            Exception: If the call raised then that exception will be raised.<br/>        &quot;&quot;&quot;<br/>        try:<br/>            with self._condition:<br/>                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:<br/>                    raise CancelledError()<br/>                elif self._state == FINISHED:<br/>&gt;                   return self.__get_result()<br/><br/>C:\Program Files\Python39\lib\concurrent\futures\_base.py:439: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = None<br/><br/>    def __get_result(self):<br/>        if self._exception:<br/>            try:<br/>&gt;               raise self._exception<br/><br/>C:\Program Files\Python39\lib\concurrent\futures\_base.py:391: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-background-color-rgba(0, 0, 201, 1)]&gt;&gt;<br/>driver_class = &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;<br/>driver_kwargs = {&#x27;desired_capabilities&#x27;: {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}, &#x27;executable_path&#x27;: &#x27;....\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a0\\driver.log&#x27;}<br/><br/>    @pytest.fixture<br/>    def driver(request, driver_class, driver_kwargs):<br/>        &quot;&quot;&quot;Returns a WebDriver instance based on options and capabilities&quot;&quot;&quot;<br/>    <br/>        retries = int(request.config.getini(&quot;max_driver_init_attempts&quot;))<br/>        for retry in Retrying(<br/>            stop=stop_after_attempt(retries), wait=wait_exponential(), reraise=True<br/>        ):<br/>            with retry:<br/>                LOGGER.info(<br/>                    f&quot;Driver init, attempt {retry.retry_state.attempt_number}/{retries}&quot;<br/>                )<br/>&gt;               driver = driver_class(**driver_kwargs)<br/><br/>venv\lib\site-packages\pytest_selenium\pytest_selenium.py:208: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[AttributeError(&quot;&#x27;WebDriver&#x27; object has no attribute &#x27;session_id&#x27;&quot;) raised in repr()] WebDriver object at 0x15c7b55ba00&gt;<br/>executable_path = &#x27;./binaries/webdriver/chromedriver.exe&#x27;, port = 0, options = &lt;selenium.webdriver.chrome.options.Options object at 0x0000015C7B55B460&gt;<br/>service_args = None, desired_capabilities = {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}<br/>service_log_path = &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a0\\driver.log&#x27;<br/>chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7B55B970&gt;, keep_alive = True<br/><br/>    def __init__(self, executable_path=DEFAULT_EXECUTABLE_PATH, port=DEFAULT_PORT,<br/>                 options: Options = None, service_args=None,<br/>                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,<br/>                 chrome_options=None, service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):<br/>        &quot;&quot;&quot;<br/>        Creates a new instance of the chrome driver.<br/>        Starts the service and then creates new instance of chrome driver.<br/>    <br/>        :Args:<br/>         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH<br/>         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.<br/>         - options - this takes an instance of ChromeOptions<br/>         - service - Service object for handling the browser driver if you need to pass extra details<br/>         - service_args - Deprecated: List of args to pass to the driver service<br/>         - desired_capabilities - Deprecated: Dictionary object with non-browser specific<br/>           capabilities only, such as &quot;proxy&quot; or &quot;loggingPref&quot;.<br/>         - service_log_path - Deprecated: Where to log information from the driver.<br/>         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.<br/>        &quot;&quot;&quot;<br/>        if executable_path != &#x27;chromedriver&#x27;:<br/>            warnings.warn(&#x27;executable_path has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if chrome_options:<br/>            warnings.warn(&#x27;use options instead of chrome_options&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>            options = chrome_options<br/>        if keep_alive != DEFAULT_KEEP_ALIVE:<br/>            warnings.warn(&#x27;keep_alive has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        else:<br/>            keep_alive = True<br/>        if not service:<br/>            service = Service(executable_path, port, service_args, service_log_path)<br/>    <br/>&gt;       super(WebDriver, self).__init__(DesiredCapabilities.CHROME[&#x27;browserName&#x27;], &quot;goog&quot;,<br/>                                        port, options,<br/>                                        service_args, desired_capabilities,<br/>                                        service_log_path, service, keep_alive)<br/><br/>venv\lib\site-packages\selenium\webdriver\chrome\webdriver.py:70: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[AttributeError(&quot;&#x27;WebDriver&#x27; object has no attribute &#x27;session_id&#x27;&quot;) raised in repr()] WebDriver object at 0x15c7b55ba00&gt;, browser_name = &#x27;chrome&#x27;<br/>vendor_prefix = &#x27;goog&#x27;, port = 0, options = &lt;selenium.webdriver.chrome.options.Options object at 0x0000015C7B55B460&gt;, service_args = None<br/>desired_capabilities = {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}<br/>service_log_path = &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a0\\driver.log&#x27;<br/>service = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7B55B970&gt;, keep_alive = True<br/><br/>    def __init__(self, browser_name, vendor_prefix,<br/>                 port=DEFAULT_PORT, options: BaseOptions = None, service_args=None,<br/>                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,<br/>                 service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):<br/>        &quot;&quot;&quot;<br/>        Creates a new WebDriver instance of the ChromiumDriver.<br/>        Starts the service and then creates new WebDriver instance of ChromiumDriver.<br/>    <br/>        :Args:<br/>         - browser_name - Browser name used when matching capabilities.<br/>         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.<br/>         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.<br/>         - options - this takes an instance of ChromiumOptions<br/>         - service_args - Deprecated: List of args to pass to the driver service<br/>         - desired_capabilities - Deprecated: Dictionary object with non-browser specific<br/>           capabilities only, such as &quot;proxy&quot; or &quot;loggingPref&quot;.<br/>         - service_log_path - Deprecated: Where to log information from the driver.<br/>         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.<br/>        &quot;&quot;&quot;<br/>        if desired_capabilities:<br/>            warnings.warn(&#x27;desired_capabilities has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if port != DEFAULT_PORT:<br/>            warnings.warn(&#x27;port has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        self.port = port<br/>        if service_log_path != DEFAULT_SERVICE_LOG_PATH:<br/>            warnings.warn(&#x27;service_log_path has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:<br/>            warnings.warn(&#x27;keep_alive has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        else:<br/>            keep_alive = True<br/>    <br/>        self.vendor_prefix = vendor_prefix<br/>    <br/>        _ignore_proxy = None<br/>        if not options:<br/>            options = self.create_options()<br/>    <br/>        if desired_capabilities:<br/>            for key, value in desired_capabilities.items():<br/>                options.set_capability(key, value)<br/>    <br/>        if options._ignore_local_proxy:<br/>            _ignore_proxy = options._ignore_local_proxy<br/>    <br/>        if not service:<br/>            raise AttributeError(&#x27;service cannot be None&#x27;)<br/>    <br/>        self.service = service<br/>&gt;       self.service.start()<br/><br/>venv\lib\site-packages\selenium\webdriver\chromium\webdriver.py:90: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7B55B970&gt;<br/><br/>    def start(self):<br/>        &quot;&quot;&quot;<br/>        Starts the Service.<br/>    <br/>        :Exceptions:<br/>         - WebDriverException : Raised either when it can&#x27;t start the service<br/>           or when it can&#x27;t connect to the service<br/>        &quot;&quot;&quot;<br/>        try:<br/>            cmd = [self.path]<br/>            cmd.extend(self.command_line_args())<br/>            self.process = subprocess.Popen(cmd, env=self.env,<br/>                                            close_fds=system() != &#x27;Windows&#x27;,<br/>                                            stdout=self.log_file,<br/>                                            stderr=self.log_file,<br/>                                            stdin=PIPE,<br/>                                            creationflags=self.creationflags)<br/>        except TypeError:<br/>            raise<br/>        except OSError as err:<br/>            if err.errno == errno.ENOENT:<br/>&gt;               raise WebDriverException(<br/>                    &quot;&#x27;%s&#x27; executable needs to be in PATH. %s&quot; % (<br/>                        os.path.basename(self.path), self.start_error_message)<br/><span class="error">E                       selenium.common.exceptions.WebDriverException: Message: &#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.chromium.org/home</span><br/><br/>venv\lib\site-packages\selenium\webdriver\common\service.py:81: WebDriverException<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;_HookCaller &#x27;pytest_bdd_step_error&#x27;&gt;<br/>kwargs = {&#x27;exception&#x27;: WebDriverException(&quot;&#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.c...=&#x27;Then&#x27;, failed=None, scenario=None, background=None, lines=[])], tags={&#x27;TR-C393228&#x27;, &#x27;automated&#x27;, &#x27;regression&#x27;}), ...}<br/>firstresult = False<br/><br/>    def __call__(self, **kwargs: object) -&gt; Any:<br/>        assert (<br/>            not self.is_historic()<br/>        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;<br/>        self._verify_all_args_are_provided(kwargs)<br/>        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False<br/>&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_hooks.py:433: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv\lib\site-packages\pluggy\_manager.py:112: in _hookexec<br/>    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)<br/>venv\lib\site-packages\enhanced_reports\core.py:493: in pytest_bdd_step_error<br/>    __capture_js_logs(current_state, driver, op_name)<br/>venv\lib\site-packages\enhanced_reports\core.py:234: in __capture_js_logs<br/>    logs = browser_console_manager.get_js_logs(driver)<br/>venv\lib\site-packages\enhanced_reports\browser_console_manager.py:13: in get_js_logs<br/>    logs = _capture_output(driver)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>driver = None<br/><br/>    def _capture_output(driver: WebDriver):<br/>&gt;       return driver.get_log(&quot;browser&quot;)<br/><span class="error">E       AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;get_log&#x27;</span><br/><br/>venv\lib\site-packages\enhanced_reports\browser_console_manager.py:18: AttributeError<br/> -----------------------------Captured stderr setup------------------------------ <br/>2023-06-22 05:35:18 [info     ] current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 05:35:18 [info     ] Loaded C:\Users\DIXITA19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\frontend\grv_project\plugins\enhanced_reports\config.py
2023-06-22 05:35:18 [info     ] Loaded c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\enhanced_reports\report_libs\allure_pytest_bdd.py
2023-06-22 05:35:19 [info     ] current param_value False
<br/> -------------------------------Captured log setup------------------------------- <br/>2023-06-22 11:05:18 INFO current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 11:05:18 INFO Loaded C:\Users\DIXITA19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\frontend\grv_project\plugins\enhanced_reports\config.py
2023-06-22 11:05:18 INFO Loaded c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\enhanced_reports\report_libs\allure_pytest_bdd.py
2023-06-22 11:05:19 INFO current param_value False<br/> ------------------------------Captured stderr call------------------------------ <br/>

2023-06-22 05:35:19 [info     ] Scenario Execution Started.    feature=Galaxy automated regression - button and anchor components scenario_name=Verify PPC - Buttons and Anchor - Loading Button
2023-06-22 05:35:19 [info     ] Capabilities from markers: {}
2023-06-22 05:35:19 [info     ] Driver init, attempt 1/3
2023-06-22 05:35:20 [info     ] Driver init, attempt 2/3
2023-06-22 05:35:22 [info     ] Driver init, attempt 3/3
2023-06-22 05:35:22 [error    ] Step FAILED.                   step=I am on the page &#x27;/&#x27;
Traceback (most recent call last):
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\common\service.py&quot;, line 71, in start
    self.process = subprocess.Popen(cmd, env=self.env,
  File &quot;C:\Program Files\Python39\lib\subprocess.py&quot;, line 951, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File &quot;C:\Program Files\Python39\lib\subprocess.py&quot;, line 1420, in _execute_child
    hp, ht, pid, tid = _winapi.CreateProcess(executable, args,
FileNotFoundError: [WinError 2] The system cannot find the file specified

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_bdd\scenario.py&quot;, line 154, in _execute_step_function
    kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_bdd\scenario.py&quot;, line 154, in &lt;dictcomp&gt;
    kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 581, in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1072, in execute
    result = hook.pytest_fixture_setup(fixturedef=self, request=request)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_hooks.py&quot;, line 433, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_manager.py&quot;, line 112, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_callers.py&quot;, line 155, in _multicall
    return outcome.get_result()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_result.py&quot;, line 108, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_callers.py&quot;, line 80, in _multicall
    res = hook_impl.function(*args)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1126, in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 925, in call_fixture_func
    fixture_result = next(generator)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_selenium\pytest_selenium.py&quot;, line 201, in driver
    for retry in Retrying(
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 394, in __iter__
    do = self.iter(retry_state=retry_state)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 372, in iter
    raise retry_exc.reraise()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 189, in reraise
    raise self.last_attempt.result()
  File &quot;C:\Program Files\Python39\lib\concurrent\futures\_base.py&quot;, line 439, in result
    return self.__get_result()
  File &quot;C:\Program Files\Python39\lib\concurrent\futures\_base.py&quot;, line 391, in __get_result
    raise self._exception
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_selenium\pytest_selenium.py&quot;, line 208, in driver
    driver = driver_class(**driver_kwargs)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\chrome\webdriver.py&quot;, line 70, in __init__
    super(WebDriver, self).__init__(DesiredCapabilities.CHROME[&#x27;browserName&#x27;], &quot;goog&quot;,
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\chromium\webdriver.py&quot;, line 90, in __init__
    self.service.start()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\common\service.py&quot;, line 81, in start
    raise WebDriverException(
selenium.common.exceptions.WebDriverException: Message: &#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.chromium.org/home

2023-06-22 05:35:22 [info     ] current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 05:35:22 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
2023-06-22 05:35:22 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
2023-06-22 05:35:22 [info     ] Scenario Execution Completed.  feature=Galaxy automated regression - button and anchor components scenario_name=Verify PPC - Buttons and Anchor - Loading Button
2023-06-22 05:35:22 [info     ] current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 05:35:22 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-section">Galaxy automated regression -&gt; button and anchor components</td>
          <td class="col-tags">TR-C393228</td>
          <td class="col-name">Verify PPC - Buttons and Anchor - Loading Button  locator: helixComponent &gt; loading_button, attribute: color, value: rgba(255, 255, 255, 1)</td>
          <td class="col-result">Failed</td>
          <td class="col-duration">00:03.04</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="6">
            <div class="log">self = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7A665BB0&gt;<br/><br/>    def start(self):<br/>        &quot;&quot;&quot;<br/>        Starts the Service.<br/>    <br/>        :Exceptions:<br/>         - WebDriverException : Raised either when it can&#x27;t start the service<br/>           or when it can&#x27;t connect to the service<br/>        &quot;&quot;&quot;<br/>        try:<br/>            cmd = [self.path]<br/>            cmd.extend(self.command_line_args())<br/>&gt;           self.process = subprocess.Popen(cmd, env=self.env,<br/>                                            close_fds=system() != &#x27;Windows&#x27;,<br/>                                            stdout=self.log_file,<br/>                                            stderr=self.log_file,<br/>                                            stdin=PIPE,<br/>                                            creationflags=self.creationflags)<br/><br/>venv\lib\site-packages\selenium\webdriver\common\service.py:71: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Popen: returncode: None args: [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--...&gt;<br/>args = [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--port=52299&#x27;, &#x27;--log-path=C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a1\\driver.log&#x27;]<br/>bufsize = -1, executable = None, stdin = -1, stdout = -3, stderr = -3, preexec_fn = None, close_fds = False, shell = False, cwd = None<br/>env = environ({&#x27;__INTELLIJ_COMMAND_HISTFILE__&#x27;: &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\terminal\\..._verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)] (call)&#x27;})<br/>universal_newlines = None, startupinfo = None, creationflags = 0, restore_signals = True, start_new_session = False, pass_fds = ()<br/><br/>    def __init__(self, args, bufsize=-1, executable=None,<br/>                 stdin=None, stdout=None, stderr=None,<br/>                 preexec_fn=None, close_fds=True,<br/>                 shell=False, cwd=None, env=None, universal_newlines=None,<br/>                 startupinfo=None, creationflags=0,<br/>                 restore_signals=True, start_new_session=False,<br/>                 pass_fds=(), *, user=None, group=None, extra_groups=None,<br/>                 encoding=None, errors=None, text=None, umask=-1):<br/>        &quot;&quot;&quot;Create new Popen instance.&quot;&quot;&quot;<br/>        _cleanup()<br/>        # Held while anything is calling waitpid before returncode has been<br/>        # updated to prevent clobbering returncode if wait() or poll() are<br/>        # called from multiple threads at once.  After acquiring the lock,<br/>        # code must re-check self.returncode to see if another thread just<br/>        # finished a waitpid() call.<br/>        self._waitpid_lock = threading.Lock()<br/>    <br/>        self._input = None<br/>        self._communication_started = False<br/>        if bufsize is None:<br/>            bufsize = -1  # Restore default<br/>        if not isinstance(bufsize, int):<br/>            raise TypeError(&quot;bufsize must be an integer&quot;)<br/>    <br/>        if _mswindows:<br/>            if preexec_fn is not None:<br/>                raise ValueError(&quot;preexec_fn is not supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>        else:<br/>            # POSIX<br/>            if pass_fds and not close_fds:<br/>                warnings.warn(&quot;pass_fds overriding close_fds.&quot;, RuntimeWarning)<br/>                close_fds = True<br/>            if startupinfo is not None:<br/>                raise ValueError(&quot;startupinfo is only supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>            if creationflags != 0:<br/>                raise ValueError(&quot;creationflags is only supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>    <br/>        self.args = args<br/>        self.stdin = None<br/>        self.stdout = None<br/>        self.stderr = None<br/>        self.pid = None<br/>        self.returncode = None<br/>        self.encoding = encoding<br/>        self.errors = errors<br/>    <br/>        # Validate the combinations of text and universal_newlines<br/>        if (text is not None and universal_newlines is not None<br/>            and bool(universal_newlines) != bool(text)):<br/>            raise SubprocessError(&#x27;Cannot disambiguate when both text &#x27;<br/>                                  &#x27;and universal_newlines are supplied but &#x27;<br/>                                  &#x27;different. Pass one or the other.&#x27;)<br/>    <br/>        # Input and output objects. The general principle is like<br/>        # this:<br/>        #<br/>        # Parent                   Child<br/>        # ------                   -----<br/>        # p2cwrite   ---stdin---&gt;  p2cread<br/>        # c2pread    &lt;--stdout---  c2pwrite<br/>        # errread    &lt;--stderr---  errwrite<br/>        #<br/>        # On POSIX, the child objects are file descriptors.  On<br/>        # Windows, these are Windows file handles.  The parent objects<br/>        # are file descriptors on both platforms.  The parent objects<br/>        # are -1 when not using PIPEs. The child objects are -1<br/>        # when not redirecting.<br/>    <br/>        (p2cread, p2cwrite,<br/>         c2pread, c2pwrite,<br/>         errread, errwrite) = self._get_handles(stdin, stdout, stderr)<br/>    <br/>        # We wrap OS handles *before* launching the child, otherwise a<br/>        # quickly terminating child could make our fds unwrappable<br/>        # (see #8458).<br/>    <br/>        if _mswindows:<br/>            if p2cwrite != -1:<br/>                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)<br/>            if c2pread != -1:<br/>                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)<br/>            if errread != -1:<br/>                errread = msvcrt.open_osfhandle(errread.Detach(), 0)<br/>    <br/>        self.text_mode = encoding or errors or text or universal_newlines<br/>    <br/>        # How long to resume waiting on a child after the first ^C.<br/>        # There is no right value for this.  The purpose is to be polite<br/>        # yet remain good for interactive users trying to exit a tool.<br/>        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()<br/>    <br/>        self._closed_child_pipe_fds = False<br/>    <br/>        if self.text_mode:<br/>            if bufsize == 1:<br/>                line_buffering = True<br/>                # Use the default buffer size for the underlying binary streams<br/>                # since they don&#x27;t support line buffering.<br/>                bufsize = -1<br/>            else:<br/>                line_buffering = False<br/>    <br/>        gid = None<br/>        if group is not None:<br/>            if not hasattr(os, &#x27;setregid&#x27;):<br/>                raise ValueError(&quot;The &#x27;group&#x27; parameter is not supported on the &quot;<br/>                                 &quot;current platform&quot;)<br/>    <br/>            elif isinstance(group, str):<br/>                if grp is None:<br/>                    raise ValueError(&quot;The group parameter cannot be a string &quot;<br/>                                     &quot;on systems without the grp module&quot;)<br/>    <br/>                gid = grp.getgrnam(group).gr_gid<br/>            elif isinstance(group, int):<br/>                gid = group<br/>            else:<br/>                raise TypeError(&quot;Group must be a string or an integer, not {}&quot;<br/>                                .format(type(group)))<br/>    <br/>            if gid &lt; 0:<br/>                raise ValueError(f&quot;Group ID cannot be negative, got {gid}&quot;)<br/>    <br/>        gids = None<br/>        if extra_groups is not None:<br/>            if not hasattr(os, &#x27;setgroups&#x27;):<br/>                raise ValueError(&quot;The &#x27;extra_groups&#x27; parameter is not &quot;<br/>                                 &quot;supported on the current platform&quot;)<br/>    <br/>            elif isinstance(extra_groups, str):<br/>                raise ValueError(&quot;Groups must be a list, not a string&quot;)<br/>    <br/>            gids = []<br/>            for extra_group in extra_groups:<br/>                if isinstance(extra_group, str):<br/>                    if grp is None:<br/>                        raise ValueError(&quot;Items in extra_groups cannot be &quot;<br/>                                         &quot;strings on systems without the &quot;<br/>                                         &quot;grp module&quot;)<br/>    <br/>                    gids.append(grp.getgrnam(extra_group).gr_gid)<br/>                elif isinstance(extra_group, int):<br/>                    gids.append(extra_group)<br/>                else:<br/>                    raise TypeError(&quot;Items in extra_groups must be a string &quot;<br/>                                    &quot;or integer, not {}&quot;<br/>                                    .format(type(extra_group)))<br/>    <br/>            # make sure that the gids are all positive here so we can do less<br/>            # checking in the C code<br/>            for gid_check in gids:<br/>                if gid_check &lt; 0:<br/>                    raise ValueError(f&quot;Group ID cannot be negative, got {gid_check}&quot;)<br/>    <br/>        uid = None<br/>        if user is not None:<br/>            if not hasattr(os, &#x27;setreuid&#x27;):<br/>                raise ValueError(&quot;The &#x27;user&#x27; parameter is not supported on &quot;<br/>                                 &quot;the current platform&quot;)<br/>    <br/>            elif isinstance(user, str):<br/>                if pwd is None:<br/>                    raise ValueError(&quot;The user parameter cannot be a string &quot;<br/>                                     &quot;on systems without the pwd module&quot;)<br/>    <br/>                uid = pwd.getpwnam(user).pw_uid<br/>            elif isinstance(user, int):<br/>                uid = user<br/>            else:<br/>                raise TypeError(&quot;User must be a string or an integer&quot;)<br/>    <br/>            if uid &lt; 0:<br/>                raise ValueError(f&quot;User ID cannot be negative, got {uid}&quot;)<br/>    <br/>        try:<br/>            if p2cwrite != -1:<br/>                self.stdin = io.open(p2cwrite, &#x27;wb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,<br/>                            line_buffering=line_buffering,<br/>                            encoding=encoding, errors=errors)<br/>            if c2pread != -1:<br/>                self.stdout = io.open(c2pread, &#x27;rb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stdout = io.TextIOWrapper(self.stdout,<br/>                            encoding=encoding, errors=errors)<br/>            if errread != -1:<br/>                self.stderr = io.open(errread, &#x27;rb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stderr = io.TextIOWrapper(self.stderr,<br/>                            encoding=encoding, errors=errors)<br/>    <br/>&gt;           self._execute_child(args, executable, preexec_fn, close_fds,<br/>                                pass_fds, cwd, env,<br/>                                startupinfo, creationflags, shell,<br/>                                p2cread, p2cwrite,<br/>                                c2pread, c2pwrite,<br/>                                errread, errwrite,<br/>                                restore_signals,<br/>                                gid, gids, uid, umask,<br/>                                start_new_session)<br/><br/>C:\Program Files\Python39\lib\subprocess.py:951: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Popen: returncode: None args: [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--...&gt;<br/>args = &#x27;./binaries/webdriver/chromedriver.exe --port=52299 --log-path=C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a1\\driver.log&#x27;<br/>executable = None, preexec_fn = None, close_fds = False, pass_fds = (), cwd = None<br/>env = environ({&#x27;__INTELLIJ_COMMAND_HISTFILE__&#x27;: &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\terminal\\..._verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)] (call)&#x27;})<br/>startupinfo = &lt;subprocess.STARTUPINFO object at 0x0000015C7A642F40&gt;, creationflags = 0, shell = False, p2cread = Handle(1584), p2cwrite = 16, c2pread = -1<br/>c2pwrite = Handle(1564), errread = -1, errwrite = Handle(1372), unused_restore_signals = True, unused_gid = None, unused_gids = None, unused_uid = None<br/>unused_umask = -1, unused_start_new_session = False<br/><br/>    def _execute_child(self, args, executable, preexec_fn, close_fds,<br/>                       pass_fds, cwd, env,<br/>                       startupinfo, creationflags, shell,<br/>                       p2cread, p2cwrite,<br/>                       c2pread, c2pwrite,<br/>                       errread, errwrite,<br/>                       unused_restore_signals,<br/>                       unused_gid, unused_gids, unused_uid,<br/>                       unused_umask,<br/>                       unused_start_new_session):<br/>        &quot;&quot;&quot;Execute program (MS Windows version)&quot;&quot;&quot;<br/>    <br/>        assert not pass_fds, &quot;pass_fds not supported on Windows.&quot;<br/>    <br/>        if isinstance(args, str):<br/>            pass<br/>        elif isinstance(args, bytes):<br/>            if shell:<br/>                raise TypeError(&#x27;bytes args is not allowed on Windows&#x27;)<br/>            args = list2cmdline([args])<br/>        elif isinstance(args, os.PathLike):<br/>            if shell:<br/>                raise TypeError(&#x27;path-like args is not allowed when &#x27;<br/>                                &#x27;shell is true&#x27;)<br/>            args = list2cmdline([args])<br/>        else:<br/>            args = list2cmdline(args)<br/>    <br/>        if executable is not None:<br/>            executable = os.fsdecode(executable)<br/>    <br/>        # Process startup details<br/>        if startupinfo is None:<br/>            startupinfo = STARTUPINFO()<br/>        else:<br/>            # bpo-34044: Copy STARTUPINFO since it is modified above,<br/>            # so the caller can reuse it multiple times.<br/>            startupinfo = startupinfo.copy()<br/>    <br/>        use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)<br/>        if use_std_handles:<br/>            startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES<br/>            startupinfo.hStdInput = p2cread<br/>            startupinfo.hStdOutput = c2pwrite<br/>            startupinfo.hStdError = errwrite<br/>    <br/>        attribute_list = startupinfo.lpAttributeList<br/>        have_handle_list = bool(attribute_list and<br/>                                &quot;handle_list&quot; in attribute_list and<br/>                                attribute_list[&quot;handle_list&quot;])<br/>    <br/>        # If we were given an handle_list or need to create one<br/>        if have_handle_list or (use_std_handles and close_fds):<br/>            if attribute_list is None:<br/>                attribute_list = startupinfo.lpAttributeList = {}<br/>            handle_list = attribute_list[&quot;handle_list&quot;] = \<br/>                list(attribute_list.get(&quot;handle_list&quot;, []))<br/>    <br/>            if use_std_handles:<br/>                handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]<br/>    <br/>            handle_list[:] = self._filter_handle_list(handle_list)<br/>    <br/>            if handle_list:<br/>                if not close_fds:<br/>                    warnings.warn(&quot;startupinfo.lpAttributeList[&#x27;handle_list&#x27;] &quot;<br/>                                  &quot;overriding close_fds&quot;, RuntimeWarning)<br/>    <br/>                # When using the handle_list we always request to inherit<br/>                # handles but the only handles that will be inherited are<br/>                # the ones in the handle_list<br/>                close_fds = False<br/>    <br/>        if shell:<br/>            startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW<br/>            startupinfo.wShowWindow = _winapi.SW_HIDE<br/>            comspec = os.environ.get(&quot;COMSPEC&quot;, &quot;cmd.exe&quot;)<br/>            args = &#x27;{} /c &quot;{}&quot;&#x27;.format (comspec, args)<br/>    <br/>        if cwd is not None:<br/>            cwd = os.fsdecode(cwd)<br/>    <br/>        sys.audit(&quot;subprocess.Popen&quot;, executable, args, cwd, env)<br/>    <br/>        # Start the process<br/>        try:<br/>&gt;           hp, ht, pid, tid = _winapi.CreateProcess(executable, args,<br/>                                     # no special security<br/>                                     None, None,<br/>                                     int(not close_fds),<br/>                                     creationflags,<br/>                                     env,<br/>                                     cwd,<br/>                                     startupinfo)<br/><span class="error">E                                    FileNotFoundError: [WinError 2] The system cannot find the file specified</span><br/><br/>C:\Program Files\Python39\lib\subprocess.py:1420: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>request = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>scenario = Scenario(feature=Feature(scenarios=OrderedDict([(&#x27;Verify PPC - Buttons and Anchor - Loading Button&#x27;, ScenarioTemplate(...eyword=&#x27;Then&#x27;, failed=None, scenario=None, background=None, lines=[])], tags={&#x27;TR-C393228&#x27;, &#x27;automated&#x27;, &#x27;regression&#x27;})<br/>step = Step(type=&#x27;given&#x27;, _name=&quot;I am on the page &#x27;/&#x27;&quot;, line_number=5, indent=8, keyword=&#x27;Given&#x27;, failed=True, scenario=None,...closeIcon&#x27;&quot;, line_number=8, indent=8, keyword=&#x27;And&#x27;, failed=None, scenario=None, background=..., lines=[])]), lines=[])<br/>context = StepFunctionContext(type=&#x27;given&#x27;, step_func=&lt;function open_webpage at 0x0000015C7A412820&gt;, parser=&lt;pytest_bdd.parsers....t at 0x0000015C7A40F7C0&gt;, converters={&#x27;page_url&#x27;: &lt;function env_formatted at 0x0000015C78B20700&gt;}, target_fixture=None)<br/><br/>    def _execute_step_function(<br/>        request: FixtureRequest, scenario: Scenario, step: Step, context: StepFunctionContext<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;Execute step function.&quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        kw = {<br/>            &quot;request&quot;: request,<br/>            &quot;feature&quot;: scenario.feature,<br/>            &quot;scenario&quot;: scenario,<br/>            &quot;step&quot;: step,<br/>            &quot;step_func&quot;: context.step_func,<br/>            &quot;step_func_args&quot;: {},<br/>        }<br/>    <br/>        request.config.hook.pytest_bdd_before_step(**kw)<br/>    <br/>        # Get the step argument values.<br/>        converters = context.converters<br/>        kwargs = {}<br/>        args = get_args(context.step_func)<br/>    <br/>        try:<br/>            parsed_args = context.parser.parse_arguments(step.name)<br/>            assert parsed_args is not None, (<br/>                f&quot;Unexpected `NoneType` returned from &quot; f&quot;parse_arguments(...) in parser: {context.parser!r}&quot;<br/>            )<br/>            for arg, value in parsed_args.items():<br/>                if arg in converters:<br/>                    value = converters[arg](value)<br/>                kwargs[arg] = value<br/>    <br/>&gt;           kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}<br/><br/>venv\lib\site-packages\pytest_bdd\scenario.py:154: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>.0 = &lt;list_iterator object at 0x0000015C7A6171C0&gt;<br/><br/>&gt;   kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}<br/><br/>venv\lib\site-packages\pytest_bdd\scenario.py:154: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>argname = &#x27;selenium_generics&#x27;<br/><br/>    def getfixturevalue(self, argname: str) -&gt; Any:<br/>        &quot;&quot;&quot;Dynamically run a named fixture function.<br/>    <br/>        Declaring fixtures via function argument is recommended where possible.<br/>        But if you can only decide whether to use another fixture at test<br/>        setup time, you may use this function to retrieve it inside a fixture<br/>        or test function body.<br/>    <br/>        :raises pytest.FixtureLookupError:<br/>            If the given fixture could not be found.<br/>        &quot;&quot;&quot;<br/>&gt;       fixturedef = self._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:581: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>argname = &#x27;selenium_generics&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium_generics&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium_generics&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>argname = &#x27;selenium&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>argname = &#x27;selenium&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>argname = &#x27;driver&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>            fixturedef = request._get_active_fixturedef(argname)<br/>            if argname != &quot;request&quot;:<br/>                # PseudoFixtureDef is only for &quot;request&quot;.<br/>                assert isinstance(fixturedef, FixtureDef)<br/>                fixturedef.addfinalizer(functools.partial(self.finish, request=request))<br/>    <br/>        my_cache_key = self.cache_key(request)<br/>        if self.cached_result is not None:<br/>            # note: comparison with `==` can fail (or be expensive) for e.g.<br/>            # numpy arrays (#6497).<br/>            cache_key = self.cached_result[1]<br/>            if my_cache_key is cache_key:<br/>                if self.cached_result[2] is not None:<br/>                    _, val, tb = self.cached_result[2]<br/>                    raise val.with_traceback(tb)<br/>                else:<br/>                    result = self.cached_result[0]<br/>                    return result<br/>            # We have a previous but differently parametrized fixture instance<br/>            # so we need to tear it down before creating a new one.<br/>            self.finish(request)<br/>            assert self.cached_result is None<br/>    <br/>        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)<br/>&gt;       result = hook.pytest_fixture_setup(fixturedef=self, request=request)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1072: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_HookCaller &#x27;pytest_fixture_setup&#x27;&gt;<br/>kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;}<br/>firstresult = True<br/><br/>    def __call__(self, **kwargs: object) -&gt; Any:<br/>        assert (<br/>            not self.is_historic()<br/>        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;<br/>        self._verify_all_args_are_provided(kwargs)<br/>        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False<br/>&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_hooks.py:433: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_pytest.config.PytestPluginManager object at 0x0000015C7034A250&gt;, hook_name = &#x27;pytest_fixture_setup&#x27;<br/>methods = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _hookexec(<br/>        self,<br/>        hook_name: str,<br/>        methods: Sequence[HookImpl],<br/>        kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        # called from all hookcaller instances.<br/>        # enable_tracing will set its own wrapping function at self._inner_hookexec<br/>&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_manager.py:112: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_name = &#x27;pytest_fixture_setup&#x27;<br/>hook_impls = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>caller_kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _multicall(<br/>        hook_name: str,<br/>        hook_impls: Sequence[HookImpl],<br/>        caller_kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        results: list[object] = []<br/>        exception = None<br/>        only_new_style_wrappers = True<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns: list[Teardown] = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    f&quot;hook call must provide argument {argname!r}&quot;<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        only_new_style_wrappers = False<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            wrapper_gen = cast(Generator[None, _Result[object], None], res)<br/>                            next(wrapper_gen)  # first yield<br/>                            teardowns.append((wrapper_gen,))<br/>                        except StopIteration:<br/>                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)<br/>                    elif hook_impl.wrapper:<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            function_gen = cast(Generator[None, object, object], res)<br/>                            next(function_gen)  # first yield<br/>                            teardowns.append(function_gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)<br/>                    else:<br/>                        res = hook_impl.function(*args)<br/>                        if res is not None:<br/>                            results.append(res)<br/>                            if firstresult:  # halt further impl calls<br/>                                break<br/>            except BaseException as exc:<br/>                exception = exc<br/>        finally:<br/>            # Fast path - only new-style wrappers, no _Result.<br/>            if only_new_style_wrappers:<br/>                if firstresult:  # first result hooks return a single value<br/>                    result = results[0] if results else None<br/>                else:<br/>                    result = results<br/>    <br/>                # run all wrapper post-yield blocks<br/>                for teardown in reversed(teardowns):<br/>                    try:<br/>                        if exception is not None:<br/>                            teardown.throw(exception)  # type: ignore[union-attr]<br/>                        else:<br/>                            teardown.send(result)  # type: ignore[union-attr]<br/>                        # Following is unreachable for a well behaved hook wrapper.<br/>                        # Try to force finalizers otherwise postponed till GC action.<br/>                        # Note: close() may raise if generator handles GeneratorExit.<br/>                        teardown.close()  # type: ignore[union-attr]<br/>                    except StopIteration as si:<br/>                        result = si.value<br/>                        exception = None<br/>                        continue<br/>                    except BaseException as e:<br/>                        exception = e<br/>                        continue<br/>                    _raise_wrapfail(teardown, &quot;has second yield&quot;)  # type: ignore[arg-type]<br/>    <br/>                if exception is not None:<br/>                    raise exception.with_traceback(exception.__traceback__)<br/>                else:<br/>                    return result<br/>    <br/>            # Slow path - need to support old-style wrappers.<br/>            else:<br/>                if firstresult:  # first result hooks return a single value<br/>                    outcome: _Result[object | list[object]] = _Result(<br/>                        results[0] if results else None, exception<br/>                    )<br/>                else:<br/>                    outcome = _Result(results, exception)<br/>    <br/>                # run all wrapper post-yield blocks<br/>                for teardown in reversed(teardowns):<br/>                    if isinstance(teardown, tuple):<br/>                        try:<br/>                            teardown[0].send(outcome)<br/>                            _raise_wrapfail(teardown[0], &quot;has second yield&quot;)<br/>                        except StopIteration:<br/>                            pass<br/>                    else:<br/>                        try:<br/>                            if outcome._exception is not None:<br/>                                teardown.throw(outcome._exception)<br/>                            else:<br/>                                teardown.send(outcome._result)<br/>                            # Following is unreachable for a well behaved hook wrapper.<br/>                            # Try to force finalizers otherwise postponed till GC action.<br/>                            # Note: close() may raise if generator handles GeneratorExit.<br/>                            teardown.close()<br/>                        except StopIteration as si:<br/>                            outcome.force_result(si.value)<br/>                            continue<br/>                        except BaseException as e:<br/>                            outcome.force_exception(e)<br/>                            continue<br/>                        _raise_wrapfail(teardown, &quot;has second yield&quot;)<br/>    <br/>&gt;               return outcome.get_result()<br/><br/>venv\lib\site-packages\pluggy\_callers.py:155: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;pluggy._result._Result object at 0x0000015C7A62D040&gt;<br/><br/>    def get_result(self) -&gt; _T:<br/>        &quot;&quot;&quot;Get the result(s) for this hook call.<br/>    <br/>        If the hook was marked as a ``firstresult`` only a single value<br/>        will be returned, otherwise a list of results.<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        exc = self._exception<br/>        if exc is None:<br/>            return cast(_T, self._result)<br/>        else:<br/>&gt;           raise exc.with_traceback(exc.__traceback__)<br/><br/>venv\lib\site-packages\pluggy\_result.py:108: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_name = &#x27;pytest_fixture_setup&#x27;<br/>hook_impls = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>caller_kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _multicall(<br/>        hook_name: str,<br/>        hook_impls: Sequence[HookImpl],<br/>        caller_kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        results: list[object] = []<br/>        exception = None<br/>        only_new_style_wrappers = True<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns: list[Teardown] = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    f&quot;hook call must provide argument {argname!r}&quot;<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        only_new_style_wrappers = False<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            wrapper_gen = cast(Generator[None, _Result[object], None], res)<br/>                            next(wrapper_gen)  # first yield<br/>                            teardowns.append((wrapper_gen,))<br/>                        except StopIteration:<br/>                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)<br/>                    elif hook_impl.wrapper:<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            function_gen = cast(Generator[None, object, object], res)<br/>                            next(function_gen)  # first yield<br/>                            teardowns.append(function_gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)<br/>                    else:<br/>&gt;                       res = hook_impl.function(*args)<br/><br/>venv\lib\site-packages\pluggy\_callers.py:80: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fixturedef = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/><br/>    def pytest_fixture_setup(<br/>        fixturedef: FixtureDef[_FixtureValue], request: SubRequest<br/>    ) -&gt; _FixtureValue:<br/>        &quot;&quot;&quot;Execution of fixture setup.&quot;&quot;&quot;<br/>        kwargs = {}<br/>        for argname in fixturedef.argnames:<br/>            fixdef = request._get_active_fixturedef(argname)<br/>            assert fixdef.cached_result is not None<br/>            result, arg_cache_key, exc = fixdef.cached_result<br/>            request._check_scope(argname, request.scope, fixdef.scope)<br/>            kwargs[argname] = result<br/>    <br/>        fixturefunc = resolve_fixture_function(fixturedef, request)<br/>        my_cache_key = fixturedef.cache_key(request)<br/>        try:<br/>&gt;           result = call_fixture_func(fixturefunc, request, kwargs)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1126: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fixturefunc = &lt;function driver at 0x0000015C787C44C0&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>kwargs = {&#x27;driver_class&#x27;: &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;, &#x27;driver_kwargs&#x27;: {&#x27;desired_capabilities&#x27;: {&#x27;...on test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;}<br/><br/>    def call_fixture_func(<br/>        fixturefunc: &quot;_FixtureFunc[_FixtureValue]&quot;, request: FixtureRequest, kwargs<br/>    ) -&gt; _FixtureValue:<br/>        if is_generator(fixturefunc):<br/>            fixturefunc = cast(<br/>                Callable[..., Generator[_FixtureValue, None, None]], fixturefunc<br/>            )<br/>            generator = fixturefunc(**kwargs)<br/>            try:<br/>&gt;               fixture_result = next(generator)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:925: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>driver_class = &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;<br/>driver_kwargs = {&#x27;desired_capabilities&#x27;: {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}, &#x27;executable_path&#x27;: &#x27;....\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a1\\driver.log&#x27;}<br/><br/>    @pytest.fixture<br/>    def driver(request, driver_class, driver_kwargs):<br/>        &quot;&quot;&quot;Returns a WebDriver instance based on options and capabilities&quot;&quot;&quot;<br/>    <br/>        retries = int(request.config.getini(&quot;max_driver_init_attempts&quot;))<br/>&gt;       for retry in Retrying(<br/>            stop=stop_after_attempt(retries), wait=wait_exponential(), reraise=True<br/>        ):<br/><br/>venv\lib\site-packages\pytest_selenium\pytest_selenium.py:201: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Retrying object at 0x15c7a62da30 (stop=&lt;tenacity.stop.stop_after_attempt object at 0x0000015C7A62DA00&gt;, wait=&lt;tenacit...631370&gt;, before=&lt;function before_nothing at 0x0000015C7861BB80&gt;, after=&lt;function after_nothing at 0x0000015C7862F700&gt;)&gt;<br/><br/>    def __iter__(self):<br/>        self.begin(None)<br/>    <br/>        retry_state = RetryCallState(self, fn=None, args=(), kwargs={})<br/>        while True:<br/>&gt;           do = self.iter(retry_state=retry_state)<br/><br/>venv\lib\site-packages\tenacity\__init__.py:394: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Retrying object at 0x15c7a62da30 (stop=&lt;tenacity.stop.stop_after_attempt object at 0x0000015C7A62DA00&gt;, wait=&lt;tenacit...631370&gt;, before=&lt;function before_nothing at 0x0000015C7861BB80&gt;, after=&lt;function after_nothing at 0x0000015C7862F700&gt;)&gt;<br/>retry_state = &lt;tenacity.RetryCallState object at 0x0000015C7A62D6A0&gt;<br/><br/>    def iter(self, retry_state):  # noqa<br/>        fut = retry_state.outcome<br/>        if fut is None:<br/>            if self.before is not None:<br/>                self.before(retry_state)<br/>            return DoAttempt()<br/>    <br/>        is_explicit_retry = retry_state.outcome.failed \<br/>            and isinstance(retry_state.outcome.exception(), TryAgain)<br/>        if not (is_explicit_retry or self.retry(retry_state=retry_state)):<br/>            return fut.result()<br/>    <br/>        if self.after is not None:<br/>            self.after(retry_state=retry_state)<br/>    <br/>        self.statistics[&#x27;delay_since_first_attempt&#x27;] = \<br/>            retry_state.seconds_since_start<br/>        if self.stop(retry_state=retry_state):<br/>            if self.retry_error_callback:<br/>                return self.retry_error_callback(retry_state=retry_state)<br/>            retry_exc = self.retry_error_cls(fut)<br/>            if self.reraise:<br/>&gt;               raise retry_exc.reraise()<br/><br/>venv\lib\site-packages\tenacity\__init__.py:372: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = RetryError(&lt;Future at 0x15c7a665ee0 state=finished raised WebDriverException&gt;)<br/><br/>    def reraise(self):<br/>        if self.last_attempt.failed:<br/>&gt;           raise self.last_attempt.result()<br/><br/>venv\lib\site-packages\tenacity\__init__.py:189: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = None, timeout = None<br/><br/>    def result(self, timeout=None):<br/>        &quot;&quot;&quot;Return the result of the call that the future represents.<br/>    <br/>        Args:<br/>            timeout: The number of seconds to wait for the result if the future<br/>                isn&#x27;t done. If None, then there is no limit on the wait time.<br/>    <br/>        Returns:<br/>            The result of the call that the future represents.<br/>    <br/>        Raises:<br/>            CancelledError: If the future was cancelled.<br/>            TimeoutError: If the future didn&#x27;t finish executing before the given<br/>                timeout.<br/>            Exception: If the call raised then that exception will be raised.<br/>        &quot;&quot;&quot;<br/>        try:<br/>            with self._condition:<br/>                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:<br/>                    raise CancelledError()<br/>                elif self._state == FINISHED:<br/>&gt;                   return self.__get_result()<br/><br/>C:\Program Files\Python39\lib\concurrent\futures\_base.py:439: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = None<br/><br/>    def __get_result(self):<br/>        if self._exception:<br/>            try:<br/>&gt;               raise self._exception<br/><br/>C:\Program Files\Python39\lib\concurrent\futures\_base.py:391: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>driver_class = &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;<br/>driver_kwargs = {&#x27;desired_capabilities&#x27;: {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}, &#x27;executable_path&#x27;: &#x27;....\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a1\\driver.log&#x27;}<br/><br/>    @pytest.fixture<br/>    def driver(request, driver_class, driver_kwargs):<br/>        &quot;&quot;&quot;Returns a WebDriver instance based on options and capabilities&quot;&quot;&quot;<br/>    <br/>        retries = int(request.config.getini(&quot;max_driver_init_attempts&quot;))<br/>        for retry in Retrying(<br/>            stop=stop_after_attempt(retries), wait=wait_exponential(), reraise=True<br/>        ):<br/>            with retry:<br/>                LOGGER.info(<br/>                    f&quot;Driver init, attempt {retry.retry_state.attempt_number}/{retries}&quot;<br/>                )<br/>&gt;               driver = driver_class(**driver_kwargs)<br/><br/>venv\lib\site-packages\pytest_selenium\pytest_selenium.py:208: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[AttributeError(&quot;&#x27;WebDriver&#x27; object has no attribute &#x27;session_id&#x27;&quot;) raised in repr()] WebDriver object at 0x15c7a665d00&gt;<br/>executable_path = &#x27;./binaries/webdriver/chromedriver.exe&#x27;, port = 0, options = &lt;selenium.webdriver.chrome.options.Options object at 0x0000015C7A624CD0&gt;<br/>service_args = None, desired_capabilities = {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}<br/>service_log_path = &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a1\\driver.log&#x27;<br/>chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7A665BB0&gt;, keep_alive = True<br/><br/>    def __init__(self, executable_path=DEFAULT_EXECUTABLE_PATH, port=DEFAULT_PORT,<br/>                 options: Options = None, service_args=None,<br/>                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,<br/>                 chrome_options=None, service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):<br/>        &quot;&quot;&quot;<br/>        Creates a new instance of the chrome driver.<br/>        Starts the service and then creates new instance of chrome driver.<br/>    <br/>        :Args:<br/>         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH<br/>         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.<br/>         - options - this takes an instance of ChromeOptions<br/>         - service - Service object for handling the browser driver if you need to pass extra details<br/>         - service_args - Deprecated: List of args to pass to the driver service<br/>         - desired_capabilities - Deprecated: Dictionary object with non-browser specific<br/>           capabilities only, such as &quot;proxy&quot; or &quot;loggingPref&quot;.<br/>         - service_log_path - Deprecated: Where to log information from the driver.<br/>         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.<br/>        &quot;&quot;&quot;<br/>        if executable_path != &#x27;chromedriver&#x27;:<br/>            warnings.warn(&#x27;executable_path has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if chrome_options:<br/>            warnings.warn(&#x27;use options instead of chrome_options&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>            options = chrome_options<br/>        if keep_alive != DEFAULT_KEEP_ALIVE:<br/>            warnings.warn(&#x27;keep_alive has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        else:<br/>            keep_alive = True<br/>        if not service:<br/>            service = Service(executable_path, port, service_args, service_log_path)<br/>    <br/>&gt;       super(WebDriver, self).__init__(DesiredCapabilities.CHROME[&#x27;browserName&#x27;], &quot;goog&quot;,<br/>                                        port, options,<br/>                                        service_args, desired_capabilities,<br/>                                        service_log_path, service, keep_alive)<br/><br/>venv\lib\site-packages\selenium\webdriver\chrome\webdriver.py:70: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[AttributeError(&quot;&#x27;WebDriver&#x27; object has no attribute &#x27;session_id&#x27;&quot;) raised in repr()] WebDriver object at 0x15c7a665d00&gt;, browser_name = &#x27;chrome&#x27;<br/>vendor_prefix = &#x27;goog&#x27;, port = 0, options = &lt;selenium.webdriver.chrome.options.Options object at 0x0000015C7A624CD0&gt;, service_args = None<br/>desired_capabilities = {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}<br/>service_log_path = &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a1\\driver.log&#x27;<br/>service = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7A665BB0&gt;, keep_alive = True<br/><br/>    def __init__(self, browser_name, vendor_prefix,<br/>                 port=DEFAULT_PORT, options: BaseOptions = None, service_args=None,<br/>                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,<br/>                 service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):<br/>        &quot;&quot;&quot;<br/>        Creates a new WebDriver instance of the ChromiumDriver.<br/>        Starts the service and then creates new WebDriver instance of ChromiumDriver.<br/>    <br/>        :Args:<br/>         - browser_name - Browser name used when matching capabilities.<br/>         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.<br/>         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.<br/>         - options - this takes an instance of ChromiumOptions<br/>         - service_args - Deprecated: List of args to pass to the driver service<br/>         - desired_capabilities - Deprecated: Dictionary object with non-browser specific<br/>           capabilities only, such as &quot;proxy&quot; or &quot;loggingPref&quot;.<br/>         - service_log_path - Deprecated: Where to log information from the driver.<br/>         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.<br/>        &quot;&quot;&quot;<br/>        if desired_capabilities:<br/>            warnings.warn(&#x27;desired_capabilities has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if port != DEFAULT_PORT:<br/>            warnings.warn(&#x27;port has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        self.port = port<br/>        if service_log_path != DEFAULT_SERVICE_LOG_PATH:<br/>            warnings.warn(&#x27;service_log_path has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:<br/>            warnings.warn(&#x27;keep_alive has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        else:<br/>            keep_alive = True<br/>    <br/>        self.vendor_prefix = vendor_prefix<br/>    <br/>        _ignore_proxy = None<br/>        if not options:<br/>            options = self.create_options()<br/>    <br/>        if desired_capabilities:<br/>            for key, value in desired_capabilities.items():<br/>                options.set_capability(key, value)<br/>    <br/>        if options._ignore_local_proxy:<br/>            _ignore_proxy = options._ignore_local_proxy<br/>    <br/>        if not service:<br/>            raise AttributeError(&#x27;service cannot be None&#x27;)<br/>    <br/>        self.service = service<br/>&gt;       self.service.start()<br/><br/>venv\lib\site-packages\selenium\webdriver\chromium\webdriver.py:90: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7A665BB0&gt;<br/><br/>    def start(self):<br/>        &quot;&quot;&quot;<br/>        Starts the Service.<br/>    <br/>        :Exceptions:<br/>         - WebDriverException : Raised either when it can&#x27;t start the service<br/>           or when it can&#x27;t connect to the service<br/>        &quot;&quot;&quot;<br/>        try:<br/>            cmd = [self.path]<br/>            cmd.extend(self.command_line_args())<br/>            self.process = subprocess.Popen(cmd, env=self.env,<br/>                                            close_fds=system() != &#x27;Windows&#x27;,<br/>                                            stdout=self.log_file,<br/>                                            stderr=self.log_file,<br/>                                            stdin=PIPE,<br/>                                            creationflags=self.creationflags)<br/>        except TypeError:<br/>            raise<br/>        except OSError as err:<br/>            if err.errno == errno.ENOENT:<br/>&gt;               raise WebDriverException(<br/>                    &quot;&#x27;%s&#x27; executable needs to be in PATH. %s&quot; % (<br/>                        os.path.basename(self.path), self.start_error_message)<br/><span class="error">E                       selenium.common.exceptions.WebDriverException: Message: &#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.chromium.org/home</span><br/><br/>venv\lib\site-packages\selenium\webdriver\common\service.py:81: WebDriverException<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;_HookCaller &#x27;pytest_bdd_step_error&#x27;&gt;<br/>kwargs = {&#x27;exception&#x27;: WebDriverException(&quot;&#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.c...=&#x27;Then&#x27;, failed=None, scenario=None, background=None, lines=[])], tags={&#x27;TR-C393228&#x27;, &#x27;automated&#x27;, &#x27;regression&#x27;}), ...}<br/>firstresult = False<br/><br/>    def __call__(self, **kwargs: object) -&gt; Any:<br/>        assert (<br/>            not self.is_historic()<br/>        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;<br/>        self._verify_all_args_are_provided(kwargs)<br/>        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False<br/>&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_hooks.py:433: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv\lib\site-packages\pluggy\_manager.py:112: in _hookexec<br/>    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)<br/>venv\lib\site-packages\enhanced_reports\core.py:493: in pytest_bdd_step_error<br/>    __capture_js_logs(current_state, driver, op_name)<br/>venv\lib\site-packages\enhanced_reports\core.py:234: in __capture_js_logs<br/>    logs = browser_console_manager.get_js_logs(driver)<br/>venv\lib\site-packages\enhanced_reports\browser_console_manager.py:13: in get_js_logs<br/>    logs = _capture_output(driver)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>driver = None<br/><br/>    def _capture_output(driver: WebDriver):<br/>&gt;       return driver.get_log(&quot;browser&quot;)<br/><span class="error">E       AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;get_log&#x27;</span><br/><br/>venv\lib\site-packages\enhanced_reports\browser_console_manager.py:18: AttributeError<br/> -----------------------------Captured stderr setup------------------------------ <br/>2023-06-22 05:35:23 [info     ] current param_value False
<br/> -------------------------------Captured log setup------------------------------- <br/>2023-06-22 11:05:23 INFO current param_value False<br/> ------------------------------Captured stderr call------------------------------ <br/>

2023-06-22 05:35:23 [info     ] Scenario Execution Started.    feature=Galaxy automated regression - button and anchor components scenario_name=Verify PPC - Buttons and Anchor - Loading Button
2023-06-22 05:35:23 [info     ] Capabilities from markers: {}
2023-06-22 05:35:23 [info     ] Driver init, attempt 1/3
2023-06-22 05:35:24 [info     ] Driver init, attempt 2/3
2023-06-22 05:35:26 [info     ] Driver init, attempt 3/3
2023-06-22 05:35:26 [error    ] Step FAILED.                   step=I am on the page &#x27;/&#x27;
Traceback (most recent call last):
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\common\service.py&quot;, line 71, in start
    self.process = subprocess.Popen(cmd, env=self.env,
  File &quot;C:\Program Files\Python39\lib\subprocess.py&quot;, line 951, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File &quot;C:\Program Files\Python39\lib\subprocess.py&quot;, line 1420, in _execute_child
    hp, ht, pid, tid = _winapi.CreateProcess(executable, args,
FileNotFoundError: [WinError 2] The system cannot find the file specified

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_bdd\scenario.py&quot;, line 154, in _execute_step_function
    kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_bdd\scenario.py&quot;, line 154, in &lt;dictcomp&gt;
    kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 581, in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1072, in execute
    result = hook.pytest_fixture_setup(fixturedef=self, request=request)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_hooks.py&quot;, line 433, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_manager.py&quot;, line 112, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_callers.py&quot;, line 155, in _multicall
    return outcome.get_result()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_result.py&quot;, line 108, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_callers.py&quot;, line 80, in _multicall
    res = hook_impl.function(*args)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1126, in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 925, in call_fixture_func
    fixture_result = next(generator)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_selenium\pytest_selenium.py&quot;, line 201, in driver
    for retry in Retrying(
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 394, in __iter__
    do = self.iter(retry_state=retry_state)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 372, in iter
    raise retry_exc.reraise()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 189, in reraise
    raise self.last_attempt.result()
  File &quot;C:\Program Files\Python39\lib\concurrent\futures\_base.py&quot;, line 439, in result
    return self.__get_result()
  File &quot;C:\Program Files\Python39\lib\concurrent\futures\_base.py&quot;, line 391, in __get_result
    raise self._exception
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_selenium\pytest_selenium.py&quot;, line 208, in driver
    driver = driver_class(**driver_kwargs)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\chrome\webdriver.py&quot;, line 70, in __init__
    super(WebDriver, self).__init__(DesiredCapabilities.CHROME[&#x27;browserName&#x27;], &quot;goog&quot;,
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\chromium\webdriver.py&quot;, line 90, in __init__
    self.service.start()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\common\service.py&quot;, line 81, in start
    raise WebDriverException(
selenium.common.exceptions.WebDriverException: Message: &#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.chromium.org/home

2023-06-22 05:35:26 [info     ] current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 05:35:26 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
2023-06-22 05:35:26 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
2023-06-22 05:35:26 [info     ] Scenario Execution Completed.  feature=Galaxy automated regression - button and anchor components scenario_name=Verify PPC - Buttons and Anchor - Loading Button
2023-06-22 05:35:26 [info     ] current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 05:35:26 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-section">Galaxy automated regression -&gt; button and anchor components</td>
          <td class="col-tags">TR-C393228</td>
          <td class="col-name">Verify PPC - Buttons and Anchor - Loading Button  locator: helixComponent &gt; loading_button, attribute: padding-left, value: 40px</td>
          <td class="col-result">Failed</td>
          <td class="col-duration">00:03.04</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="6">
            <div class="log">self = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BAAB610&gt;<br/><br/>    def start(self):<br/>        &quot;&quot;&quot;<br/>        Starts the Service.<br/>    <br/>        :Exceptions:<br/>         - WebDriverException : Raised either when it can&#x27;t start the service<br/>           or when it can&#x27;t connect to the service<br/>        &quot;&quot;&quot;<br/>        try:<br/>            cmd = [self.path]<br/>            cmd.extend(self.command_line_args())<br/>&gt;           self.process = subprocess.Popen(cmd, env=self.env,<br/>                                            close_fds=system() != &#x27;Windows&#x27;,<br/>                                            stdout=self.log_file,<br/>                                            stderr=self.log_file,<br/>                                            stdin=PIPE,<br/>                                            creationflags=self.creationflags)<br/><br/>venv\lib\site-packages\selenium\webdriver\common\service.py:71: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Popen: returncode: None args: [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--...&gt;<br/>args = [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--port=52302&#x27;, &#x27;--log-path=C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a2\\driver.log&#x27;]<br/>bufsize = -1, executable = None, stdin = -1, stdout = -3, stderr = -3, preexec_fn = None, close_fds = False, shell = False, cwd = None<br/>env = environ({&#x27;__INTELLIJ_COMMAND_HISTFILE__&#x27;: &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\terminal\\...ps.py::test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px] (call)&#x27;})<br/>universal_newlines = None, startupinfo = None, creationflags = 0, restore_signals = True, start_new_session = False, pass_fds = ()<br/><br/>    def __init__(self, args, bufsize=-1, executable=None,<br/>                 stdin=None, stdout=None, stderr=None,<br/>                 preexec_fn=None, close_fds=True,<br/>                 shell=False, cwd=None, env=None, universal_newlines=None,<br/>                 startupinfo=None, creationflags=0,<br/>                 restore_signals=True, start_new_session=False,<br/>                 pass_fds=(), *, user=None, group=None, extra_groups=None,<br/>                 encoding=None, errors=None, text=None, umask=-1):<br/>        &quot;&quot;&quot;Create new Popen instance.&quot;&quot;&quot;<br/>        _cleanup()<br/>        # Held while anything is calling waitpid before returncode has been<br/>        # updated to prevent clobbering returncode if wait() or poll() are<br/>        # called from multiple threads at once.  After acquiring the lock,<br/>        # code must re-check self.returncode to see if another thread just<br/>        # finished a waitpid() call.<br/>        self._waitpid_lock = threading.Lock()<br/>    <br/>        self._input = None<br/>        self._communication_started = False<br/>        if bufsize is None:<br/>            bufsize = -1  # Restore default<br/>        if not isinstance(bufsize, int):<br/>            raise TypeError(&quot;bufsize must be an integer&quot;)<br/>    <br/>        if _mswindows:<br/>            if preexec_fn is not None:<br/>                raise ValueError(&quot;preexec_fn is not supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>        else:<br/>            # POSIX<br/>            if pass_fds and not close_fds:<br/>                warnings.warn(&quot;pass_fds overriding close_fds.&quot;, RuntimeWarning)<br/>                close_fds = True<br/>            if startupinfo is not None:<br/>                raise ValueError(&quot;startupinfo is only supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>            if creationflags != 0:<br/>                raise ValueError(&quot;creationflags is only supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>    <br/>        self.args = args<br/>        self.stdin = None<br/>        self.stdout = None<br/>        self.stderr = None<br/>        self.pid = None<br/>        self.returncode = None<br/>        self.encoding = encoding<br/>        self.errors = errors<br/>    <br/>        # Validate the combinations of text and universal_newlines<br/>        if (text is not None and universal_newlines is not None<br/>            and bool(universal_newlines) != bool(text)):<br/>            raise SubprocessError(&#x27;Cannot disambiguate when both text &#x27;<br/>                                  &#x27;and universal_newlines are supplied but &#x27;<br/>                                  &#x27;different. Pass one or the other.&#x27;)<br/>    <br/>        # Input and output objects. The general principle is like<br/>        # this:<br/>        #<br/>        # Parent                   Child<br/>        # ------                   -----<br/>        # p2cwrite   ---stdin---&gt;  p2cread<br/>        # c2pread    &lt;--stdout---  c2pwrite<br/>        # errread    &lt;--stderr---  errwrite<br/>        #<br/>        # On POSIX, the child objects are file descriptors.  On<br/>        # Windows, these are Windows file handles.  The parent objects<br/>        # are file descriptors on both platforms.  The parent objects<br/>        # are -1 when not using PIPEs. The child objects are -1<br/>        # when not redirecting.<br/>    <br/>        (p2cread, p2cwrite,<br/>         c2pread, c2pwrite,<br/>         errread, errwrite) = self._get_handles(stdin, stdout, stderr)<br/>    <br/>        # We wrap OS handles *before* launching the child, otherwise a<br/>        # quickly terminating child could make our fds unwrappable<br/>        # (see #8458).<br/>    <br/>        if _mswindows:<br/>            if p2cwrite != -1:<br/>                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)<br/>            if c2pread != -1:<br/>                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)<br/>            if errread != -1:<br/>                errread = msvcrt.open_osfhandle(errread.Detach(), 0)<br/>    <br/>        self.text_mode = encoding or errors or text or universal_newlines<br/>    <br/>        # How long to resume waiting on a child after the first ^C.<br/>        # There is no right value for this.  The purpose is to be polite<br/>        # yet remain good for interactive users trying to exit a tool.<br/>        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()<br/>    <br/>        self._closed_child_pipe_fds = False<br/>    <br/>        if self.text_mode:<br/>            if bufsize == 1:<br/>                line_buffering = True<br/>                # Use the default buffer size for the underlying binary streams<br/>                # since they don&#x27;t support line buffering.<br/>                bufsize = -1<br/>            else:<br/>                line_buffering = False<br/>    <br/>        gid = None<br/>        if group is not None:<br/>            if not hasattr(os, &#x27;setregid&#x27;):<br/>                raise ValueError(&quot;The &#x27;group&#x27; parameter is not supported on the &quot;<br/>                                 &quot;current platform&quot;)<br/>    <br/>            elif isinstance(group, str):<br/>                if grp is None:<br/>                    raise ValueError(&quot;The group parameter cannot be a string &quot;<br/>                                     &quot;on systems without the grp module&quot;)<br/>    <br/>                gid = grp.getgrnam(group).gr_gid<br/>            elif isinstance(group, int):<br/>                gid = group<br/>            else:<br/>                raise TypeError(&quot;Group must be a string or an integer, not {}&quot;<br/>                                .format(type(group)))<br/>    <br/>            if gid &lt; 0:<br/>                raise ValueError(f&quot;Group ID cannot be negative, got {gid}&quot;)<br/>    <br/>        gids = None<br/>        if extra_groups is not None:<br/>            if not hasattr(os, &#x27;setgroups&#x27;):<br/>                raise ValueError(&quot;The &#x27;extra_groups&#x27; parameter is not &quot;<br/>                                 &quot;supported on the current platform&quot;)<br/>    <br/>            elif isinstance(extra_groups, str):<br/>                raise ValueError(&quot;Groups must be a list, not a string&quot;)<br/>    <br/>            gids = []<br/>            for extra_group in extra_groups:<br/>                if isinstance(extra_group, str):<br/>                    if grp is None:<br/>                        raise ValueError(&quot;Items in extra_groups cannot be &quot;<br/>                                         &quot;strings on systems without the &quot;<br/>                                         &quot;grp module&quot;)<br/>    <br/>                    gids.append(grp.getgrnam(extra_group).gr_gid)<br/>                elif isinstance(extra_group, int):<br/>                    gids.append(extra_group)<br/>                else:<br/>                    raise TypeError(&quot;Items in extra_groups must be a string &quot;<br/>                                    &quot;or integer, not {}&quot;<br/>                                    .format(type(extra_group)))<br/>    <br/>            # make sure that the gids are all positive here so we can do less<br/>            # checking in the C code<br/>            for gid_check in gids:<br/>                if gid_check &lt; 0:<br/>                    raise ValueError(f&quot;Group ID cannot be negative, got {gid_check}&quot;)<br/>    <br/>        uid = None<br/>        if user is not None:<br/>            if not hasattr(os, &#x27;setreuid&#x27;):<br/>                raise ValueError(&quot;The &#x27;user&#x27; parameter is not supported on &quot;<br/>                                 &quot;the current platform&quot;)<br/>    <br/>            elif isinstance(user, str):<br/>                if pwd is None:<br/>                    raise ValueError(&quot;The user parameter cannot be a string &quot;<br/>                                     &quot;on systems without the pwd module&quot;)<br/>    <br/>                uid = pwd.getpwnam(user).pw_uid<br/>            elif isinstance(user, int):<br/>                uid = user<br/>            else:<br/>                raise TypeError(&quot;User must be a string or an integer&quot;)<br/>    <br/>            if uid &lt; 0:<br/>                raise ValueError(f&quot;User ID cannot be negative, got {uid}&quot;)<br/>    <br/>        try:<br/>            if p2cwrite != -1:<br/>                self.stdin = io.open(p2cwrite, &#x27;wb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,<br/>                            line_buffering=line_buffering,<br/>                            encoding=encoding, errors=errors)<br/>            if c2pread != -1:<br/>                self.stdout = io.open(c2pread, &#x27;rb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stdout = io.TextIOWrapper(self.stdout,<br/>                            encoding=encoding, errors=errors)<br/>            if errread != -1:<br/>                self.stderr = io.open(errread, &#x27;rb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stderr = io.TextIOWrapper(self.stderr,<br/>                            encoding=encoding, errors=errors)<br/>    <br/>&gt;           self._execute_child(args, executable, preexec_fn, close_fds,<br/>                                pass_fds, cwd, env,<br/>                                startupinfo, creationflags, shell,<br/>                                p2cread, p2cwrite,<br/>                                c2pread, c2pwrite,<br/>                                errread, errwrite,<br/>                                restore_signals,<br/>                                gid, gids, uid, umask,<br/>                                start_new_session)<br/><br/>C:\Program Files\Python39\lib\subprocess.py:951: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Popen: returncode: None args: [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--...&gt;<br/>args = &#x27;./binaries/webdriver/chromedriver.exe --port=52302 --log-path=C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a2\\driver.log&#x27;<br/>executable = None, preexec_fn = None, close_fds = False, pass_fds = (), cwd = None<br/>env = environ({&#x27;__INTELLIJ_COMMAND_HISTFILE__&#x27;: &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\terminal\\...ps.py::test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px] (call)&#x27;})<br/>startupinfo = &lt;subprocess.STARTUPINFO object at 0x0000015C7BAABA60&gt;, creationflags = 0, shell = False, p2cread = Handle(1552), p2cwrite = 16, c2pread = -1<br/>c2pwrite = Handle(1524), errread = -1, errwrite = Handle(1620), unused_restore_signals = True, unused_gid = None, unused_gids = None, unused_uid = None<br/>unused_umask = -1, unused_start_new_session = False<br/><br/>    def _execute_child(self, args, executable, preexec_fn, close_fds,<br/>                       pass_fds, cwd, env,<br/>                       startupinfo, creationflags, shell,<br/>                       p2cread, p2cwrite,<br/>                       c2pread, c2pwrite,<br/>                       errread, errwrite,<br/>                       unused_restore_signals,<br/>                       unused_gid, unused_gids, unused_uid,<br/>                       unused_umask,<br/>                       unused_start_new_session):<br/>        &quot;&quot;&quot;Execute program (MS Windows version)&quot;&quot;&quot;<br/>    <br/>        assert not pass_fds, &quot;pass_fds not supported on Windows.&quot;<br/>    <br/>        if isinstance(args, str):<br/>            pass<br/>        elif isinstance(args, bytes):<br/>            if shell:<br/>                raise TypeError(&#x27;bytes args is not allowed on Windows&#x27;)<br/>            args = list2cmdline([args])<br/>        elif isinstance(args, os.PathLike):<br/>            if shell:<br/>                raise TypeError(&#x27;path-like args is not allowed when &#x27;<br/>                                &#x27;shell is true&#x27;)<br/>            args = list2cmdline([args])<br/>        else:<br/>            args = list2cmdline(args)<br/>    <br/>        if executable is not None:<br/>            executable = os.fsdecode(executable)<br/>    <br/>        # Process startup details<br/>        if startupinfo is None:<br/>            startupinfo = STARTUPINFO()<br/>        else:<br/>            # bpo-34044: Copy STARTUPINFO since it is modified above,<br/>            # so the caller can reuse it multiple times.<br/>            startupinfo = startupinfo.copy()<br/>    <br/>        use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)<br/>        if use_std_handles:<br/>            startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES<br/>            startupinfo.hStdInput = p2cread<br/>            startupinfo.hStdOutput = c2pwrite<br/>            startupinfo.hStdError = errwrite<br/>    <br/>        attribute_list = startupinfo.lpAttributeList<br/>        have_handle_list = bool(attribute_list and<br/>                                &quot;handle_list&quot; in attribute_list and<br/>                                attribute_list[&quot;handle_list&quot;])<br/>    <br/>        # If we were given an handle_list or need to create one<br/>        if have_handle_list or (use_std_handles and close_fds):<br/>            if attribute_list is None:<br/>                attribute_list = startupinfo.lpAttributeList = {}<br/>            handle_list = attribute_list[&quot;handle_list&quot;] = \<br/>                list(attribute_list.get(&quot;handle_list&quot;, []))<br/>    <br/>            if use_std_handles:<br/>                handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]<br/>    <br/>            handle_list[:] = self._filter_handle_list(handle_list)<br/>    <br/>            if handle_list:<br/>                if not close_fds:<br/>                    warnings.warn(&quot;startupinfo.lpAttributeList[&#x27;handle_list&#x27;] &quot;<br/>                                  &quot;overriding close_fds&quot;, RuntimeWarning)<br/>    <br/>                # When using the handle_list we always request to inherit<br/>                # handles but the only handles that will be inherited are<br/>                # the ones in the handle_list<br/>                close_fds = False<br/>    <br/>        if shell:<br/>            startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW<br/>            startupinfo.wShowWindow = _winapi.SW_HIDE<br/>            comspec = os.environ.get(&quot;COMSPEC&quot;, &quot;cmd.exe&quot;)<br/>            args = &#x27;{} /c &quot;{}&quot;&#x27;.format (comspec, args)<br/>    <br/>        if cwd is not None:<br/>            cwd = os.fsdecode(cwd)<br/>    <br/>        sys.audit(&quot;subprocess.Popen&quot;, executable, args, cwd, env)<br/>    <br/>        # Start the process<br/>        try:<br/>&gt;           hp, ht, pid, tid = _winapi.CreateProcess(executable, args,<br/>                                     # no special security<br/>                                     None, None,<br/>                                     int(not close_fds),<br/>                                     creationflags,<br/>                                     env,<br/>                                     cwd,<br/>                                     startupinfo)<br/><span class="error">E                                    FileNotFoundError: [WinError 2] The system cannot find the file specified</span><br/><br/>C:\Program Files\Python39\lib\subprocess.py:1420: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>request = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/>scenario = Scenario(feature=Feature(scenarios=OrderedDict([(&#x27;Verify PPC - Buttons and Anchor - Loading Button&#x27;, ScenarioTemplate(...eyword=&#x27;Then&#x27;, failed=None, scenario=None, background=None, lines=[])], tags={&#x27;TR-C393228&#x27;, &#x27;automated&#x27;, &#x27;regression&#x27;})<br/>step = Step(type=&#x27;given&#x27;, _name=&quot;I am on the page &#x27;/&#x27;&quot;, line_number=5, indent=8, keyword=&#x27;Given&#x27;, failed=True, scenario=None,...closeIcon&#x27;&quot;, line_number=8, indent=8, keyword=&#x27;And&#x27;, failed=None, scenario=None, background=..., lines=[])]), lines=[])<br/>context = StepFunctionContext(type=&#x27;given&#x27;, step_func=&lt;function open_webpage at 0x0000015C7A412820&gt;, parser=&lt;pytest_bdd.parsers....t at 0x0000015C7A40F7C0&gt;, converters={&#x27;page_url&#x27;: &lt;function env_formatted at 0x0000015C78B20700&gt;}, target_fixture=None)<br/><br/>    def _execute_step_function(<br/>        request: FixtureRequest, scenario: Scenario, step: Step, context: StepFunctionContext<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;Execute step function.&quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        kw = {<br/>            &quot;request&quot;: request,<br/>            &quot;feature&quot;: scenario.feature,<br/>            &quot;scenario&quot;: scenario,<br/>            &quot;step&quot;: step,<br/>            &quot;step_func&quot;: context.step_func,<br/>            &quot;step_func_args&quot;: {},<br/>        }<br/>    <br/>        request.config.hook.pytest_bdd_before_step(**kw)<br/>    <br/>        # Get the step argument values.<br/>        converters = context.converters<br/>        kwargs = {}<br/>        args = get_args(context.step_func)<br/>    <br/>        try:<br/>            parsed_args = context.parser.parse_arguments(step.name)<br/>            assert parsed_args is not None, (<br/>                f&quot;Unexpected `NoneType` returned from &quot; f&quot;parse_arguments(...) in parser: {context.parser!r}&quot;<br/>            )<br/>            for arg, value in parsed_args.items():<br/>                if arg in converters:<br/>                    value = converters[arg](value)<br/>                kwargs[arg] = value<br/>    <br/>&gt;           kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}<br/><br/>venv\lib\site-packages\pytest_bdd\scenario.py:154: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>.0 = &lt;list_iterator object at 0x0000015C7BCC76A0&gt;<br/><br/>&gt;   kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}<br/><br/>venv\lib\site-packages\pytest_bdd\scenario.py:154: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/>argname = &#x27;selenium_generics&#x27;<br/><br/>    def getfixturevalue(self, argname: str) -&gt; Any:<br/>        &quot;&quot;&quot;Dynamically run a named fixture function.<br/>    <br/>        Declaring fixtures via function argument is recommended where possible.<br/>        But if you can only decide whether to use another fixture at test<br/>        setup time, you may use this function to retrieve it inside a fixture<br/>        or test function body.<br/>    <br/>        :raises pytest.FixtureLookupError:<br/>            If the given fixture could not be found.<br/>        &quot;&quot;&quot;<br/>&gt;       fixturedef = self._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:581: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/>argname = &#x27;selenium_generics&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium_generics&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium_generics&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/>argname = &#x27;selenium&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/>argname = &#x27;selenium&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/>argname = &#x27;driver&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>            fixturedef = request._get_active_fixturedef(argname)<br/>            if argname != &quot;request&quot;:<br/>                # PseudoFixtureDef is only for &quot;request&quot;.<br/>                assert isinstance(fixturedef, FixtureDef)<br/>                fixturedef.addfinalizer(functools.partial(self.finish, request=request))<br/>    <br/>        my_cache_key = self.cache_key(request)<br/>        if self.cached_result is not None:<br/>            # note: comparison with `==` can fail (or be expensive) for e.g.<br/>            # numpy arrays (#6497).<br/>            cache_key = self.cached_result[1]<br/>            if my_cache_key is cache_key:<br/>                if self.cached_result[2] is not None:<br/>                    _, val, tb = self.cached_result[2]<br/>                    raise val.with_traceback(tb)<br/>                else:<br/>                    result = self.cached_result[0]<br/>                    return result<br/>            # We have a previous but differently parametrized fixture instance<br/>            # so we need to tear it down before creating a new one.<br/>            self.finish(request)<br/>            assert self.cached_result is None<br/>    <br/>        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)<br/>&gt;       result = hook.pytest_fixture_setup(fixturedef=self, request=request)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1072: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_HookCaller &#x27;pytest_fixture_setup&#x27;&gt;<br/>kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def __call__(self, **kwargs: object) -&gt; Any:<br/>        assert (<br/>            not self.is_historic()<br/>        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;<br/>        self._verify_all_args_are_provided(kwargs)<br/>        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False<br/>&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_hooks.py:433: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_pytest.config.PytestPluginManager object at 0x0000015C7034A250&gt;, hook_name = &#x27;pytest_fixture_setup&#x27;<br/>methods = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _hookexec(<br/>        self,<br/>        hook_name: str,<br/>        methods: Sequence[HookImpl],<br/>        kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        # called from all hookcaller instances.<br/>        # enable_tracing will set its own wrapping function at self._inner_hookexec<br/>&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_manager.py:112: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_name = &#x27;pytest_fixture_setup&#x27;<br/>hook_impls = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>caller_kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _multicall(<br/>        hook_name: str,<br/>        hook_impls: Sequence[HookImpl],<br/>        caller_kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        results: list[object] = []<br/>        exception = None<br/>        only_new_style_wrappers = True<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns: list[Teardown] = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    f&quot;hook call must provide argument {argname!r}&quot;<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        only_new_style_wrappers = False<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            wrapper_gen = cast(Generator[None, _Result[object], None], res)<br/>                            next(wrapper_gen)  # first yield<br/>                            teardowns.append((wrapper_gen,))<br/>                        except StopIteration:<br/>                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)<br/>                    elif hook_impl.wrapper:<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            function_gen = cast(Generator[None, object, object], res)<br/>                            next(function_gen)  # first yield<br/>                            teardowns.append(function_gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)<br/>                    else:<br/>                        res = hook_impl.function(*args)<br/>                        if res is not None:<br/>                            results.append(res)<br/>                            if firstresult:  # halt further impl calls<br/>                                break<br/>            except BaseException as exc:<br/>                exception = exc<br/>        finally:<br/>            # Fast path - only new-style wrappers, no _Result.<br/>            if only_new_style_wrappers:<br/>                if firstresult:  # first result hooks return a single value<br/>                    result = results[0] if results else None<br/>                else:<br/>                    result = results<br/>    <br/>                # run all wrapper post-yield blocks<br/>                for teardown in reversed(teardowns):<br/>                    try:<br/>                        if exception is not None:<br/>                            teardown.throw(exception)  # type: ignore[union-attr]<br/>                        else:<br/>                            teardown.send(result)  # type: ignore[union-attr]<br/>                        # Following is unreachable for a well behaved hook wrapper.<br/>                        # Try to force finalizers otherwise postponed till GC action.<br/>                        # Note: close() may raise if generator handles GeneratorExit.<br/>                        teardown.close()  # type: ignore[union-attr]<br/>                    except StopIteration as si:<br/>                        result = si.value<br/>                        exception = None<br/>                        continue<br/>                    except BaseException as e:<br/>                        exception = e<br/>                        continue<br/>                    _raise_wrapfail(teardown, &quot;has second yield&quot;)  # type: ignore[arg-type]<br/>    <br/>                if exception is not None:<br/>                    raise exception.with_traceback(exception.__traceback__)<br/>                else:<br/>                    return result<br/>    <br/>            # Slow path - need to support old-style wrappers.<br/>            else:<br/>                if firstresult:  # first result hooks return a single value<br/>                    outcome: _Result[object | list[object]] = _Result(<br/>                        results[0] if results else None, exception<br/>                    )<br/>                else:<br/>                    outcome = _Result(results, exception)<br/>    <br/>                # run all wrapper post-yield blocks<br/>                for teardown in reversed(teardowns):<br/>                    if isinstance(teardown, tuple):<br/>                        try:<br/>                            teardown[0].send(outcome)<br/>                            _raise_wrapfail(teardown[0], &quot;has second yield&quot;)<br/>                        except StopIteration:<br/>                            pass<br/>                    else:<br/>                        try:<br/>                            if outcome._exception is not None:<br/>                                teardown.throw(outcome._exception)<br/>                            else:<br/>                                teardown.send(outcome._result)<br/>                            # Following is unreachable for a well behaved hook wrapper.<br/>                            # Try to force finalizers otherwise postponed till GC action.<br/>                            # Note: close() may raise if generator handles GeneratorExit.<br/>                            teardown.close()<br/>                        except StopIteration as si:<br/>                            outcome.force_result(si.value)<br/>                            continue<br/>                        except BaseException as e:<br/>                            outcome.force_exception(e)<br/>                            continue<br/>                        _raise_wrapfail(teardown, &quot;has second yield&quot;)<br/>    <br/>&gt;               return outcome.get_result()<br/><br/>venv\lib\site-packages\pluggy\_callers.py:155: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;pluggy._result._Result object at 0x0000015C7BAAB280&gt;<br/><br/>    def get_result(self) -&gt; _T:<br/>        &quot;&quot;&quot;Get the result(s) for this hook call.<br/>    <br/>        If the hook was marked as a ``firstresult`` only a single value<br/>        will be returned, otherwise a list of results.<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        exc = self._exception<br/>        if exc is None:<br/>            return cast(_T, self._result)<br/>        else:<br/>&gt;           raise exc.with_traceback(exc.__traceback__)<br/><br/>venv\lib\site-packages\pluggy\_result.py:108: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_name = &#x27;pytest_fixture_setup&#x27;<br/>hook_impls = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>caller_kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _multicall(<br/>        hook_name: str,<br/>        hook_impls: Sequence[HookImpl],<br/>        caller_kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        results: list[object] = []<br/>        exception = None<br/>        only_new_style_wrappers = True<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns: list[Teardown] = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    f&quot;hook call must provide argument {argname!r}&quot;<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        only_new_style_wrappers = False<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            wrapper_gen = cast(Generator[None, _Result[object], None], res)<br/>                            next(wrapper_gen)  # first yield<br/>                            teardowns.append((wrapper_gen,))<br/>                        except StopIteration:<br/>                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)<br/>                    elif hook_impl.wrapper:<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            function_gen = cast(Generator[None, object, object], res)<br/>                            next(function_gen)  # first yield<br/>                            teardowns.append(function_gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)<br/>                    else:<br/>&gt;                       res = hook_impl.function(*args)<br/><br/>venv\lib\site-packages\pluggy\_callers.py:80: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fixturedef = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/><br/>    def pytest_fixture_setup(<br/>        fixturedef: FixtureDef[_FixtureValue], request: SubRequest<br/>    ) -&gt; _FixtureValue:<br/>        &quot;&quot;&quot;Execution of fixture setup.&quot;&quot;&quot;<br/>        kwargs = {}<br/>        for argname in fixturedef.argnames:<br/>            fixdef = request._get_active_fixturedef(argname)<br/>            assert fixdef.cached_result is not None<br/>            result, arg_cache_key, exc = fixdef.cached_result<br/>            request._check_scope(argname, request.scope, fixdef.scope)<br/>            kwargs[argname] = result<br/>    <br/>        fixturefunc = resolve_fixture_function(fixturedef, request)<br/>        my_cache_key = fixturedef.cache_key(request)<br/>        try:<br/>&gt;           result = call_fixture_func(fixturefunc, request, kwargs)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1126: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fixturefunc = &lt;function driver at 0x0000015C787C44C0&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/>kwargs = {&#x27;driver_class&#x27;: &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;, &#x27;driver_kwargs&#x27;: {&#x27;desired_capabilities&#x27;: {&#x27;...for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;}<br/><br/>    def call_fixture_func(<br/>        fixturefunc: &quot;_FixtureFunc[_FixtureValue]&quot;, request: FixtureRequest, kwargs<br/>    ) -&gt; _FixtureValue:<br/>        if is_generator(fixturefunc):<br/>            fixturefunc = cast(<br/>                Callable[..., Generator[_FixtureValue, None, None]], fixturefunc<br/>            )<br/>            generator = fixturefunc(**kwargs)<br/>            try:<br/>&gt;               fixture_result = next(generator)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:925: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/>driver_class = &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;<br/>driver_kwargs = {&#x27;desired_capabilities&#x27;: {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}, &#x27;executable_path&#x27;: &#x27;....\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a2\\driver.log&#x27;}<br/><br/>    @pytest.fixture<br/>    def driver(request, driver_class, driver_kwargs):<br/>        &quot;&quot;&quot;Returns a WebDriver instance based on options and capabilities&quot;&quot;&quot;<br/>    <br/>        retries = int(request.config.getini(&quot;max_driver_init_attempts&quot;))<br/>&gt;       for retry in Retrying(<br/>            stop=stop_after_attempt(retries), wait=wait_exponential(), reraise=True<br/>        ):<br/><br/>venv\lib\site-packages\pytest_selenium\pytest_selenium.py:201: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Retrying object at 0x15c7baab340 (stop=&lt;tenacity.stop.stop_after_attempt object at 0x0000015C7BAAB5B0&gt;, wait=&lt;tenacit...631370&gt;, before=&lt;function before_nothing at 0x0000015C7861BB80&gt;, after=&lt;function after_nothing at 0x0000015C7862F700&gt;)&gt;<br/><br/>    def __iter__(self):<br/>        self.begin(None)<br/>    <br/>        retry_state = RetryCallState(self, fn=None, args=(), kwargs={})<br/>        while True:<br/>&gt;           do = self.iter(retry_state=retry_state)<br/><br/>venv\lib\site-packages\tenacity\__init__.py:394: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Retrying object at 0x15c7baab340 (stop=&lt;tenacity.stop.stop_after_attempt object at 0x0000015C7BAAB5B0&gt;, wait=&lt;tenacit...631370&gt;, before=&lt;function before_nothing at 0x0000015C7861BB80&gt;, after=&lt;function after_nothing at 0x0000015C7862F700&gt;)&gt;<br/>retry_state = &lt;tenacity.RetryCallState object at 0x0000015C7BAAB190&gt;<br/><br/>    def iter(self, retry_state):  # noqa<br/>        fut = retry_state.outcome<br/>        if fut is None:<br/>            if self.before is not None:<br/>                self.before(retry_state)<br/>            return DoAttempt()<br/>    <br/>        is_explicit_retry = retry_state.outcome.failed \<br/>            and isinstance(retry_state.outcome.exception(), TryAgain)<br/>        if not (is_explicit_retry or self.retry(retry_state=retry_state)):<br/>            return fut.result()<br/>    <br/>        if self.after is not None:<br/>            self.after(retry_state=retry_state)<br/>    <br/>        self.statistics[&#x27;delay_since_first_attempt&#x27;] = \<br/>            retry_state.seconds_since_start<br/>        if self.stop(retry_state=retry_state):<br/>            if self.retry_error_callback:<br/>                return self.retry_error_callback(retry_state=retry_state)<br/>            retry_exc = self.retry_error_cls(fut)<br/>            if self.reraise:<br/>&gt;               raise retry_exc.reraise()<br/><br/>venv\lib\site-packages\tenacity\__init__.py:372: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = RetryError(&lt;Future at 0x15c7baab640 state=finished raised WebDriverException&gt;)<br/><br/>    def reraise(self):<br/>        if self.last_attempt.failed:<br/>&gt;           raise self.last_attempt.result()<br/><br/>venv\lib\site-packages\tenacity\__init__.py:189: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = None, timeout = None<br/><br/>    def result(self, timeout=None):<br/>        &quot;&quot;&quot;Return the result of the call that the future represents.<br/>    <br/>        Args:<br/>            timeout: The number of seconds to wait for the result if the future<br/>                isn&#x27;t done. If None, then there is no limit on the wait time.<br/>    <br/>        Returns:<br/>            The result of the call that the future represents.<br/>    <br/>        Raises:<br/>            CancelledError: If the future was cancelled.<br/>            TimeoutError: If the future didn&#x27;t finish executing before the given<br/>                timeout.<br/>            Exception: If the call raised then that exception will be raised.<br/>        &quot;&quot;&quot;<br/>        try:<br/>            with self._condition:<br/>                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:<br/>                    raise CancelledError()<br/>                elif self._state == FINISHED:<br/>&gt;                   return self.__get_result()<br/><br/>C:\Program Files\Python39\lib\concurrent\futures\_base.py:439: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = None<br/><br/>    def __get_result(self):<br/>        if self._exception:<br/>            try:<br/>&gt;               raise self._exception<br/><br/>C:\Program Files\Python39\lib\concurrent\futures\_base.py:391: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-left-40px]&gt;&gt;<br/>driver_class = &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;<br/>driver_kwargs = {&#x27;desired_capabilities&#x27;: {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}, &#x27;executable_path&#x27;: &#x27;....\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a2\\driver.log&#x27;}<br/><br/>    @pytest.fixture<br/>    def driver(request, driver_class, driver_kwargs):<br/>        &quot;&quot;&quot;Returns a WebDriver instance based on options and capabilities&quot;&quot;&quot;<br/>    <br/>        retries = int(request.config.getini(&quot;max_driver_init_attempts&quot;))<br/>        for retry in Retrying(<br/>            stop=stop_after_attempt(retries), wait=wait_exponential(), reraise=True<br/>        ):<br/>            with retry:<br/>                LOGGER.info(<br/>                    f&quot;Driver init, attempt {retry.retry_state.attempt_number}/{retries}&quot;<br/>                )<br/>&gt;               driver = driver_class(**driver_kwargs)<br/><br/>venv\lib\site-packages\pytest_selenium\pytest_selenium.py:208: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[AttributeError(&quot;&#x27;WebDriver&#x27; object has no attribute &#x27;session_id&#x27;&quot;) raised in repr()] WebDriver object at 0x15c7baab700&gt;<br/>executable_path = &#x27;./binaries/webdriver/chromedriver.exe&#x27;, port = 0, options = &lt;selenium.webdriver.chrome.options.Options object at 0x0000015C7BCC70D0&gt;<br/>service_args = None, desired_capabilities = {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}<br/>service_log_path = &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a2\\driver.log&#x27;<br/>chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BAAB610&gt;, keep_alive = True<br/><br/>    def __init__(self, executable_path=DEFAULT_EXECUTABLE_PATH, port=DEFAULT_PORT,<br/>                 options: Options = None, service_args=None,<br/>                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,<br/>                 chrome_options=None, service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):<br/>        &quot;&quot;&quot;<br/>        Creates a new instance of the chrome driver.<br/>        Starts the service and then creates new instance of chrome driver.<br/>    <br/>        :Args:<br/>         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH<br/>         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.<br/>         - options - this takes an instance of ChromeOptions<br/>         - service - Service object for handling the browser driver if you need to pass extra details<br/>         - service_args - Deprecated: List of args to pass to the driver service<br/>         - desired_capabilities - Deprecated: Dictionary object with non-browser specific<br/>           capabilities only, such as &quot;proxy&quot; or &quot;loggingPref&quot;.<br/>         - service_log_path - Deprecated: Where to log information from the driver.<br/>         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.<br/>        &quot;&quot;&quot;<br/>        if executable_path != &#x27;chromedriver&#x27;:<br/>            warnings.warn(&#x27;executable_path has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if chrome_options:<br/>            warnings.warn(&#x27;use options instead of chrome_options&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>            options = chrome_options<br/>        if keep_alive != DEFAULT_KEEP_ALIVE:<br/>            warnings.warn(&#x27;keep_alive has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        else:<br/>            keep_alive = True<br/>        if not service:<br/>            service = Service(executable_path, port, service_args, service_log_path)<br/>    <br/>&gt;       super(WebDriver, self).__init__(DesiredCapabilities.CHROME[&#x27;browserName&#x27;], &quot;goog&quot;,<br/>                                        port, options,<br/>                                        service_args, desired_capabilities,<br/>                                        service_log_path, service, keep_alive)<br/><br/>venv\lib\site-packages\selenium\webdriver\chrome\webdriver.py:70: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[AttributeError(&quot;&#x27;WebDriver&#x27; object has no attribute &#x27;session_id&#x27;&quot;) raised in repr()] WebDriver object at 0x15c7baab700&gt;, browser_name = &#x27;chrome&#x27;<br/>vendor_prefix = &#x27;goog&#x27;, port = 0, options = &lt;selenium.webdriver.chrome.options.Options object at 0x0000015C7BCC70D0&gt;, service_args = None<br/>desired_capabilities = {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}<br/>service_log_path = &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a2\\driver.log&#x27;<br/>service = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BAAB610&gt;, keep_alive = True<br/><br/>    def __init__(self, browser_name, vendor_prefix,<br/>                 port=DEFAULT_PORT, options: BaseOptions = None, service_args=None,<br/>                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,<br/>                 service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):<br/>        &quot;&quot;&quot;<br/>        Creates a new WebDriver instance of the ChromiumDriver.<br/>        Starts the service and then creates new WebDriver instance of ChromiumDriver.<br/>    <br/>        :Args:<br/>         - browser_name - Browser name used when matching capabilities.<br/>         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.<br/>         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.<br/>         - options - this takes an instance of ChromiumOptions<br/>         - service_args - Deprecated: List of args to pass to the driver service<br/>         - desired_capabilities - Deprecated: Dictionary object with non-browser specific<br/>           capabilities only, such as &quot;proxy&quot; or &quot;loggingPref&quot;.<br/>         - service_log_path - Deprecated: Where to log information from the driver.<br/>         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.<br/>        &quot;&quot;&quot;<br/>        if desired_capabilities:<br/>            warnings.warn(&#x27;desired_capabilities has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if port != DEFAULT_PORT:<br/>            warnings.warn(&#x27;port has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        self.port = port<br/>        if service_log_path != DEFAULT_SERVICE_LOG_PATH:<br/>            warnings.warn(&#x27;service_log_path has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:<br/>            warnings.warn(&#x27;keep_alive has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        else:<br/>            keep_alive = True<br/>    <br/>        self.vendor_prefix = vendor_prefix<br/>    <br/>        _ignore_proxy = None<br/>        if not options:<br/>            options = self.create_options()<br/>    <br/>        if desired_capabilities:<br/>            for key, value in desired_capabilities.items():<br/>                options.set_capability(key, value)<br/>    <br/>        if options._ignore_local_proxy:<br/>            _ignore_proxy = options._ignore_local_proxy<br/>    <br/>        if not service:<br/>            raise AttributeError(&#x27;service cannot be None&#x27;)<br/>    <br/>        self.service = service<br/>&gt;       self.service.start()<br/><br/>venv\lib\site-packages\selenium\webdriver\chromium\webdriver.py:90: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BAAB610&gt;<br/><br/>    def start(self):<br/>        &quot;&quot;&quot;<br/>        Starts the Service.<br/>    <br/>        :Exceptions:<br/>         - WebDriverException : Raised either when it can&#x27;t start the service<br/>           or when it can&#x27;t connect to the service<br/>        &quot;&quot;&quot;<br/>        try:<br/>            cmd = [self.path]<br/>            cmd.extend(self.command_line_args())<br/>            self.process = subprocess.Popen(cmd, env=self.env,<br/>                                            close_fds=system() != &#x27;Windows&#x27;,<br/>                                            stdout=self.log_file,<br/>                                            stderr=self.log_file,<br/>                                            stdin=PIPE,<br/>                                            creationflags=self.creationflags)<br/>        except TypeError:<br/>            raise<br/>        except OSError as err:<br/>            if err.errno == errno.ENOENT:<br/>&gt;               raise WebDriverException(<br/>                    &quot;&#x27;%s&#x27; executable needs to be in PATH. %s&quot; % (<br/>                        os.path.basename(self.path), self.start_error_message)<br/><span class="error">E                       selenium.common.exceptions.WebDriverException: Message: &#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.chromium.org/home</span><br/><br/>venv\lib\site-packages\selenium\webdriver\common\service.py:81: WebDriverException<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;_HookCaller &#x27;pytest_bdd_step_error&#x27;&gt;<br/>kwargs = {&#x27;exception&#x27;: WebDriverException(&quot;&#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.c...=&#x27;Then&#x27;, failed=None, scenario=None, background=None, lines=[])], tags={&#x27;TR-C393228&#x27;, &#x27;automated&#x27;, &#x27;regression&#x27;}), ...}<br/>firstresult = False<br/><br/>    def __call__(self, **kwargs: object) -&gt; Any:<br/>        assert (<br/>            not self.is_historic()<br/>        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;<br/>        self._verify_all_args_are_provided(kwargs)<br/>        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False<br/>&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_hooks.py:433: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv\lib\site-packages\pluggy\_manager.py:112: in _hookexec<br/>    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)<br/>venv\lib\site-packages\enhanced_reports\core.py:493: in pytest_bdd_step_error<br/>    __capture_js_logs(current_state, driver, op_name)<br/>venv\lib\site-packages\enhanced_reports\core.py:234: in __capture_js_logs<br/>    logs = browser_console_manager.get_js_logs(driver)<br/>venv\lib\site-packages\enhanced_reports\browser_console_manager.py:13: in get_js_logs<br/>    logs = _capture_output(driver)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>driver = None<br/><br/>    def _capture_output(driver: WebDriver):<br/>&gt;       return driver.get_log(&quot;browser&quot;)<br/><span class="error">E       AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;get_log&#x27;</span><br/><br/>venv\lib\site-packages\enhanced_reports\browser_console_manager.py:18: AttributeError<br/> -----------------------------Captured stderr setup------------------------------ <br/>2023-06-22 05:35:27 [info     ] current param_value False
<br/> -------------------------------Captured log setup------------------------------- <br/>2023-06-22 11:05:27 INFO current param_value False<br/> ------------------------------Captured stderr call------------------------------ <br/>

2023-06-22 05:35:27 [info     ] Scenario Execution Started.    feature=Galaxy automated regression - button and anchor components scenario_name=Verify PPC - Buttons and Anchor - Loading Button
2023-06-22 05:35:27 [info     ] Capabilities from markers: {}
2023-06-22 05:35:27 [info     ] Driver init, attempt 1/3
2023-06-22 05:35:28 [info     ] Driver init, attempt 2/3
2023-06-22 05:35:30 [info     ] Driver init, attempt 3/3
2023-06-22 05:35:30 [error    ] Step FAILED.                   step=I am on the page &#x27;/&#x27;
Traceback (most recent call last):
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\common\service.py&quot;, line 71, in start
    self.process = subprocess.Popen(cmd, env=self.env,
  File &quot;C:\Program Files\Python39\lib\subprocess.py&quot;, line 951, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File &quot;C:\Program Files\Python39\lib\subprocess.py&quot;, line 1420, in _execute_child
    hp, ht, pid, tid = _winapi.CreateProcess(executable, args,
FileNotFoundError: [WinError 2] The system cannot find the file specified

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_bdd\scenario.py&quot;, line 154, in _execute_step_function
    kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_bdd\scenario.py&quot;, line 154, in &lt;dictcomp&gt;
    kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 581, in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1072, in execute
    result = hook.pytest_fixture_setup(fixturedef=self, request=request)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_hooks.py&quot;, line 433, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_manager.py&quot;, line 112, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_callers.py&quot;, line 155, in _multicall
    return outcome.get_result()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_result.py&quot;, line 108, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_callers.py&quot;, line 80, in _multicall
    res = hook_impl.function(*args)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1126, in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 925, in call_fixture_func
    fixture_result = next(generator)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_selenium\pytest_selenium.py&quot;, line 201, in driver
    for retry in Retrying(
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 394, in __iter__
    do = self.iter(retry_state=retry_state)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 372, in iter
    raise retry_exc.reraise()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 189, in reraise
    raise self.last_attempt.result()
  File &quot;C:\Program Files\Python39\lib\concurrent\futures\_base.py&quot;, line 439, in result
    return self.__get_result()
  File &quot;C:\Program Files\Python39\lib\concurrent\futures\_base.py&quot;, line 391, in __get_result
    raise self._exception
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_selenium\pytest_selenium.py&quot;, line 208, in driver
    driver = driver_class(**driver_kwargs)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\chrome\webdriver.py&quot;, line 70, in __init__
    super(WebDriver, self).__init__(DesiredCapabilities.CHROME[&#x27;browserName&#x27;], &quot;goog&quot;,
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\chromium\webdriver.py&quot;, line 90, in __init__
    self.service.start()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\common\service.py&quot;, line 81, in start
    raise WebDriverException(
selenium.common.exceptions.WebDriverException: Message: &#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.chromium.org/home

2023-06-22 05:35:30 [info     ] current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 05:35:30 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
2023-06-22 05:35:30 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
2023-06-22 05:35:30 [info     ] Scenario Execution Completed.  feature=Galaxy automated regression - button and anchor components scenario_name=Verify PPC - Buttons and Anchor - Loading Button
2023-06-22 05:35:30 [info     ] current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 05:35:30 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-section">Galaxy automated regression -&gt; button and anchor components</td>
          <td class="col-tags">TR-C393228</td>
          <td class="col-name">Verify PPC - Buttons and Anchor - Loading Button  locator: helixComponent &gt; loading_button, attribute: padding-right, value: 40px</td>
          <td class="col-result">Failed</td>
          <td class="col-duration">00:03.04</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="6">
            <div class="log">self = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BA316D0&gt;<br/><br/>    def start(self):<br/>        &quot;&quot;&quot;<br/>        Starts the Service.<br/>    <br/>        :Exceptions:<br/>         - WebDriverException : Raised either when it can&#x27;t start the service<br/>           or when it can&#x27;t connect to the service<br/>        &quot;&quot;&quot;<br/>        try:<br/>            cmd = [self.path]<br/>            cmd.extend(self.command_line_args())<br/>&gt;           self.process = subprocess.Popen(cmd, env=self.env,<br/>                                            close_fds=system() != &#x27;Windows&#x27;,<br/>                                            stdout=self.log_file,<br/>                                            stderr=self.log_file,<br/>                                            stdin=PIPE,<br/>                                            creationflags=self.creationflags)<br/><br/>venv\lib\site-packages\selenium\webdriver\common\service.py:71: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Popen: returncode: None args: [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--...&gt;<br/>args = [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--port=52305&#x27;, &#x27;--log-path=C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a3\\driver.log&#x27;]<br/>bufsize = -1, executable = None, stdin = -1, stdout = -3, stderr = -3, preexec_fn = None, close_fds = False, shell = False, cwd = None<br/>env = environ({&#x27;__INTELLIJ_COMMAND_HISTFILE__&#x27;: &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\terminal\\...s.py::test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px] (call)&#x27;})<br/>universal_newlines = None, startupinfo = None, creationflags = 0, restore_signals = True, start_new_session = False, pass_fds = ()<br/><br/>    def __init__(self, args, bufsize=-1, executable=None,<br/>                 stdin=None, stdout=None, stderr=None,<br/>                 preexec_fn=None, close_fds=True,<br/>                 shell=False, cwd=None, env=None, universal_newlines=None,<br/>                 startupinfo=None, creationflags=0,<br/>                 restore_signals=True, start_new_session=False,<br/>                 pass_fds=(), *, user=None, group=None, extra_groups=None,<br/>                 encoding=None, errors=None, text=None, umask=-1):<br/>        &quot;&quot;&quot;Create new Popen instance.&quot;&quot;&quot;<br/>        _cleanup()<br/>        # Held while anything is calling waitpid before returncode has been<br/>        # updated to prevent clobbering returncode if wait() or poll() are<br/>        # called from multiple threads at once.  After acquiring the lock,<br/>        # code must re-check self.returncode to see if another thread just<br/>        # finished a waitpid() call.<br/>        self._waitpid_lock = threading.Lock()<br/>    <br/>        self._input = None<br/>        self._communication_started = False<br/>        if bufsize is None:<br/>            bufsize = -1  # Restore default<br/>        if not isinstance(bufsize, int):<br/>            raise TypeError(&quot;bufsize must be an integer&quot;)<br/>    <br/>        if _mswindows:<br/>            if preexec_fn is not None:<br/>                raise ValueError(&quot;preexec_fn is not supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>        else:<br/>            # POSIX<br/>            if pass_fds and not close_fds:<br/>                warnings.warn(&quot;pass_fds overriding close_fds.&quot;, RuntimeWarning)<br/>                close_fds = True<br/>            if startupinfo is not None:<br/>                raise ValueError(&quot;startupinfo is only supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>            if creationflags != 0:<br/>                raise ValueError(&quot;creationflags is only supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>    <br/>        self.args = args<br/>        self.stdin = None<br/>        self.stdout = None<br/>        self.stderr = None<br/>        self.pid = None<br/>        self.returncode = None<br/>        self.encoding = encoding<br/>        self.errors = errors<br/>    <br/>        # Validate the combinations of text and universal_newlines<br/>        if (text is not None and universal_newlines is not None<br/>            and bool(universal_newlines) != bool(text)):<br/>            raise SubprocessError(&#x27;Cannot disambiguate when both text &#x27;<br/>                                  &#x27;and universal_newlines are supplied but &#x27;<br/>                                  &#x27;different. Pass one or the other.&#x27;)<br/>    <br/>        # Input and output objects. The general principle is like<br/>        # this:<br/>        #<br/>        # Parent                   Child<br/>        # ------                   -----<br/>        # p2cwrite   ---stdin---&gt;  p2cread<br/>        # c2pread    &lt;--stdout---  c2pwrite<br/>        # errread    &lt;--stderr---  errwrite<br/>        #<br/>        # On POSIX, the child objects are file descriptors.  On<br/>        # Windows, these are Windows file handles.  The parent objects<br/>        # are file descriptors on both platforms.  The parent objects<br/>        # are -1 when not using PIPEs. The child objects are -1<br/>        # when not redirecting.<br/>    <br/>        (p2cread, p2cwrite,<br/>         c2pread, c2pwrite,<br/>         errread, errwrite) = self._get_handles(stdin, stdout, stderr)<br/>    <br/>        # We wrap OS handles *before* launching the child, otherwise a<br/>        # quickly terminating child could make our fds unwrappable<br/>        # (see #8458).<br/>    <br/>        if _mswindows:<br/>            if p2cwrite != -1:<br/>                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)<br/>            if c2pread != -1:<br/>                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)<br/>            if errread != -1:<br/>                errread = msvcrt.open_osfhandle(errread.Detach(), 0)<br/>    <br/>        self.text_mode = encoding or errors or text or universal_newlines<br/>    <br/>        # How long to resume waiting on a child after the first ^C.<br/>        # There is no right value for this.  The purpose is to be polite<br/>        # yet remain good for interactive users trying to exit a tool.<br/>        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()<br/>    <br/>        self._closed_child_pipe_fds = False<br/>    <br/>        if self.text_mode:<br/>            if bufsize == 1:<br/>                line_buffering = True<br/>                # Use the default buffer size for the underlying binary streams<br/>                # since they don&#x27;t support line buffering.<br/>                bufsize = -1<br/>            else:<br/>                line_buffering = False<br/>    <br/>        gid = None<br/>        if group is not None:<br/>            if not hasattr(os, &#x27;setregid&#x27;):<br/>                raise ValueError(&quot;The &#x27;group&#x27; parameter is not supported on the &quot;<br/>                                 &quot;current platform&quot;)<br/>    <br/>            elif isinstance(group, str):<br/>                if grp is None:<br/>                    raise ValueError(&quot;The group parameter cannot be a string &quot;<br/>                                     &quot;on systems without the grp module&quot;)<br/>    <br/>                gid = grp.getgrnam(group).gr_gid<br/>            elif isinstance(group, int):<br/>                gid = group<br/>            else:<br/>                raise TypeError(&quot;Group must be a string or an integer, not {}&quot;<br/>                                .format(type(group)))<br/>    <br/>            if gid &lt; 0:<br/>                raise ValueError(f&quot;Group ID cannot be negative, got {gid}&quot;)<br/>    <br/>        gids = None<br/>        if extra_groups is not None:<br/>            if not hasattr(os, &#x27;setgroups&#x27;):<br/>                raise ValueError(&quot;The &#x27;extra_groups&#x27; parameter is not &quot;<br/>                                 &quot;supported on the current platform&quot;)<br/>    <br/>            elif isinstance(extra_groups, str):<br/>                raise ValueError(&quot;Groups must be a list, not a string&quot;)<br/>    <br/>            gids = []<br/>            for extra_group in extra_groups:<br/>                if isinstance(extra_group, str):<br/>                    if grp is None:<br/>                        raise ValueError(&quot;Items in extra_groups cannot be &quot;<br/>                                         &quot;strings on systems without the &quot;<br/>                                         &quot;grp module&quot;)<br/>    <br/>                    gids.append(grp.getgrnam(extra_group).gr_gid)<br/>                elif isinstance(extra_group, int):<br/>                    gids.append(extra_group)<br/>                else:<br/>                    raise TypeError(&quot;Items in extra_groups must be a string &quot;<br/>                                    &quot;or integer, not {}&quot;<br/>                                    .format(type(extra_group)))<br/>    <br/>            # make sure that the gids are all positive here so we can do less<br/>            # checking in the C code<br/>            for gid_check in gids:<br/>                if gid_check &lt; 0:<br/>                    raise ValueError(f&quot;Group ID cannot be negative, got {gid_check}&quot;)<br/>    <br/>        uid = None<br/>        if user is not None:<br/>            if not hasattr(os, &#x27;setreuid&#x27;):<br/>                raise ValueError(&quot;The &#x27;user&#x27; parameter is not supported on &quot;<br/>                                 &quot;the current platform&quot;)<br/>    <br/>            elif isinstance(user, str):<br/>                if pwd is None:<br/>                    raise ValueError(&quot;The user parameter cannot be a string &quot;<br/>                                     &quot;on systems without the pwd module&quot;)<br/>    <br/>                uid = pwd.getpwnam(user).pw_uid<br/>            elif isinstance(user, int):<br/>                uid = user<br/>            else:<br/>                raise TypeError(&quot;User must be a string or an integer&quot;)<br/>    <br/>            if uid &lt; 0:<br/>                raise ValueError(f&quot;User ID cannot be negative, got {uid}&quot;)<br/>    <br/>        try:<br/>            if p2cwrite != -1:<br/>                self.stdin = io.open(p2cwrite, &#x27;wb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,<br/>                            line_buffering=line_buffering,<br/>                            encoding=encoding, errors=errors)<br/>            if c2pread != -1:<br/>                self.stdout = io.open(c2pread, &#x27;rb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stdout = io.TextIOWrapper(self.stdout,<br/>                            encoding=encoding, errors=errors)<br/>            if errread != -1:<br/>                self.stderr = io.open(errread, &#x27;rb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stderr = io.TextIOWrapper(self.stderr,<br/>                            encoding=encoding, errors=errors)<br/>    <br/>&gt;           self._execute_child(args, executable, preexec_fn, close_fds,<br/>                                pass_fds, cwd, env,<br/>                                startupinfo, creationflags, shell,<br/>                                p2cread, p2cwrite,<br/>                                c2pread, c2pwrite,<br/>                                errread, errwrite,<br/>                                restore_signals,<br/>                                gid, gids, uid, umask,<br/>                                start_new_session)<br/><br/>C:\Program Files\Python39\lib\subprocess.py:951: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Popen: returncode: None args: [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--...&gt;<br/>args = &#x27;./binaries/webdriver/chromedriver.exe --port=52305 --log-path=C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a3\\driver.log&#x27;<br/>executable = None, preexec_fn = None, close_fds = False, pass_fds = (), cwd = None<br/>env = environ({&#x27;__INTELLIJ_COMMAND_HISTFILE__&#x27;: &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\terminal\\...s.py::test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px] (call)&#x27;})<br/>startupinfo = &lt;subprocess.STARTUPINFO object at 0x0000015C7BA31430&gt;, creationflags = 0, shell = False, p2cread = Handle(1516), p2cwrite = 16, c2pread = -1<br/>c2pwrite = Handle(1392), errread = -1, errwrite = Handle(1388), unused_restore_signals = True, unused_gid = None, unused_gids = None, unused_uid = None<br/>unused_umask = -1, unused_start_new_session = False<br/><br/>    def _execute_child(self, args, executable, preexec_fn, close_fds,<br/>                       pass_fds, cwd, env,<br/>                       startupinfo, creationflags, shell,<br/>                       p2cread, p2cwrite,<br/>                       c2pread, c2pwrite,<br/>                       errread, errwrite,<br/>                       unused_restore_signals,<br/>                       unused_gid, unused_gids, unused_uid,<br/>                       unused_umask,<br/>                       unused_start_new_session):<br/>        &quot;&quot;&quot;Execute program (MS Windows version)&quot;&quot;&quot;<br/>    <br/>        assert not pass_fds, &quot;pass_fds not supported on Windows.&quot;<br/>    <br/>        if isinstance(args, str):<br/>            pass<br/>        elif isinstance(args, bytes):<br/>            if shell:<br/>                raise TypeError(&#x27;bytes args is not allowed on Windows&#x27;)<br/>            args = list2cmdline([args])<br/>        elif isinstance(args, os.PathLike):<br/>            if shell:<br/>                raise TypeError(&#x27;path-like args is not allowed when &#x27;<br/>                                &#x27;shell is true&#x27;)<br/>            args = list2cmdline([args])<br/>        else:<br/>            args = list2cmdline(args)<br/>    <br/>        if executable is not None:<br/>            executable = os.fsdecode(executable)<br/>    <br/>        # Process startup details<br/>        if startupinfo is None:<br/>            startupinfo = STARTUPINFO()<br/>        else:<br/>            # bpo-34044: Copy STARTUPINFO since it is modified above,<br/>            # so the caller can reuse it multiple times.<br/>            startupinfo = startupinfo.copy()<br/>    <br/>        use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)<br/>        if use_std_handles:<br/>            startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES<br/>            startupinfo.hStdInput = p2cread<br/>            startupinfo.hStdOutput = c2pwrite<br/>            startupinfo.hStdError = errwrite<br/>    <br/>        attribute_list = startupinfo.lpAttributeList<br/>        have_handle_list = bool(attribute_list and<br/>                                &quot;handle_list&quot; in attribute_list and<br/>                                attribute_list[&quot;handle_list&quot;])<br/>    <br/>        # If we were given an handle_list or need to create one<br/>        if have_handle_list or (use_std_handles and close_fds):<br/>            if attribute_list is None:<br/>                attribute_list = startupinfo.lpAttributeList = {}<br/>            handle_list = attribute_list[&quot;handle_list&quot;] = \<br/>                list(attribute_list.get(&quot;handle_list&quot;, []))<br/>    <br/>            if use_std_handles:<br/>                handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]<br/>    <br/>            handle_list[:] = self._filter_handle_list(handle_list)<br/>    <br/>            if handle_list:<br/>                if not close_fds:<br/>                    warnings.warn(&quot;startupinfo.lpAttributeList[&#x27;handle_list&#x27;] &quot;<br/>                                  &quot;overriding close_fds&quot;, RuntimeWarning)<br/>    <br/>                # When using the handle_list we always request to inherit<br/>                # handles but the only handles that will be inherited are<br/>                # the ones in the handle_list<br/>                close_fds = False<br/>    <br/>        if shell:<br/>            startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW<br/>            startupinfo.wShowWindow = _winapi.SW_HIDE<br/>            comspec = os.environ.get(&quot;COMSPEC&quot;, &quot;cmd.exe&quot;)<br/>            args = &#x27;{} /c &quot;{}&quot;&#x27;.format (comspec, args)<br/>    <br/>        if cwd is not None:<br/>            cwd = os.fsdecode(cwd)<br/>    <br/>        sys.audit(&quot;subprocess.Popen&quot;, executable, args, cwd, env)<br/>    <br/>        # Start the process<br/>        try:<br/>&gt;           hp, ht, pid, tid = _winapi.CreateProcess(executable, args,<br/>                                     # no special security<br/>                                     None, None,<br/>                                     int(not close_fds),<br/>                                     creationflags,<br/>                                     env,<br/>                                     cwd,<br/>                                     startupinfo)<br/><span class="error">E                                    FileNotFoundError: [WinError 2] The system cannot find the file specified</span><br/><br/>C:\Program Files\Python39\lib\subprocess.py:1420: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>request = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/>scenario = Scenario(feature=Feature(scenarios=OrderedDict([(&#x27;Verify PPC - Buttons and Anchor - Loading Button&#x27;, ScenarioTemplate(...eyword=&#x27;Then&#x27;, failed=None, scenario=None, background=None, lines=[])], tags={&#x27;TR-C393228&#x27;, &#x27;automated&#x27;, &#x27;regression&#x27;})<br/>step = Step(type=&#x27;given&#x27;, _name=&quot;I am on the page &#x27;/&#x27;&quot;, line_number=5, indent=8, keyword=&#x27;Given&#x27;, failed=True, scenario=None,...closeIcon&#x27;&quot;, line_number=8, indent=8, keyword=&#x27;And&#x27;, failed=None, scenario=None, background=..., lines=[])]), lines=[])<br/>context = StepFunctionContext(type=&#x27;given&#x27;, step_func=&lt;function open_webpage at 0x0000015C7A412820&gt;, parser=&lt;pytest_bdd.parsers....t at 0x0000015C7A40F7C0&gt;, converters={&#x27;page_url&#x27;: &lt;function env_formatted at 0x0000015C78B20700&gt;}, target_fixture=None)<br/><br/>    def _execute_step_function(<br/>        request: FixtureRequest, scenario: Scenario, step: Step, context: StepFunctionContext<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;Execute step function.&quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        kw = {<br/>            &quot;request&quot;: request,<br/>            &quot;feature&quot;: scenario.feature,<br/>            &quot;scenario&quot;: scenario,<br/>            &quot;step&quot;: step,<br/>            &quot;step_func&quot;: context.step_func,<br/>            &quot;step_func_args&quot;: {},<br/>        }<br/>    <br/>        request.config.hook.pytest_bdd_before_step(**kw)<br/>    <br/>        # Get the step argument values.<br/>        converters = context.converters<br/>        kwargs = {}<br/>        args = get_args(context.step_func)<br/>    <br/>        try:<br/>            parsed_args = context.parser.parse_arguments(step.name)<br/>            assert parsed_args is not None, (<br/>                f&quot;Unexpected `NoneType` returned from &quot; f&quot;parse_arguments(...) in parser: {context.parser!r}&quot;<br/>            )<br/>            for arg, value in parsed_args.items():<br/>                if arg in converters:<br/>                    value = converters[arg](value)<br/>                kwargs[arg] = value<br/>    <br/>&gt;           kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}<br/><br/>venv\lib\site-packages\pytest_bdd\scenario.py:154: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>.0 = &lt;list_iterator object at 0x0000015C7BA201F0&gt;<br/><br/>&gt;   kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}<br/><br/>venv\lib\site-packages\pytest_bdd\scenario.py:154: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/>argname = &#x27;selenium_generics&#x27;<br/><br/>    def getfixturevalue(self, argname: str) -&gt; Any:<br/>        &quot;&quot;&quot;Dynamically run a named fixture function.<br/>    <br/>        Declaring fixtures via function argument is recommended where possible.<br/>        But if you can only decide whether to use another fixture at test<br/>        setup time, you may use this function to retrieve it inside a fixture<br/>        or test function body.<br/>    <br/>        :raises pytest.FixtureLookupError:<br/>            If the given fixture could not be found.<br/>        &quot;&quot;&quot;<br/>&gt;       fixturedef = self._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:581: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/>argname = &#x27;selenium_generics&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium_generics&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium_generics&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/>argname = &#x27;selenium&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/>argname = &#x27;selenium&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/>argname = &#x27;driver&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>            fixturedef = request._get_active_fixturedef(argname)<br/>            if argname != &quot;request&quot;:<br/>                # PseudoFixtureDef is only for &quot;request&quot;.<br/>                assert isinstance(fixturedef, FixtureDef)<br/>                fixturedef.addfinalizer(functools.partial(self.finish, request=request))<br/>    <br/>        my_cache_key = self.cache_key(request)<br/>        if self.cached_result is not None:<br/>            # note: comparison with `==` can fail (or be expensive) for e.g.<br/>            # numpy arrays (#6497).<br/>            cache_key = self.cached_result[1]<br/>            if my_cache_key is cache_key:<br/>                if self.cached_result[2] is not None:<br/>                    _, val, tb = self.cached_result[2]<br/>                    raise val.with_traceback(tb)<br/>                else:<br/>                    result = self.cached_result[0]<br/>                    return result<br/>            # We have a previous but differently parametrized fixture instance<br/>            # so we need to tear it down before creating a new one.<br/>            self.finish(request)<br/>            assert self.cached_result is None<br/>    <br/>        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)<br/>&gt;       result = hook.pytest_fixture_setup(fixturedef=self, request=request)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1072: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_HookCaller &#x27;pytest_fixture_setup&#x27;&gt;<br/>kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def __call__(self, **kwargs: object) -&gt; Any:<br/>        assert (<br/>            not self.is_historic()<br/>        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;<br/>        self._verify_all_args_are_provided(kwargs)<br/>        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False<br/>&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_hooks.py:433: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_pytest.config.PytestPluginManager object at 0x0000015C7034A250&gt;, hook_name = &#x27;pytest_fixture_setup&#x27;<br/>methods = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _hookexec(<br/>        self,<br/>        hook_name: str,<br/>        methods: Sequence[HookImpl],<br/>        kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        # called from all hookcaller instances.<br/>        # enable_tracing will set its own wrapping function at self._inner_hookexec<br/>&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_manager.py:112: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_name = &#x27;pytest_fixture_setup&#x27;<br/>hook_impls = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>caller_kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _multicall(<br/>        hook_name: str,<br/>        hook_impls: Sequence[HookImpl],<br/>        caller_kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        results: list[object] = []<br/>        exception = None<br/>        only_new_style_wrappers = True<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns: list[Teardown] = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    f&quot;hook call must provide argument {argname!r}&quot;<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        only_new_style_wrappers = False<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            wrapper_gen = cast(Generator[None, _Result[object], None], res)<br/>                            next(wrapper_gen)  # first yield<br/>                            teardowns.append((wrapper_gen,))<br/>                        except StopIteration:<br/>                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)<br/>                    elif hook_impl.wrapper:<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            function_gen = cast(Generator[None, object, object], res)<br/>                            next(function_gen)  # first yield<br/>                            teardowns.append(function_gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)<br/>                    else:<br/>                        res = hook_impl.function(*args)<br/>                        if res is not None:<br/>                            results.append(res)<br/>                            if firstresult:  # halt further impl calls<br/>                                break<br/>            except BaseException as exc:<br/>                exception = exc<br/>        finally:<br/>            # Fast path - only new-style wrappers, no _Result.<br/>            if only_new_style_wrappers:<br/>                if firstresult:  # first result hooks return a single value<br/>                    result = results[0] if results else None<br/>                else:<br/>                    result = results<br/>    <br/>                # run all wrapper post-yield blocks<br/>                for teardown in reversed(teardowns):<br/>                    try:<br/>                        if exception is not None:<br/>                            teardown.throw(exception)  # type: ignore[union-attr]<br/>                        else:<br/>                            teardown.send(result)  # type: ignore[union-attr]<br/>                        # Following is unreachable for a well behaved hook wrapper.<br/>                        # Try to force finalizers otherwise postponed till GC action.<br/>                        # Note: close() may raise if generator handles GeneratorExit.<br/>                        teardown.close()  # type: ignore[union-attr]<br/>                    except StopIteration as si:<br/>                        result = si.value<br/>                        exception = None<br/>                        continue<br/>                    except BaseException as e:<br/>                        exception = e<br/>                        continue<br/>                    _raise_wrapfail(teardown, &quot;has second yield&quot;)  # type: ignore[arg-type]<br/>    <br/>                if exception is not None:<br/>                    raise exception.with_traceback(exception.__traceback__)<br/>                else:<br/>                    return result<br/>    <br/>            # Slow path - need to support old-style wrappers.<br/>            else:<br/>                if firstresult:  # first result hooks return a single value<br/>                    outcome: _Result[object | list[object]] = _Result(<br/>                        results[0] if results else None, exception<br/>                    )<br/>                else:<br/>                    outcome = _Result(results, exception)<br/>    <br/>                # run all wrapper post-yield blocks<br/>                for teardown in reversed(teardowns):<br/>                    if isinstance(teardown, tuple):<br/>                        try:<br/>                            teardown[0].send(outcome)<br/>                            _raise_wrapfail(teardown[0], &quot;has second yield&quot;)<br/>                        except StopIteration:<br/>                            pass<br/>                    else:<br/>                        try:<br/>                            if outcome._exception is not None:<br/>                                teardown.throw(outcome._exception)<br/>                            else:<br/>                                teardown.send(outcome._result)<br/>                            # Following is unreachable for a well behaved hook wrapper.<br/>                            # Try to force finalizers otherwise postponed till GC action.<br/>                            # Note: close() may raise if generator handles GeneratorExit.<br/>                            teardown.close()<br/>                        except StopIteration as si:<br/>                            outcome.force_result(si.value)<br/>                            continue<br/>                        except BaseException as e:<br/>                            outcome.force_exception(e)<br/>                            continue<br/>                        _raise_wrapfail(teardown, &quot;has second yield&quot;)<br/>    <br/>&gt;               return outcome.get_result()<br/><br/>venv\lib\site-packages\pluggy\_callers.py:155: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;pluggy._result._Result object at 0x0000015C7BA31CA0&gt;<br/><br/>    def get_result(self) -&gt; _T:<br/>        &quot;&quot;&quot;Get the result(s) for this hook call.<br/>    <br/>        If the hook was marked as a ``firstresult`` only a single value<br/>        will be returned, otherwise a list of results.<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        exc = self._exception<br/>        if exc is None:<br/>            return cast(_T, self._result)<br/>        else:<br/>&gt;           raise exc.with_traceback(exc.__traceback__)<br/><br/>venv\lib\site-packages\pluggy\_result.py:108: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_name = &#x27;pytest_fixture_setup&#x27;<br/>hook_impls = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>caller_kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _multicall(<br/>        hook_name: str,<br/>        hook_impls: Sequence[HookImpl],<br/>        caller_kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        results: list[object] = []<br/>        exception = None<br/>        only_new_style_wrappers = True<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns: list[Teardown] = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    f&quot;hook call must provide argument {argname!r}&quot;<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        only_new_style_wrappers = False<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            wrapper_gen = cast(Generator[None, _Result[object], None], res)<br/>                            next(wrapper_gen)  # first yield<br/>                            teardowns.append((wrapper_gen,))<br/>                        except StopIteration:<br/>                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)<br/>                    elif hook_impl.wrapper:<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            function_gen = cast(Generator[None, object, object], res)<br/>                            next(function_gen)  # first yield<br/>                            teardowns.append(function_gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)<br/>                    else:<br/>&gt;                       res = hook_impl.function(*args)<br/><br/>venv\lib\site-packages\pluggy\_callers.py:80: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fixturedef = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/><br/>    def pytest_fixture_setup(<br/>        fixturedef: FixtureDef[_FixtureValue], request: SubRequest<br/>    ) -&gt; _FixtureValue:<br/>        &quot;&quot;&quot;Execution of fixture setup.&quot;&quot;&quot;<br/>        kwargs = {}<br/>        for argname in fixturedef.argnames:<br/>            fixdef = request._get_active_fixturedef(argname)<br/>            assert fixdef.cached_result is not None<br/>            result, arg_cache_key, exc = fixdef.cached_result<br/>            request._check_scope(argname, request.scope, fixdef.scope)<br/>            kwargs[argname] = result<br/>    <br/>        fixturefunc = resolve_fixture_function(fixturedef, request)<br/>        my_cache_key = fixturedef.cache_key(request)<br/>        try:<br/>&gt;           result = call_fixture_func(fixturefunc, request, kwargs)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1126: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fixturefunc = &lt;function driver at 0x0000015C787C44C0&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/>kwargs = {&#x27;driver_class&#x27;: &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;, &#x27;driver_kwargs&#x27;: {&#x27;desired_capabilities&#x27;: {&#x27;...or &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;}<br/><br/>    def call_fixture_func(<br/>        fixturefunc: &quot;_FixtureFunc[_FixtureValue]&quot;, request: FixtureRequest, kwargs<br/>    ) -&gt; _FixtureValue:<br/>        if is_generator(fixturefunc):<br/>            fixturefunc = cast(<br/>                Callable[..., Generator[_FixtureValue, None, None]], fixturefunc<br/>            )<br/>            generator = fixturefunc(**kwargs)<br/>            try:<br/>&gt;               fixture_result = next(generator)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:925: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/>driver_class = &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;<br/>driver_kwargs = {&#x27;desired_capabilities&#x27;: {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}, &#x27;executable_path&#x27;: &#x27;....\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a3\\driver.log&#x27;}<br/><br/>    @pytest.fixture<br/>    def driver(request, driver_class, driver_kwargs):<br/>        &quot;&quot;&quot;Returns a WebDriver instance based on options and capabilities&quot;&quot;&quot;<br/>    <br/>        retries = int(request.config.getini(&quot;max_driver_init_attempts&quot;))<br/>&gt;       for retry in Retrying(<br/>            stop=stop_after_attempt(retries), wait=wait_exponential(), reraise=True<br/>        ):<br/><br/>venv\lib\site-packages\pytest_selenium\pytest_selenium.py:201: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Retrying object at 0x15c7ba31760 (stop=&lt;tenacity.stop.stop_after_attempt object at 0x0000015C7BA31D90&gt;, wait=&lt;tenacit...631370&gt;, before=&lt;function before_nothing at 0x0000015C7861BB80&gt;, after=&lt;function after_nothing at 0x0000015C7862F700&gt;)&gt;<br/><br/>    def __iter__(self):<br/>        self.begin(None)<br/>    <br/>        retry_state = RetryCallState(self, fn=None, args=(), kwargs={})<br/>        while True:<br/>&gt;           do = self.iter(retry_state=retry_state)<br/><br/>venv\lib\site-packages\tenacity\__init__.py:394: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Retrying object at 0x15c7ba31760 (stop=&lt;tenacity.stop.stop_after_attempt object at 0x0000015C7BA31D90&gt;, wait=&lt;tenacit...631370&gt;, before=&lt;function before_nothing at 0x0000015C7861BB80&gt;, after=&lt;function after_nothing at 0x0000015C7862F700&gt;)&gt;<br/>retry_state = &lt;tenacity.RetryCallState object at 0x0000015C7BA31730&gt;<br/><br/>    def iter(self, retry_state):  # noqa<br/>        fut = retry_state.outcome<br/>        if fut is None:<br/>            if self.before is not None:<br/>                self.before(retry_state)<br/>            return DoAttempt()<br/>    <br/>        is_explicit_retry = retry_state.outcome.failed \<br/>            and isinstance(retry_state.outcome.exception(), TryAgain)<br/>        if not (is_explicit_retry or self.retry(retry_state=retry_state)):<br/>            return fut.result()<br/>    <br/>        if self.after is not None:<br/>            self.after(retry_state=retry_state)<br/>    <br/>        self.statistics[&#x27;delay_since_first_attempt&#x27;] = \<br/>            retry_state.seconds_since_start<br/>        if self.stop(retry_state=retry_state):<br/>            if self.retry_error_callback:<br/>                return self.retry_error_callback(retry_state=retry_state)<br/>            retry_exc = self.retry_error_cls(fut)<br/>            if self.reraise:<br/>&gt;               raise retry_exc.reraise()<br/><br/>venv\lib\site-packages\tenacity\__init__.py:372: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = RetryError(&lt;Future at 0x15c7ba31670 state=finished raised WebDriverException&gt;)<br/><br/>    def reraise(self):<br/>        if self.last_attempt.failed:<br/>&gt;           raise self.last_attempt.result()<br/><br/>venv\lib\site-packages\tenacity\__init__.py:189: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = None, timeout = None<br/><br/>    def result(self, timeout=None):<br/>        &quot;&quot;&quot;Return the result of the call that the future represents.<br/>    <br/>        Args:<br/>            timeout: The number of seconds to wait for the result if the future<br/>                isn&#x27;t done. If None, then there is no limit on the wait time.<br/>    <br/>        Returns:<br/>            The result of the call that the future represents.<br/>    <br/>        Raises:<br/>            CancelledError: If the future was cancelled.<br/>            TimeoutError: If the future didn&#x27;t finish executing before the given<br/>                timeout.<br/>            Exception: If the call raised then that exception will be raised.<br/>        &quot;&quot;&quot;<br/>        try:<br/>            with self._condition:<br/>                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:<br/>                    raise CancelledError()<br/>                elif self._state == FINISHED:<br/>&gt;                   return self.__get_result()<br/><br/>C:\Program Files\Python39\lib\concurrent\futures\_base.py:439: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = None<br/><br/>    def __get_result(self):<br/>        if self._exception:<br/>            try:<br/>&gt;               raise self._exception<br/><br/>C:\Program Files\Python39\lib\concurrent\futures\_base.py:391: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-right-40px]&gt;&gt;<br/>driver_class = &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;<br/>driver_kwargs = {&#x27;desired_capabilities&#x27;: {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}, &#x27;executable_path&#x27;: &#x27;....\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a3\\driver.log&#x27;}<br/><br/>    @pytest.fixture<br/>    def driver(request, driver_class, driver_kwargs):<br/>        &quot;&quot;&quot;Returns a WebDriver instance based on options and capabilities&quot;&quot;&quot;<br/>    <br/>        retries = int(request.config.getini(&quot;max_driver_init_attempts&quot;))<br/>        for retry in Retrying(<br/>            stop=stop_after_attempt(retries), wait=wait_exponential(), reraise=True<br/>        ):<br/>            with retry:<br/>                LOGGER.info(<br/>                    f&quot;Driver init, attempt {retry.retry_state.attempt_number}/{retries}&quot;<br/>                )<br/>&gt;               driver = driver_class(**driver_kwargs)<br/><br/>venv\lib\site-packages\pytest_selenium\pytest_selenium.py:208: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[AttributeError(&quot;&#x27;WebDriver&#x27; object has no attribute &#x27;session_id&#x27;&quot;) raised in repr()] WebDriver object at 0x15c7ba31640&gt;<br/>executable_path = &#x27;./binaries/webdriver/chromedriver.exe&#x27;, port = 0, options = &lt;selenium.webdriver.chrome.options.Options object at 0x0000015C7BA31B50&gt;<br/>service_args = None, desired_capabilities = {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}<br/>service_log_path = &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a3\\driver.log&#x27;<br/>chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BA316D0&gt;, keep_alive = True<br/><br/>    def __init__(self, executable_path=DEFAULT_EXECUTABLE_PATH, port=DEFAULT_PORT,<br/>                 options: Options = None, service_args=None,<br/>                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,<br/>                 chrome_options=None, service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):<br/>        &quot;&quot;&quot;<br/>        Creates a new instance of the chrome driver.<br/>        Starts the service and then creates new instance of chrome driver.<br/>    <br/>        :Args:<br/>         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH<br/>         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.<br/>         - options - this takes an instance of ChromeOptions<br/>         - service - Service object for handling the browser driver if you need to pass extra details<br/>         - service_args - Deprecated: List of args to pass to the driver service<br/>         - desired_capabilities - Deprecated: Dictionary object with non-browser specific<br/>           capabilities only, such as &quot;proxy&quot; or &quot;loggingPref&quot;.<br/>         - service_log_path - Deprecated: Where to log information from the driver.<br/>         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.<br/>        &quot;&quot;&quot;<br/>        if executable_path != &#x27;chromedriver&#x27;:<br/>            warnings.warn(&#x27;executable_path has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if chrome_options:<br/>            warnings.warn(&#x27;use options instead of chrome_options&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>            options = chrome_options<br/>        if keep_alive != DEFAULT_KEEP_ALIVE:<br/>            warnings.warn(&#x27;keep_alive has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        else:<br/>            keep_alive = True<br/>        if not service:<br/>            service = Service(executable_path, port, service_args, service_log_path)<br/>    <br/>&gt;       super(WebDriver, self).__init__(DesiredCapabilities.CHROME[&#x27;browserName&#x27;], &quot;goog&quot;,<br/>                                        port, options,<br/>                                        service_args, desired_capabilities,<br/>                                        service_log_path, service, keep_alive)<br/><br/>venv\lib\site-packages\selenium\webdriver\chrome\webdriver.py:70: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[AttributeError(&quot;&#x27;WebDriver&#x27; object has no attribute &#x27;session_id&#x27;&quot;) raised in repr()] WebDriver object at 0x15c7ba31640&gt;, browser_name = &#x27;chrome&#x27;<br/>vendor_prefix = &#x27;goog&#x27;, port = 0, options = &lt;selenium.webdriver.chrome.options.Options object at 0x0000015C7BA31B50&gt;, service_args = None<br/>desired_capabilities = {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}<br/>service_log_path = &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a3\\driver.log&#x27;<br/>service = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BA316D0&gt;, keep_alive = True<br/><br/>    def __init__(self, browser_name, vendor_prefix,<br/>                 port=DEFAULT_PORT, options: BaseOptions = None, service_args=None,<br/>                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,<br/>                 service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):<br/>        &quot;&quot;&quot;<br/>        Creates a new WebDriver instance of the ChromiumDriver.<br/>        Starts the service and then creates new WebDriver instance of ChromiumDriver.<br/>    <br/>        :Args:<br/>         - browser_name - Browser name used when matching capabilities.<br/>         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.<br/>         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.<br/>         - options - this takes an instance of ChromiumOptions<br/>         - service_args - Deprecated: List of args to pass to the driver service<br/>         - desired_capabilities - Deprecated: Dictionary object with non-browser specific<br/>           capabilities only, such as &quot;proxy&quot; or &quot;loggingPref&quot;.<br/>         - service_log_path - Deprecated: Where to log information from the driver.<br/>         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.<br/>        &quot;&quot;&quot;<br/>        if desired_capabilities:<br/>            warnings.warn(&#x27;desired_capabilities has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if port != DEFAULT_PORT:<br/>            warnings.warn(&#x27;port has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        self.port = port<br/>        if service_log_path != DEFAULT_SERVICE_LOG_PATH:<br/>            warnings.warn(&#x27;service_log_path has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:<br/>            warnings.warn(&#x27;keep_alive has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        else:<br/>            keep_alive = True<br/>    <br/>        self.vendor_prefix = vendor_prefix<br/>    <br/>        _ignore_proxy = None<br/>        if not options:<br/>            options = self.create_options()<br/>    <br/>        if desired_capabilities:<br/>            for key, value in desired_capabilities.items():<br/>                options.set_capability(key, value)<br/>    <br/>        if options._ignore_local_proxy:<br/>            _ignore_proxy = options._ignore_local_proxy<br/>    <br/>        if not service:<br/>            raise AttributeError(&#x27;service cannot be None&#x27;)<br/>    <br/>        self.service = service<br/>&gt;       self.service.start()<br/><br/>venv\lib\site-packages\selenium\webdriver\chromium\webdriver.py:90: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BA316D0&gt;<br/><br/>    def start(self):<br/>        &quot;&quot;&quot;<br/>        Starts the Service.<br/>    <br/>        :Exceptions:<br/>         - WebDriverException : Raised either when it can&#x27;t start the service<br/>           or when it can&#x27;t connect to the service<br/>        &quot;&quot;&quot;<br/>        try:<br/>            cmd = [self.path]<br/>            cmd.extend(self.command_line_args())<br/>            self.process = subprocess.Popen(cmd, env=self.env,<br/>                                            close_fds=system() != &#x27;Windows&#x27;,<br/>                                            stdout=self.log_file,<br/>                                            stderr=self.log_file,<br/>                                            stdin=PIPE,<br/>                                            creationflags=self.creationflags)<br/>        except TypeError:<br/>            raise<br/>        except OSError as err:<br/>            if err.errno == errno.ENOENT:<br/>&gt;               raise WebDriverException(<br/>                    &quot;&#x27;%s&#x27; executable needs to be in PATH. %s&quot; % (<br/>                        os.path.basename(self.path), self.start_error_message)<br/><span class="error">E                       selenium.common.exceptions.WebDriverException: Message: &#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.chromium.org/home</span><br/><br/>venv\lib\site-packages\selenium\webdriver\common\service.py:81: WebDriverException<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;_HookCaller &#x27;pytest_bdd_step_error&#x27;&gt;<br/>kwargs = {&#x27;exception&#x27;: WebDriverException(&quot;&#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.c...=&#x27;Then&#x27;, failed=None, scenario=None, background=None, lines=[])], tags={&#x27;TR-C393228&#x27;, &#x27;automated&#x27;, &#x27;regression&#x27;}), ...}<br/>firstresult = False<br/><br/>    def __call__(self, **kwargs: object) -&gt; Any:<br/>        assert (<br/>            not self.is_historic()<br/>        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;<br/>        self._verify_all_args_are_provided(kwargs)<br/>        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False<br/>&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_hooks.py:433: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv\lib\site-packages\pluggy\_manager.py:112: in _hookexec<br/>    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)<br/>venv\lib\site-packages\enhanced_reports\core.py:493: in pytest_bdd_step_error<br/>    __capture_js_logs(current_state, driver, op_name)<br/>venv\lib\site-packages\enhanced_reports\core.py:234: in __capture_js_logs<br/>    logs = browser_console_manager.get_js_logs(driver)<br/>venv\lib\site-packages\enhanced_reports\browser_console_manager.py:13: in get_js_logs<br/>    logs = _capture_output(driver)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>driver = None<br/><br/>    def _capture_output(driver: WebDriver):<br/>&gt;       return driver.get_log(&quot;browser&quot;)<br/><span class="error">E       AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;get_log&#x27;</span><br/><br/>venv\lib\site-packages\enhanced_reports\browser_console_manager.py:18: AttributeError<br/> -----------------------------Captured stderr setup------------------------------ <br/>2023-06-22 05:35:30 [info     ] current param_value False
<br/> -------------------------------Captured log setup------------------------------- <br/>2023-06-22 11:05:30 INFO current param_value False<br/> ------------------------------Captured stderr call------------------------------ <br/>

2023-06-22 05:35:30 [info     ] Scenario Execution Started.    feature=Galaxy automated regression - button and anchor components scenario_name=Verify PPC - Buttons and Anchor - Loading Button
2023-06-22 05:35:30 [info     ] Capabilities from markers: {}
2023-06-22 05:35:30 [info     ] Driver init, attempt 1/3
2023-06-22 05:35:31 [info     ] Driver init, attempt 2/3
2023-06-22 05:35:33 [info     ] Driver init, attempt 3/3
2023-06-22 05:35:33 [error    ] Step FAILED.                   step=I am on the page &#x27;/&#x27;
Traceback (most recent call last):
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\common\service.py&quot;, line 71, in start
    self.process = subprocess.Popen(cmd, env=self.env,
  File &quot;C:\Program Files\Python39\lib\subprocess.py&quot;, line 951, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File &quot;C:\Program Files\Python39\lib\subprocess.py&quot;, line 1420, in _execute_child
    hp, ht, pid, tid = _winapi.CreateProcess(executable, args,
FileNotFoundError: [WinError 2] The system cannot find the file specified

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_bdd\scenario.py&quot;, line 154, in _execute_step_function
    kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_bdd\scenario.py&quot;, line 154, in &lt;dictcomp&gt;
    kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 581, in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1072, in execute
    result = hook.pytest_fixture_setup(fixturedef=self, request=request)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_hooks.py&quot;, line 433, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_manager.py&quot;, line 112, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_callers.py&quot;, line 155, in _multicall
    return outcome.get_result()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_result.py&quot;, line 108, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_callers.py&quot;, line 80, in _multicall
    res = hook_impl.function(*args)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1126, in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 925, in call_fixture_func
    fixture_result = next(generator)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_selenium\pytest_selenium.py&quot;, line 201, in driver
    for retry in Retrying(
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 394, in __iter__
    do = self.iter(retry_state=retry_state)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 372, in iter
    raise retry_exc.reraise()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 189, in reraise
    raise self.last_attempt.result()
  File &quot;C:\Program Files\Python39\lib\concurrent\futures\_base.py&quot;, line 439, in result
    return self.__get_result()
  File &quot;C:\Program Files\Python39\lib\concurrent\futures\_base.py&quot;, line 391, in __get_result
    raise self._exception
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_selenium\pytest_selenium.py&quot;, line 208, in driver
    driver = driver_class(**driver_kwargs)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\chrome\webdriver.py&quot;, line 70, in __init__
    super(WebDriver, self).__init__(DesiredCapabilities.CHROME[&#x27;browserName&#x27;], &quot;goog&quot;,
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\chromium\webdriver.py&quot;, line 90, in __init__
    self.service.start()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\common\service.py&quot;, line 81, in start
    raise WebDriverException(
selenium.common.exceptions.WebDriverException: Message: &#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.chromium.org/home

2023-06-22 05:35:33 [info     ] current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 05:35:33 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
2023-06-22 05:35:33 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
2023-06-22 05:35:33 [info     ] Scenario Execution Completed.  feature=Galaxy automated regression - button and anchor components scenario_name=Verify PPC - Buttons and Anchor - Loading Button
2023-06-22 05:35:33 [info     ] current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 05:35:33 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-section">Galaxy automated regression -&gt; button and anchor components</td>
          <td class="col-tags">TR-C393228</td>
          <td class="col-name">Verify PPC - Buttons and Anchor - Loading Button  locator: helixComponent &gt; loading_button, attribute: padding-top, value: 12px</td>
          <td class="col-result">Failed</td>
          <td class="col-duration">00:03.04</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="6">
            <div class="log">self = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BA22C70&gt;<br/><br/>    def start(self):<br/>        &quot;&quot;&quot;<br/>        Starts the Service.<br/>    <br/>        :Exceptions:<br/>         - WebDriverException : Raised either when it can&#x27;t start the service<br/>           or when it can&#x27;t connect to the service<br/>        &quot;&quot;&quot;<br/>        try:<br/>            cmd = [self.path]<br/>            cmd.extend(self.command_line_args())<br/>&gt;           self.process = subprocess.Popen(cmd, env=self.env,<br/>                                            close_fds=system() != &#x27;Windows&#x27;,<br/>                                            stdout=self.log_file,<br/>                                            stderr=self.log_file,<br/>                                            stdin=PIPE,<br/>                                            creationflags=self.creationflags)<br/><br/>venv\lib\site-packages\selenium\webdriver\common\service.py:71: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Popen: returncode: None args: [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--...&gt;<br/>args = [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--port=52309&#x27;, &#x27;--log-path=C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a4\\driver.log&#x27;]<br/>bufsize = -1, executable = None, stdin = -1, stdout = -3, stderr = -3, preexec_fn = None, close_fds = False, shell = False, cwd = None<br/>env = environ({&#x27;__INTELLIJ_COMMAND_HISTFILE__&#x27;: &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\terminal\\...eps.py::test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px] (call)&#x27;})<br/>universal_newlines = None, startupinfo = None, creationflags = 0, restore_signals = True, start_new_session = False, pass_fds = ()<br/><br/>    def __init__(self, args, bufsize=-1, executable=None,<br/>                 stdin=None, stdout=None, stderr=None,<br/>                 preexec_fn=None, close_fds=True,<br/>                 shell=False, cwd=None, env=None, universal_newlines=None,<br/>                 startupinfo=None, creationflags=0,<br/>                 restore_signals=True, start_new_session=False,<br/>                 pass_fds=(), *, user=None, group=None, extra_groups=None,<br/>                 encoding=None, errors=None, text=None, umask=-1):<br/>        &quot;&quot;&quot;Create new Popen instance.&quot;&quot;&quot;<br/>        _cleanup()<br/>        # Held while anything is calling waitpid before returncode has been<br/>        # updated to prevent clobbering returncode if wait() or poll() are<br/>        # called from multiple threads at once.  After acquiring the lock,<br/>        # code must re-check self.returncode to see if another thread just<br/>        # finished a waitpid() call.<br/>        self._waitpid_lock = threading.Lock()<br/>    <br/>        self._input = None<br/>        self._communication_started = False<br/>        if bufsize is None:<br/>            bufsize = -1  # Restore default<br/>        if not isinstance(bufsize, int):<br/>            raise TypeError(&quot;bufsize must be an integer&quot;)<br/>    <br/>        if _mswindows:<br/>            if preexec_fn is not None:<br/>                raise ValueError(&quot;preexec_fn is not supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>        else:<br/>            # POSIX<br/>            if pass_fds and not close_fds:<br/>                warnings.warn(&quot;pass_fds overriding close_fds.&quot;, RuntimeWarning)<br/>                close_fds = True<br/>            if startupinfo is not None:<br/>                raise ValueError(&quot;startupinfo is only supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>            if creationflags != 0:<br/>                raise ValueError(&quot;creationflags is only supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>    <br/>        self.args = args<br/>        self.stdin = None<br/>        self.stdout = None<br/>        self.stderr = None<br/>        self.pid = None<br/>        self.returncode = None<br/>        self.encoding = encoding<br/>        self.errors = errors<br/>    <br/>        # Validate the combinations of text and universal_newlines<br/>        if (text is not None and universal_newlines is not None<br/>            and bool(universal_newlines) != bool(text)):<br/>            raise SubprocessError(&#x27;Cannot disambiguate when both text &#x27;<br/>                                  &#x27;and universal_newlines are supplied but &#x27;<br/>                                  &#x27;different. Pass one or the other.&#x27;)<br/>    <br/>        # Input and output objects. The general principle is like<br/>        # this:<br/>        #<br/>        # Parent                   Child<br/>        # ------                   -----<br/>        # p2cwrite   ---stdin---&gt;  p2cread<br/>        # c2pread    &lt;--stdout---  c2pwrite<br/>        # errread    &lt;--stderr---  errwrite<br/>        #<br/>        # On POSIX, the child objects are file descriptors.  On<br/>        # Windows, these are Windows file handles.  The parent objects<br/>        # are file descriptors on both platforms.  The parent objects<br/>        # are -1 when not using PIPEs. The child objects are -1<br/>        # when not redirecting.<br/>    <br/>        (p2cread, p2cwrite,<br/>         c2pread, c2pwrite,<br/>         errread, errwrite) = self._get_handles(stdin, stdout, stderr)<br/>    <br/>        # We wrap OS handles *before* launching the child, otherwise a<br/>        # quickly terminating child could make our fds unwrappable<br/>        # (see #8458).<br/>    <br/>        if _mswindows:<br/>            if p2cwrite != -1:<br/>                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)<br/>            if c2pread != -1:<br/>                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)<br/>            if errread != -1:<br/>                errread = msvcrt.open_osfhandle(errread.Detach(), 0)<br/>    <br/>        self.text_mode = encoding or errors or text or universal_newlines<br/>    <br/>        # How long to resume waiting on a child after the first ^C.<br/>        # There is no right value for this.  The purpose is to be polite<br/>        # yet remain good for interactive users trying to exit a tool.<br/>        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()<br/>    <br/>        self._closed_child_pipe_fds = False<br/>    <br/>        if self.text_mode:<br/>            if bufsize == 1:<br/>                line_buffering = True<br/>                # Use the default buffer size for the underlying binary streams<br/>                # since they don&#x27;t support line buffering.<br/>                bufsize = -1<br/>            else:<br/>                line_buffering = False<br/>    <br/>        gid = None<br/>        if group is not None:<br/>            if not hasattr(os, &#x27;setregid&#x27;):<br/>                raise ValueError(&quot;The &#x27;group&#x27; parameter is not supported on the &quot;<br/>                                 &quot;current platform&quot;)<br/>    <br/>            elif isinstance(group, str):<br/>                if grp is None:<br/>                    raise ValueError(&quot;The group parameter cannot be a string &quot;<br/>                                     &quot;on systems without the grp module&quot;)<br/>    <br/>                gid = grp.getgrnam(group).gr_gid<br/>            elif isinstance(group, int):<br/>                gid = group<br/>            else:<br/>                raise TypeError(&quot;Group must be a string or an integer, not {}&quot;<br/>                                .format(type(group)))<br/>    <br/>            if gid &lt; 0:<br/>                raise ValueError(f&quot;Group ID cannot be negative, got {gid}&quot;)<br/>    <br/>        gids = None<br/>        if extra_groups is not None:<br/>            if not hasattr(os, &#x27;setgroups&#x27;):<br/>                raise ValueError(&quot;The &#x27;extra_groups&#x27; parameter is not &quot;<br/>                                 &quot;supported on the current platform&quot;)<br/>    <br/>            elif isinstance(extra_groups, str):<br/>                raise ValueError(&quot;Groups must be a list, not a string&quot;)<br/>    <br/>            gids = []<br/>            for extra_group in extra_groups:<br/>                if isinstance(extra_group, str):<br/>                    if grp is None:<br/>                        raise ValueError(&quot;Items in extra_groups cannot be &quot;<br/>                                         &quot;strings on systems without the &quot;<br/>                                         &quot;grp module&quot;)<br/>    <br/>                    gids.append(grp.getgrnam(extra_group).gr_gid)<br/>                elif isinstance(extra_group, int):<br/>                    gids.append(extra_group)<br/>                else:<br/>                    raise TypeError(&quot;Items in extra_groups must be a string &quot;<br/>                                    &quot;or integer, not {}&quot;<br/>                                    .format(type(extra_group)))<br/>    <br/>            # make sure that the gids are all positive here so we can do less<br/>            # checking in the C code<br/>            for gid_check in gids:<br/>                if gid_check &lt; 0:<br/>                    raise ValueError(f&quot;Group ID cannot be negative, got {gid_check}&quot;)<br/>    <br/>        uid = None<br/>        if user is not None:<br/>            if not hasattr(os, &#x27;setreuid&#x27;):<br/>                raise ValueError(&quot;The &#x27;user&#x27; parameter is not supported on &quot;<br/>                                 &quot;the current platform&quot;)<br/>    <br/>            elif isinstance(user, str):<br/>                if pwd is None:<br/>                    raise ValueError(&quot;The user parameter cannot be a string &quot;<br/>                                     &quot;on systems without the pwd module&quot;)<br/>    <br/>                uid = pwd.getpwnam(user).pw_uid<br/>            elif isinstance(user, int):<br/>                uid = user<br/>            else:<br/>                raise TypeError(&quot;User must be a string or an integer&quot;)<br/>    <br/>            if uid &lt; 0:<br/>                raise ValueError(f&quot;User ID cannot be negative, got {uid}&quot;)<br/>    <br/>        try:<br/>            if p2cwrite != -1:<br/>                self.stdin = io.open(p2cwrite, &#x27;wb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,<br/>                            line_buffering=line_buffering,<br/>                            encoding=encoding, errors=errors)<br/>            if c2pread != -1:<br/>                self.stdout = io.open(c2pread, &#x27;rb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stdout = io.TextIOWrapper(self.stdout,<br/>                            encoding=encoding, errors=errors)<br/>            if errread != -1:<br/>                self.stderr = io.open(errread, &#x27;rb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stderr = io.TextIOWrapper(self.stderr,<br/>                            encoding=encoding, errors=errors)<br/>    <br/>&gt;           self._execute_child(args, executable, preexec_fn, close_fds,<br/>                                pass_fds, cwd, env,<br/>                                startupinfo, creationflags, shell,<br/>                                p2cread, p2cwrite,<br/>                                c2pread, c2pwrite,<br/>                                errread, errwrite,<br/>                                restore_signals,<br/>                                gid, gids, uid, umask,<br/>                                start_new_session)<br/><br/>C:\Program Files\Python39\lib\subprocess.py:951: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Popen: returncode: None args: [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--...&gt;<br/>args = &#x27;./binaries/webdriver/chromedriver.exe --port=52309 --log-path=C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a4\\driver.log&#x27;<br/>executable = None, preexec_fn = None, close_fds = False, pass_fds = (), cwd = None<br/>env = environ({&#x27;__INTELLIJ_COMMAND_HISTFILE__&#x27;: &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\terminal\\...eps.py::test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px] (call)&#x27;})<br/>startupinfo = &lt;subprocess.STARTUPINFO object at 0x0000015C7BA22700&gt;, creationflags = 0, shell = False, p2cread = Handle(1368), p2cwrite = 16, c2pread = -1<br/>c2pwrite = Handle(1612), errread = -1, errwrite = Handle(1628), unused_restore_signals = True, unused_gid = None, unused_gids = None, unused_uid = None<br/>unused_umask = -1, unused_start_new_session = False<br/><br/>    def _execute_child(self, args, executable, preexec_fn, close_fds,<br/>                       pass_fds, cwd, env,<br/>                       startupinfo, creationflags, shell,<br/>                       p2cread, p2cwrite,<br/>                       c2pread, c2pwrite,<br/>                       errread, errwrite,<br/>                       unused_restore_signals,<br/>                       unused_gid, unused_gids, unused_uid,<br/>                       unused_umask,<br/>                       unused_start_new_session):<br/>        &quot;&quot;&quot;Execute program (MS Windows version)&quot;&quot;&quot;<br/>    <br/>        assert not pass_fds, &quot;pass_fds not supported on Windows.&quot;<br/>    <br/>        if isinstance(args, str):<br/>            pass<br/>        elif isinstance(args, bytes):<br/>            if shell:<br/>                raise TypeError(&#x27;bytes args is not allowed on Windows&#x27;)<br/>            args = list2cmdline([args])<br/>        elif isinstance(args, os.PathLike):<br/>            if shell:<br/>                raise TypeError(&#x27;path-like args is not allowed when &#x27;<br/>                                &#x27;shell is true&#x27;)<br/>            args = list2cmdline([args])<br/>        else:<br/>            args = list2cmdline(args)<br/>    <br/>        if executable is not None:<br/>            executable = os.fsdecode(executable)<br/>    <br/>        # Process startup details<br/>        if startupinfo is None:<br/>            startupinfo = STARTUPINFO()<br/>        else:<br/>            # bpo-34044: Copy STARTUPINFO since it is modified above,<br/>            # so the caller can reuse it multiple times.<br/>            startupinfo = startupinfo.copy()<br/>    <br/>        use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)<br/>        if use_std_handles:<br/>            startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES<br/>            startupinfo.hStdInput = p2cread<br/>            startupinfo.hStdOutput = c2pwrite<br/>            startupinfo.hStdError = errwrite<br/>    <br/>        attribute_list = startupinfo.lpAttributeList<br/>        have_handle_list = bool(attribute_list and<br/>                                &quot;handle_list&quot; in attribute_list and<br/>                                attribute_list[&quot;handle_list&quot;])<br/>    <br/>        # If we were given an handle_list or need to create one<br/>        if have_handle_list or (use_std_handles and close_fds):<br/>            if attribute_list is None:<br/>                attribute_list = startupinfo.lpAttributeList = {}<br/>            handle_list = attribute_list[&quot;handle_list&quot;] = \<br/>                list(attribute_list.get(&quot;handle_list&quot;, []))<br/>    <br/>            if use_std_handles:<br/>                handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]<br/>    <br/>            handle_list[:] = self._filter_handle_list(handle_list)<br/>    <br/>            if handle_list:<br/>                if not close_fds:<br/>                    warnings.warn(&quot;startupinfo.lpAttributeList[&#x27;handle_list&#x27;] &quot;<br/>                                  &quot;overriding close_fds&quot;, RuntimeWarning)<br/>    <br/>                # When using the handle_list we always request to inherit<br/>                # handles but the only handles that will be inherited are<br/>                # the ones in the handle_list<br/>                close_fds = False<br/>    <br/>        if shell:<br/>            startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW<br/>            startupinfo.wShowWindow = _winapi.SW_HIDE<br/>            comspec = os.environ.get(&quot;COMSPEC&quot;, &quot;cmd.exe&quot;)<br/>            args = &#x27;{} /c &quot;{}&quot;&#x27;.format (comspec, args)<br/>    <br/>        if cwd is not None:<br/>            cwd = os.fsdecode(cwd)<br/>    <br/>        sys.audit(&quot;subprocess.Popen&quot;, executable, args, cwd, env)<br/>    <br/>        # Start the process<br/>        try:<br/>&gt;           hp, ht, pid, tid = _winapi.CreateProcess(executable, args,<br/>                                     # no special security<br/>                                     None, None,<br/>                                     int(not close_fds),<br/>                                     creationflags,<br/>                                     env,<br/>                                     cwd,<br/>                                     startupinfo)<br/><span class="error">E                                    FileNotFoundError: [WinError 2] The system cannot find the file specified</span><br/><br/>C:\Program Files\Python39\lib\subprocess.py:1420: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>request = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/>scenario = Scenario(feature=Feature(scenarios=OrderedDict([(&#x27;Verify PPC - Buttons and Anchor - Loading Button&#x27;, ScenarioTemplate(...eyword=&#x27;Then&#x27;, failed=None, scenario=None, background=None, lines=[])], tags={&#x27;TR-C393228&#x27;, &#x27;automated&#x27;, &#x27;regression&#x27;})<br/>step = Step(type=&#x27;given&#x27;, _name=&quot;I am on the page &#x27;/&#x27;&quot;, line_number=5, indent=8, keyword=&#x27;Given&#x27;, failed=True, scenario=None,...closeIcon&#x27;&quot;, line_number=8, indent=8, keyword=&#x27;And&#x27;, failed=None, scenario=None, background=..., lines=[])]), lines=[])<br/>context = StepFunctionContext(type=&#x27;given&#x27;, step_func=&lt;function open_webpage at 0x0000015C7A412820&gt;, parser=&lt;pytest_bdd.parsers....t at 0x0000015C7A40F7C0&gt;, converters={&#x27;page_url&#x27;: &lt;function env_formatted at 0x0000015C78B20700&gt;}, target_fixture=None)<br/><br/>    def _execute_step_function(<br/>        request: FixtureRequest, scenario: Scenario, step: Step, context: StepFunctionContext<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;Execute step function.&quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        kw = {<br/>            &quot;request&quot;: request,<br/>            &quot;feature&quot;: scenario.feature,<br/>            &quot;scenario&quot;: scenario,<br/>            &quot;step&quot;: step,<br/>            &quot;step_func&quot;: context.step_func,<br/>            &quot;step_func_args&quot;: {},<br/>        }<br/>    <br/>        request.config.hook.pytest_bdd_before_step(**kw)<br/>    <br/>        # Get the step argument values.<br/>        converters = context.converters<br/>        kwargs = {}<br/>        args = get_args(context.step_func)<br/>    <br/>        try:<br/>            parsed_args = context.parser.parse_arguments(step.name)<br/>            assert parsed_args is not None, (<br/>                f&quot;Unexpected `NoneType` returned from &quot; f&quot;parse_arguments(...) in parser: {context.parser!r}&quot;<br/>            )<br/>            for arg, value in parsed_args.items():<br/>                if arg in converters:<br/>                    value = converters[arg](value)<br/>                kwargs[arg] = value<br/>    <br/>&gt;           kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}<br/><br/>venv\lib\site-packages\pytest_bdd\scenario.py:154: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>.0 = &lt;list_iterator object at 0x0000015C7B8FA3A0&gt;<br/><br/>&gt;   kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}<br/><br/>venv\lib\site-packages\pytest_bdd\scenario.py:154: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/>argname = &#x27;selenium_generics&#x27;<br/><br/>    def getfixturevalue(self, argname: str) -&gt; Any:<br/>        &quot;&quot;&quot;Dynamically run a named fixture function.<br/>    <br/>        Declaring fixtures via function argument is recommended where possible.<br/>        But if you can only decide whether to use another fixture at test<br/>        setup time, you may use this function to retrieve it inside a fixture<br/>        or test function body.<br/>    <br/>        :raises pytest.FixtureLookupError:<br/>            If the given fixture could not be found.<br/>        &quot;&quot;&quot;<br/>&gt;       fixturedef = self._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:581: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/>argname = &#x27;selenium_generics&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium_generics&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium_generics&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/>argname = &#x27;selenium&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/>argname = &#x27;selenium&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/>argname = &#x27;driver&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>            fixturedef = request._get_active_fixturedef(argname)<br/>            if argname != &quot;request&quot;:<br/>                # PseudoFixtureDef is only for &quot;request&quot;.<br/>                assert isinstance(fixturedef, FixtureDef)<br/>                fixturedef.addfinalizer(functools.partial(self.finish, request=request))<br/>    <br/>        my_cache_key = self.cache_key(request)<br/>        if self.cached_result is not None:<br/>            # note: comparison with `==` can fail (or be expensive) for e.g.<br/>            # numpy arrays (#6497).<br/>            cache_key = self.cached_result[1]<br/>            if my_cache_key is cache_key:<br/>                if self.cached_result[2] is not None:<br/>                    _, val, tb = self.cached_result[2]<br/>                    raise val.with_traceback(tb)<br/>                else:<br/>                    result = self.cached_result[0]<br/>                    return result<br/>            # We have a previous but differently parametrized fixture instance<br/>            # so we need to tear it down before creating a new one.<br/>            self.finish(request)<br/>            assert self.cached_result is None<br/>    <br/>        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)<br/>&gt;       result = hook.pytest_fixture_setup(fixturedef=self, request=request)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1072: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_HookCaller &#x27;pytest_fixture_setup&#x27;&gt;<br/>kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def __call__(self, **kwargs: object) -&gt; Any:<br/>        assert (<br/>            not self.is_historic()<br/>        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;<br/>        self._verify_all_args_are_provided(kwargs)<br/>        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False<br/>&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_hooks.py:433: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_pytest.config.PytestPluginManager object at 0x0000015C7034A250&gt;, hook_name = &#x27;pytest_fixture_setup&#x27;<br/>methods = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _hookexec(<br/>        self,<br/>        hook_name: str,<br/>        methods: Sequence[HookImpl],<br/>        kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        # called from all hookcaller instances.<br/>        # enable_tracing will set its own wrapping function at self._inner_hookexec<br/>&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_manager.py:112: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_name = &#x27;pytest_fixture_setup&#x27;<br/>hook_impls = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>caller_kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _multicall(<br/>        hook_name: str,<br/>        hook_impls: Sequence[HookImpl],<br/>        caller_kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        results: list[object] = []<br/>        exception = None<br/>        only_new_style_wrappers = True<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns: list[Teardown] = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    f&quot;hook call must provide argument {argname!r}&quot;<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        only_new_style_wrappers = False<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            wrapper_gen = cast(Generator[None, _Result[object], None], res)<br/>                            next(wrapper_gen)  # first yield<br/>                            teardowns.append((wrapper_gen,))<br/>                        except StopIteration:<br/>                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)<br/>                    elif hook_impl.wrapper:<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            function_gen = cast(Generator[None, object, object], res)<br/>                            next(function_gen)  # first yield<br/>                            teardowns.append(function_gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)<br/>                    else:<br/>                        res = hook_impl.function(*args)<br/>                        if res is not None:<br/>                            results.append(res)<br/>                            if firstresult:  # halt further impl calls<br/>                                break<br/>            except BaseException as exc:<br/>                exception = exc<br/>        finally:<br/>            # Fast path - only new-style wrappers, no _Result.<br/>            if only_new_style_wrappers:<br/>                if firstresult:  # first result hooks return a single value<br/>                    result = results[0] if results else None<br/>                else:<br/>                    result = results<br/>    <br/>                # run all wrapper post-yield blocks<br/>                for teardown in reversed(teardowns):<br/>                    try:<br/>                        if exception is not None:<br/>                            teardown.throw(exception)  # type: ignore[union-attr]<br/>                        else:<br/>                            teardown.send(result)  # type: ignore[union-attr]<br/>                        # Following is unreachable for a well behaved hook wrapper.<br/>                        # Try to force finalizers otherwise postponed till GC action.<br/>                        # Note: close() may raise if generator handles GeneratorExit.<br/>                        teardown.close()  # type: ignore[union-attr]<br/>                    except StopIteration as si:<br/>                        result = si.value<br/>                        exception = None<br/>                        continue<br/>                    except BaseException as e:<br/>                        exception = e<br/>                        continue<br/>                    _raise_wrapfail(teardown, &quot;has second yield&quot;)  # type: ignore[arg-type]<br/>    <br/>                if exception is not None:<br/>                    raise exception.with_traceback(exception.__traceback__)<br/>                else:<br/>                    return result<br/>    <br/>            # Slow path - need to support old-style wrappers.<br/>            else:<br/>                if firstresult:  # first result hooks return a single value<br/>                    outcome: _Result[object | list[object]] = _Result(<br/>                        results[0] if results else None, exception<br/>                    )<br/>                else:<br/>                    outcome = _Result(results, exception)<br/>    <br/>                # run all wrapper post-yield blocks<br/>                for teardown in reversed(teardowns):<br/>                    if isinstance(teardown, tuple):<br/>                        try:<br/>                            teardown[0].send(outcome)<br/>                            _raise_wrapfail(teardown[0], &quot;has second yield&quot;)<br/>                        except StopIteration:<br/>                            pass<br/>                    else:<br/>                        try:<br/>                            if outcome._exception is not None:<br/>                                teardown.throw(outcome._exception)<br/>                            else:<br/>                                teardown.send(outcome._result)<br/>                            # Following is unreachable for a well behaved hook wrapper.<br/>                            # Try to force finalizers otherwise postponed till GC action.<br/>                            # Note: close() may raise if generator handles GeneratorExit.<br/>                            teardown.close()<br/>                        except StopIteration as si:<br/>                            outcome.force_result(si.value)<br/>                            continue<br/>                        except BaseException as e:<br/>                            outcome.force_exception(e)<br/>                            continue<br/>                        _raise_wrapfail(teardown, &quot;has second yield&quot;)<br/>    <br/>&gt;               return outcome.get_result()<br/><br/>venv\lib\site-packages\pluggy\_callers.py:155: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;pluggy._result._Result object at 0x0000015C7BA22670&gt;<br/><br/>    def get_result(self) -&gt; _T:<br/>        &quot;&quot;&quot;Get the result(s) for this hook call.<br/>    <br/>        If the hook was marked as a ``firstresult`` only a single value<br/>        will be returned, otherwise a list of results.<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        exc = self._exception<br/>        if exc is None:<br/>            return cast(_T, self._result)<br/>        else:<br/>&gt;           raise exc.with_traceback(exc.__traceback__)<br/><br/>venv\lib\site-packages\pluggy\_result.py:108: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_name = &#x27;pytest_fixture_setup&#x27;<br/>hook_impls = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>caller_kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _multicall(<br/>        hook_name: str,<br/>        hook_impls: Sequence[HookImpl],<br/>        caller_kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        results: list[object] = []<br/>        exception = None<br/>        only_new_style_wrappers = True<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns: list[Teardown] = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    f&quot;hook call must provide argument {argname!r}&quot;<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        only_new_style_wrappers = False<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            wrapper_gen = cast(Generator[None, _Result[object], None], res)<br/>                            next(wrapper_gen)  # first yield<br/>                            teardowns.append((wrapper_gen,))<br/>                        except StopIteration:<br/>                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)<br/>                    elif hook_impl.wrapper:<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            function_gen = cast(Generator[None, object, object], res)<br/>                            next(function_gen)  # first yield<br/>                            teardowns.append(function_gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)<br/>                    else:<br/>&gt;                       res = hook_impl.function(*args)<br/><br/>venv\lib\site-packages\pluggy\_callers.py:80: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fixturedef = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/><br/>    def pytest_fixture_setup(<br/>        fixturedef: FixtureDef[_FixtureValue], request: SubRequest<br/>    ) -&gt; _FixtureValue:<br/>        &quot;&quot;&quot;Execution of fixture setup.&quot;&quot;&quot;<br/>        kwargs = {}<br/>        for argname in fixturedef.argnames:<br/>            fixdef = request._get_active_fixturedef(argname)<br/>            assert fixdef.cached_result is not None<br/>            result, arg_cache_key, exc = fixdef.cached_result<br/>            request._check_scope(argname, request.scope, fixdef.scope)<br/>            kwargs[argname] = result<br/>    <br/>        fixturefunc = resolve_fixture_function(fixturedef, request)<br/>        my_cache_key = fixturedef.cache_key(request)<br/>        try:<br/>&gt;           result = call_fixture_func(fixturefunc, request, kwargs)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1126: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fixturefunc = &lt;function driver at 0x0000015C787C44C0&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/>kwargs = {&#x27;driver_class&#x27;: &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;, &#x27;driver_kwargs&#x27;: {&#x27;desired_capabilities&#x27;: {&#x27;... for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;}<br/><br/>    def call_fixture_func(<br/>        fixturefunc: &quot;_FixtureFunc[_FixtureValue]&quot;, request: FixtureRequest, kwargs<br/>    ) -&gt; _FixtureValue:<br/>        if is_generator(fixturefunc):<br/>            fixturefunc = cast(<br/>                Callable[..., Generator[_FixtureValue, None, None]], fixturefunc<br/>            )<br/>            generator = fixturefunc(**kwargs)<br/>            try:<br/>&gt;               fixture_result = next(generator)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:925: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/>driver_class = &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;<br/>driver_kwargs = {&#x27;desired_capabilities&#x27;: {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}, &#x27;executable_path&#x27;: &#x27;....\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a4\\driver.log&#x27;}<br/><br/>    @pytest.fixture<br/>    def driver(request, driver_class, driver_kwargs):<br/>        &quot;&quot;&quot;Returns a WebDriver instance based on options and capabilities&quot;&quot;&quot;<br/>    <br/>        retries = int(request.config.getini(&quot;max_driver_init_attempts&quot;))<br/>&gt;       for retry in Retrying(<br/>            stop=stop_after_attempt(retries), wait=wait_exponential(), reraise=True<br/>        ):<br/><br/>venv\lib\site-packages\pytest_selenium\pytest_selenium.py:201: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Retrying object at 0x15c7ba22dc0 (stop=&lt;tenacity.stop.stop_after_attempt object at 0x0000015C7BA22D90&gt;, wait=&lt;tenacit...631370&gt;, before=&lt;function before_nothing at 0x0000015C7861BB80&gt;, after=&lt;function after_nothing at 0x0000015C7862F700&gt;)&gt;<br/><br/>    def __iter__(self):<br/>        self.begin(None)<br/>    <br/>        retry_state = RetryCallState(self, fn=None, args=(), kwargs={})<br/>        while True:<br/>&gt;           do = self.iter(retry_state=retry_state)<br/><br/>venv\lib\site-packages\tenacity\__init__.py:394: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Retrying object at 0x15c7ba22dc0 (stop=&lt;tenacity.stop.stop_after_attempt object at 0x0000015C7BA22D90&gt;, wait=&lt;tenacit...631370&gt;, before=&lt;function before_nothing at 0x0000015C7861BB80&gt;, after=&lt;function after_nothing at 0x0000015C7862F700&gt;)&gt;<br/>retry_state = &lt;tenacity.RetryCallState object at 0x0000015C7BA22E20&gt;<br/><br/>    def iter(self, retry_state):  # noqa<br/>        fut = retry_state.outcome<br/>        if fut is None:<br/>            if self.before is not None:<br/>                self.before(retry_state)<br/>            return DoAttempt()<br/>    <br/>        is_explicit_retry = retry_state.outcome.failed \<br/>            and isinstance(retry_state.outcome.exception(), TryAgain)<br/>        if not (is_explicit_retry or self.retry(retry_state=retry_state)):<br/>            return fut.result()<br/>    <br/>        if self.after is not None:<br/>            self.after(retry_state=retry_state)<br/>    <br/>        self.statistics[&#x27;delay_since_first_attempt&#x27;] = \<br/>            retry_state.seconds_since_start<br/>        if self.stop(retry_state=retry_state):<br/>            if self.retry_error_callback:<br/>                return self.retry_error_callback(retry_state=retry_state)<br/>            retry_exc = self.retry_error_cls(fut)<br/>            if self.reraise:<br/>&gt;               raise retry_exc.reraise()<br/><br/>venv\lib\site-packages\tenacity\__init__.py:372: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = RetryError(&lt;Future at 0x15c7ba22d30 state=finished raised WebDriverException&gt;)<br/><br/>    def reraise(self):<br/>        if self.last_attempt.failed:<br/>&gt;           raise self.last_attempt.result()<br/><br/>venv\lib\site-packages\tenacity\__init__.py:189: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = None, timeout = None<br/><br/>    def result(self, timeout=None):<br/>        &quot;&quot;&quot;Return the result of the call that the future represents.<br/>    <br/>        Args:<br/>            timeout: The number of seconds to wait for the result if the future<br/>                isn&#x27;t done. If None, then there is no limit on the wait time.<br/>    <br/>        Returns:<br/>            The result of the call that the future represents.<br/>    <br/>        Raises:<br/>            CancelledError: If the future was cancelled.<br/>            TimeoutError: If the future didn&#x27;t finish executing before the given<br/>                timeout.<br/>            Exception: If the call raised then that exception will be raised.<br/>        &quot;&quot;&quot;<br/>        try:<br/>            with self._condition:<br/>                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:<br/>                    raise CancelledError()<br/>                elif self._state == FINISHED:<br/>&gt;                   return self.__get_result()<br/><br/>C:\Program Files\Python39\lib\concurrent\futures\_base.py:439: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = None<br/><br/>    def __get_result(self):<br/>        if self._exception:<br/>            try:<br/>&gt;               raise self._exception<br/><br/>C:\Program Files\Python39\lib\concurrent\futures\_base.py:391: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-top-12px]&gt;&gt;<br/>driver_class = &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;<br/>driver_kwargs = {&#x27;desired_capabilities&#x27;: {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}, &#x27;executable_path&#x27;: &#x27;....\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a4\\driver.log&#x27;}<br/><br/>    @pytest.fixture<br/>    def driver(request, driver_class, driver_kwargs):<br/>        &quot;&quot;&quot;Returns a WebDriver instance based on options and capabilities&quot;&quot;&quot;<br/>    <br/>        retries = int(request.config.getini(&quot;max_driver_init_attempts&quot;))<br/>        for retry in Retrying(<br/>            stop=stop_after_attempt(retries), wait=wait_exponential(), reraise=True<br/>        ):<br/>            with retry:<br/>                LOGGER.info(<br/>                    f&quot;Driver init, attempt {retry.retry_state.attempt_number}/{retries}&quot;<br/>                )<br/>&gt;               driver = driver_class(**driver_kwargs)<br/><br/>venv\lib\site-packages\pytest_selenium\pytest_selenium.py:208: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[AttributeError(&quot;&#x27;WebDriver&#x27; object has no attribute &#x27;session_id&#x27;&quot;) raised in repr()] WebDriver object at 0x15c7ba22d00&gt;<br/>executable_path = &#x27;./binaries/webdriver/chromedriver.exe&#x27;, port = 0, options = &lt;selenium.webdriver.chrome.options.Options object at 0x0000015C7BA22280&gt;<br/>service_args = None, desired_capabilities = {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}<br/>service_log_path = &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a4\\driver.log&#x27;<br/>chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BA22C70&gt;, keep_alive = True<br/><br/>    def __init__(self, executable_path=DEFAULT_EXECUTABLE_PATH, port=DEFAULT_PORT,<br/>                 options: Options = None, service_args=None,<br/>                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,<br/>                 chrome_options=None, service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):<br/>        &quot;&quot;&quot;<br/>        Creates a new instance of the chrome driver.<br/>        Starts the service and then creates new instance of chrome driver.<br/>    <br/>        :Args:<br/>         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH<br/>         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.<br/>         - options - this takes an instance of ChromeOptions<br/>         - service - Service object for handling the browser driver if you need to pass extra details<br/>         - service_args - Deprecated: List of args to pass to the driver service<br/>         - desired_capabilities - Deprecated: Dictionary object with non-browser specific<br/>           capabilities only, such as &quot;proxy&quot; or &quot;loggingPref&quot;.<br/>         - service_log_path - Deprecated: Where to log information from the driver.<br/>         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.<br/>        &quot;&quot;&quot;<br/>        if executable_path != &#x27;chromedriver&#x27;:<br/>            warnings.warn(&#x27;executable_path has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if chrome_options:<br/>            warnings.warn(&#x27;use options instead of chrome_options&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>            options = chrome_options<br/>        if keep_alive != DEFAULT_KEEP_ALIVE:<br/>            warnings.warn(&#x27;keep_alive has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        else:<br/>            keep_alive = True<br/>        if not service:<br/>            service = Service(executable_path, port, service_args, service_log_path)<br/>    <br/>&gt;       super(WebDriver, self).__init__(DesiredCapabilities.CHROME[&#x27;browserName&#x27;], &quot;goog&quot;,<br/>                                        port, options,<br/>                                        service_args, desired_capabilities,<br/>                                        service_log_path, service, keep_alive)<br/><br/>venv\lib\site-packages\selenium\webdriver\chrome\webdriver.py:70: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[AttributeError(&quot;&#x27;WebDriver&#x27; object has no attribute &#x27;session_id&#x27;&quot;) raised in repr()] WebDriver object at 0x15c7ba22d00&gt;, browser_name = &#x27;chrome&#x27;<br/>vendor_prefix = &#x27;goog&#x27;, port = 0, options = &lt;selenium.webdriver.chrome.options.Options object at 0x0000015C7BA22280&gt;, service_args = None<br/>desired_capabilities = {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}<br/>service_log_path = &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a4\\driver.log&#x27;<br/>service = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BA22C70&gt;, keep_alive = True<br/><br/>    def __init__(self, browser_name, vendor_prefix,<br/>                 port=DEFAULT_PORT, options: BaseOptions = None, service_args=None,<br/>                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,<br/>                 service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):<br/>        &quot;&quot;&quot;<br/>        Creates a new WebDriver instance of the ChromiumDriver.<br/>        Starts the service and then creates new WebDriver instance of ChromiumDriver.<br/>    <br/>        :Args:<br/>         - browser_name - Browser name used when matching capabilities.<br/>         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.<br/>         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.<br/>         - options - this takes an instance of ChromiumOptions<br/>         - service_args - Deprecated: List of args to pass to the driver service<br/>         - desired_capabilities - Deprecated: Dictionary object with non-browser specific<br/>           capabilities only, such as &quot;proxy&quot; or &quot;loggingPref&quot;.<br/>         - service_log_path - Deprecated: Where to log information from the driver.<br/>         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.<br/>        &quot;&quot;&quot;<br/>        if desired_capabilities:<br/>            warnings.warn(&#x27;desired_capabilities has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if port != DEFAULT_PORT:<br/>            warnings.warn(&#x27;port has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        self.port = port<br/>        if service_log_path != DEFAULT_SERVICE_LOG_PATH:<br/>            warnings.warn(&#x27;service_log_path has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:<br/>            warnings.warn(&#x27;keep_alive has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        else:<br/>            keep_alive = True<br/>    <br/>        self.vendor_prefix = vendor_prefix<br/>    <br/>        _ignore_proxy = None<br/>        if not options:<br/>            options = self.create_options()<br/>    <br/>        if desired_capabilities:<br/>            for key, value in desired_capabilities.items():<br/>                options.set_capability(key, value)<br/>    <br/>        if options._ignore_local_proxy:<br/>            _ignore_proxy = options._ignore_local_proxy<br/>    <br/>        if not service:<br/>            raise AttributeError(&#x27;service cannot be None&#x27;)<br/>    <br/>        self.service = service<br/>&gt;       self.service.start()<br/><br/>venv\lib\site-packages\selenium\webdriver\chromium\webdriver.py:90: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BA22C70&gt;<br/><br/>    def start(self):<br/>        &quot;&quot;&quot;<br/>        Starts the Service.<br/>    <br/>        :Exceptions:<br/>         - WebDriverException : Raised either when it can&#x27;t start the service<br/>           or when it can&#x27;t connect to the service<br/>        &quot;&quot;&quot;<br/>        try:<br/>            cmd = [self.path]<br/>            cmd.extend(self.command_line_args())<br/>            self.process = subprocess.Popen(cmd, env=self.env,<br/>                                            close_fds=system() != &#x27;Windows&#x27;,<br/>                                            stdout=self.log_file,<br/>                                            stderr=self.log_file,<br/>                                            stdin=PIPE,<br/>                                            creationflags=self.creationflags)<br/>        except TypeError:<br/>            raise<br/>        except OSError as err:<br/>            if err.errno == errno.ENOENT:<br/>&gt;               raise WebDriverException(<br/>                    &quot;&#x27;%s&#x27; executable needs to be in PATH. %s&quot; % (<br/>                        os.path.basename(self.path), self.start_error_message)<br/><span class="error">E                       selenium.common.exceptions.WebDriverException: Message: &#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.chromium.org/home</span><br/><br/>venv\lib\site-packages\selenium\webdriver\common\service.py:81: WebDriverException<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;_HookCaller &#x27;pytest_bdd_step_error&#x27;&gt;<br/>kwargs = {&#x27;exception&#x27;: WebDriverException(&quot;&#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.c...=&#x27;Then&#x27;, failed=None, scenario=None, background=None, lines=[])], tags={&#x27;TR-C393228&#x27;, &#x27;automated&#x27;, &#x27;regression&#x27;}), ...}<br/>firstresult = False<br/><br/>    def __call__(self, **kwargs: object) -&gt; Any:<br/>        assert (<br/>            not self.is_historic()<br/>        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;<br/>        self._verify_all_args_are_provided(kwargs)<br/>        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False<br/>&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_hooks.py:433: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv\lib\site-packages\pluggy\_manager.py:112: in _hookexec<br/>    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)<br/>venv\lib\site-packages\enhanced_reports\core.py:493: in pytest_bdd_step_error<br/>    __capture_js_logs(current_state, driver, op_name)<br/>venv\lib\site-packages\enhanced_reports\core.py:234: in __capture_js_logs<br/>    logs = browser_console_manager.get_js_logs(driver)<br/>venv\lib\site-packages\enhanced_reports\browser_console_manager.py:13: in get_js_logs<br/>    logs = _capture_output(driver)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>driver = None<br/><br/>    def _capture_output(driver: WebDriver):<br/>&gt;       return driver.get_log(&quot;browser&quot;)<br/><span class="error">E       AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;get_log&#x27;</span><br/><br/>venv\lib\site-packages\enhanced_reports\browser_console_manager.py:18: AttributeError<br/> -----------------------------Captured stderr setup------------------------------ <br/>2023-06-22 05:35:34 [info     ] current param_value False
<br/> -------------------------------Captured log setup------------------------------- <br/>2023-06-22 11:05:34 INFO current param_value False<br/> ------------------------------Captured stderr call------------------------------ <br/>

2023-06-22 05:35:34 [info     ] Scenario Execution Started.    feature=Galaxy automated regression - button and anchor components scenario_name=Verify PPC - Buttons and Anchor - Loading Button
2023-06-22 05:35:34 [info     ] Capabilities from markers: {}
2023-06-22 05:35:34 [info     ] Driver init, attempt 1/3
2023-06-22 05:35:35 [info     ] Driver init, attempt 2/3
2023-06-22 05:35:37 [info     ] Driver init, attempt 3/3
2023-06-22 05:35:37 [error    ] Step FAILED.                   step=I am on the page &#x27;/&#x27;
Traceback (most recent call last):
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\common\service.py&quot;, line 71, in start
    self.process = subprocess.Popen(cmd, env=self.env,
  File &quot;C:\Program Files\Python39\lib\subprocess.py&quot;, line 951, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File &quot;C:\Program Files\Python39\lib\subprocess.py&quot;, line 1420, in _execute_child
    hp, ht, pid, tid = _winapi.CreateProcess(executable, args,
FileNotFoundError: [WinError 2] The system cannot find the file specified

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_bdd\scenario.py&quot;, line 154, in _execute_step_function
    kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_bdd\scenario.py&quot;, line 154, in &lt;dictcomp&gt;
    kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 581, in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1072, in execute
    result = hook.pytest_fixture_setup(fixturedef=self, request=request)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_hooks.py&quot;, line 433, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_manager.py&quot;, line 112, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_callers.py&quot;, line 155, in _multicall
    return outcome.get_result()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_result.py&quot;, line 108, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_callers.py&quot;, line 80, in _multicall
    res = hook_impl.function(*args)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1126, in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 925, in call_fixture_func
    fixture_result = next(generator)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_selenium\pytest_selenium.py&quot;, line 201, in driver
    for retry in Retrying(
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 394, in __iter__
    do = self.iter(retry_state=retry_state)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 372, in iter
    raise retry_exc.reraise()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 189, in reraise
    raise self.last_attempt.result()
  File &quot;C:\Program Files\Python39\lib\concurrent\futures\_base.py&quot;, line 439, in result
    return self.__get_result()
  File &quot;C:\Program Files\Python39\lib\concurrent\futures\_base.py&quot;, line 391, in __get_result
    raise self._exception
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_selenium\pytest_selenium.py&quot;, line 208, in driver
    driver = driver_class(**driver_kwargs)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\chrome\webdriver.py&quot;, line 70, in __init__
    super(WebDriver, self).__init__(DesiredCapabilities.CHROME[&#x27;browserName&#x27;], &quot;goog&quot;,
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\chromium\webdriver.py&quot;, line 90, in __init__
    self.service.start()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\common\service.py&quot;, line 81, in start
    raise WebDriverException(
selenium.common.exceptions.WebDriverException: Message: &#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.chromium.org/home

2023-06-22 05:35:37 [info     ] current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 05:35:37 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
2023-06-22 05:35:37 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
2023-06-22 05:35:37 [info     ] Scenario Execution Completed.  feature=Galaxy automated regression - button and anchor components scenario_name=Verify PPC - Buttons and Anchor - Loading Button
2023-06-22 05:35:37 [info     ] current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 05:35:37 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-section">Galaxy automated regression -&gt; button and anchor components</td>
          <td class="col-tags">TR-C393228</td>
          <td class="col-name">Verify PPC - Buttons and Anchor - Loading Button  locator: helixComponent &gt; loading_button, attribute: padding-bottom, value: 12px</td>
          <td class="col-result">Failed</td>
          <td class="col-duration">00:03.06</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="6">
            <div class="log">self = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BA27EB0&gt;<br/><br/>    def start(self):<br/>        &quot;&quot;&quot;<br/>        Starts the Service.<br/>    <br/>        :Exceptions:<br/>         - WebDriverException : Raised either when it can&#x27;t start the service<br/>           or when it can&#x27;t connect to the service<br/>        &quot;&quot;&quot;<br/>        try:<br/>            cmd = [self.path]<br/>            cmd.extend(self.command_line_args())<br/>&gt;           self.process = subprocess.Popen(cmd, env=self.env,<br/>                                            close_fds=system() != &#x27;Windows&#x27;,<br/>                                            stdout=self.log_file,<br/>                                            stderr=self.log_file,<br/>                                            stdin=PIPE,<br/>                                            creationflags=self.creationflags)<br/><br/>venv\lib\site-packages\selenium\webdriver\common\service.py:71: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Popen: returncode: None args: [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--...&gt;<br/>args = [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--port=52313&#x27;, &#x27;--log-path=C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a5\\driver.log&#x27;]<br/>bufsize = -1, executable = None, stdin = -1, stdout = -3, stderr = -3, preexec_fn = None, close_fds = False, shell = False, cwd = None<br/>env = environ({&#x27;__INTELLIJ_COMMAND_HISTFILE__&#x27;: &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\terminal\\....py::test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px] (call)&#x27;})<br/>universal_newlines = None, startupinfo = None, creationflags = 0, restore_signals = True, start_new_session = False, pass_fds = ()<br/><br/>    def __init__(self, args, bufsize=-1, executable=None,<br/>                 stdin=None, stdout=None, stderr=None,<br/>                 preexec_fn=None, close_fds=True,<br/>                 shell=False, cwd=None, env=None, universal_newlines=None,<br/>                 startupinfo=None, creationflags=0,<br/>                 restore_signals=True, start_new_session=False,<br/>                 pass_fds=(), *, user=None, group=None, extra_groups=None,<br/>                 encoding=None, errors=None, text=None, umask=-1):<br/>        &quot;&quot;&quot;Create new Popen instance.&quot;&quot;&quot;<br/>        _cleanup()<br/>        # Held while anything is calling waitpid before returncode has been<br/>        # updated to prevent clobbering returncode if wait() or poll() are<br/>        # called from multiple threads at once.  After acquiring the lock,<br/>        # code must re-check self.returncode to see if another thread just<br/>        # finished a waitpid() call.<br/>        self._waitpid_lock = threading.Lock()<br/>    <br/>        self._input = None<br/>        self._communication_started = False<br/>        if bufsize is None:<br/>            bufsize = -1  # Restore default<br/>        if not isinstance(bufsize, int):<br/>            raise TypeError(&quot;bufsize must be an integer&quot;)<br/>    <br/>        if _mswindows:<br/>            if preexec_fn is not None:<br/>                raise ValueError(&quot;preexec_fn is not supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>        else:<br/>            # POSIX<br/>            if pass_fds and not close_fds:<br/>                warnings.warn(&quot;pass_fds overriding close_fds.&quot;, RuntimeWarning)<br/>                close_fds = True<br/>            if startupinfo is not None:<br/>                raise ValueError(&quot;startupinfo is only supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>            if creationflags != 0:<br/>                raise ValueError(&quot;creationflags is only supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>    <br/>        self.args = args<br/>        self.stdin = None<br/>        self.stdout = None<br/>        self.stderr = None<br/>        self.pid = None<br/>        self.returncode = None<br/>        self.encoding = encoding<br/>        self.errors = errors<br/>    <br/>        # Validate the combinations of text and universal_newlines<br/>        if (text is not None and universal_newlines is not None<br/>            and bool(universal_newlines) != bool(text)):<br/>            raise SubprocessError(&#x27;Cannot disambiguate when both text &#x27;<br/>                                  &#x27;and universal_newlines are supplied but &#x27;<br/>                                  &#x27;different. Pass one or the other.&#x27;)<br/>    <br/>        # Input and output objects. The general principle is like<br/>        # this:<br/>        #<br/>        # Parent                   Child<br/>        # ------                   -----<br/>        # p2cwrite   ---stdin---&gt;  p2cread<br/>        # c2pread    &lt;--stdout---  c2pwrite<br/>        # errread    &lt;--stderr---  errwrite<br/>        #<br/>        # On POSIX, the child objects are file descriptors.  On<br/>        # Windows, these are Windows file handles.  The parent objects<br/>        # are file descriptors on both platforms.  The parent objects<br/>        # are -1 when not using PIPEs. The child objects are -1<br/>        # when not redirecting.<br/>    <br/>        (p2cread, p2cwrite,<br/>         c2pread, c2pwrite,<br/>         errread, errwrite) = self._get_handles(stdin, stdout, stderr)<br/>    <br/>        # We wrap OS handles *before* launching the child, otherwise a<br/>        # quickly terminating child could make our fds unwrappable<br/>        # (see #8458).<br/>    <br/>        if _mswindows:<br/>            if p2cwrite != -1:<br/>                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)<br/>            if c2pread != -1:<br/>                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)<br/>            if errread != -1:<br/>                errread = msvcrt.open_osfhandle(errread.Detach(), 0)<br/>    <br/>        self.text_mode = encoding or errors or text or universal_newlines<br/>    <br/>        # How long to resume waiting on a child after the first ^C.<br/>        # There is no right value for this.  The purpose is to be polite<br/>        # yet remain good for interactive users trying to exit a tool.<br/>        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()<br/>    <br/>        self._closed_child_pipe_fds = False<br/>    <br/>        if self.text_mode:<br/>            if bufsize == 1:<br/>                line_buffering = True<br/>                # Use the default buffer size for the underlying binary streams<br/>                # since they don&#x27;t support line buffering.<br/>                bufsize = -1<br/>            else:<br/>                line_buffering = False<br/>    <br/>        gid = None<br/>        if group is not None:<br/>            if not hasattr(os, &#x27;setregid&#x27;):<br/>                raise ValueError(&quot;The &#x27;group&#x27; parameter is not supported on the &quot;<br/>                                 &quot;current platform&quot;)<br/>    <br/>            elif isinstance(group, str):<br/>                if grp is None:<br/>                    raise ValueError(&quot;The group parameter cannot be a string &quot;<br/>                                     &quot;on systems without the grp module&quot;)<br/>    <br/>                gid = grp.getgrnam(group).gr_gid<br/>            elif isinstance(group, int):<br/>                gid = group<br/>            else:<br/>                raise TypeError(&quot;Group must be a string or an integer, not {}&quot;<br/>                                .format(type(group)))<br/>    <br/>            if gid &lt; 0:<br/>                raise ValueError(f&quot;Group ID cannot be negative, got {gid}&quot;)<br/>    <br/>        gids = None<br/>        if extra_groups is not None:<br/>            if not hasattr(os, &#x27;setgroups&#x27;):<br/>                raise ValueError(&quot;The &#x27;extra_groups&#x27; parameter is not &quot;<br/>                                 &quot;supported on the current platform&quot;)<br/>    <br/>            elif isinstance(extra_groups, str):<br/>                raise ValueError(&quot;Groups must be a list, not a string&quot;)<br/>    <br/>            gids = []<br/>            for extra_group in extra_groups:<br/>                if isinstance(extra_group, str):<br/>                    if grp is None:<br/>                        raise ValueError(&quot;Items in extra_groups cannot be &quot;<br/>                                         &quot;strings on systems without the &quot;<br/>                                         &quot;grp module&quot;)<br/>    <br/>                    gids.append(grp.getgrnam(extra_group).gr_gid)<br/>                elif isinstance(extra_group, int):<br/>                    gids.append(extra_group)<br/>                else:<br/>                    raise TypeError(&quot;Items in extra_groups must be a string &quot;<br/>                                    &quot;or integer, not {}&quot;<br/>                                    .format(type(extra_group)))<br/>    <br/>            # make sure that the gids are all positive here so we can do less<br/>            # checking in the C code<br/>            for gid_check in gids:<br/>                if gid_check &lt; 0:<br/>                    raise ValueError(f&quot;Group ID cannot be negative, got {gid_check}&quot;)<br/>    <br/>        uid = None<br/>        if user is not None:<br/>            if not hasattr(os, &#x27;setreuid&#x27;):<br/>                raise ValueError(&quot;The &#x27;user&#x27; parameter is not supported on &quot;<br/>                                 &quot;the current platform&quot;)<br/>    <br/>            elif isinstance(user, str):<br/>                if pwd is None:<br/>                    raise ValueError(&quot;The user parameter cannot be a string &quot;<br/>                                     &quot;on systems without the pwd module&quot;)<br/>    <br/>                uid = pwd.getpwnam(user).pw_uid<br/>            elif isinstance(user, int):<br/>                uid = user<br/>            else:<br/>                raise TypeError(&quot;User must be a string or an integer&quot;)<br/>    <br/>            if uid &lt; 0:<br/>                raise ValueError(f&quot;User ID cannot be negative, got {uid}&quot;)<br/>    <br/>        try:<br/>            if p2cwrite != -1:<br/>                self.stdin = io.open(p2cwrite, &#x27;wb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,<br/>                            line_buffering=line_buffering,<br/>                            encoding=encoding, errors=errors)<br/>            if c2pread != -1:<br/>                self.stdout = io.open(c2pread, &#x27;rb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stdout = io.TextIOWrapper(self.stdout,<br/>                            encoding=encoding, errors=errors)<br/>            if errread != -1:<br/>                self.stderr = io.open(errread, &#x27;rb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stderr = io.TextIOWrapper(self.stderr,<br/>                            encoding=encoding, errors=errors)<br/>    <br/>&gt;           self._execute_child(args, executable, preexec_fn, close_fds,<br/>                                pass_fds, cwd, env,<br/>                                startupinfo, creationflags, shell,<br/>                                p2cread, p2cwrite,<br/>                                c2pread, c2pwrite,<br/>                                errread, errwrite,<br/>                                restore_signals,<br/>                                gid, gids, uid, umask,<br/>                                start_new_session)<br/><br/>C:\Program Files\Python39\lib\subprocess.py:951: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Popen: returncode: None args: [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--...&gt;<br/>args = &#x27;./binaries/webdriver/chromedriver.exe --port=52313 --log-path=C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a5\\driver.log&#x27;<br/>executable = None, preexec_fn = None, close_fds = False, pass_fds = (), cwd = None<br/>env = environ({&#x27;__INTELLIJ_COMMAND_HISTFILE__&#x27;: &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\terminal\\....py::test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px] (call)&#x27;})<br/>startupinfo = &lt;subprocess.STARTUPINFO object at 0x0000015C7BA277C0&gt;, creationflags = 0, shell = False, p2cread = Handle(1212), p2cwrite = 16, c2pread = -1<br/>c2pwrite = Handle(1592), errread = -1, errwrite = Handle(1476), unused_restore_signals = True, unused_gid = None, unused_gids = None, unused_uid = None<br/>unused_umask = -1, unused_start_new_session = False<br/><br/>    def _execute_child(self, args, executable, preexec_fn, close_fds,<br/>                       pass_fds, cwd, env,<br/>                       startupinfo, creationflags, shell,<br/>                       p2cread, p2cwrite,<br/>                       c2pread, c2pwrite,<br/>                       errread, errwrite,<br/>                       unused_restore_signals,<br/>                       unused_gid, unused_gids, unused_uid,<br/>                       unused_umask,<br/>                       unused_start_new_session):<br/>        &quot;&quot;&quot;Execute program (MS Windows version)&quot;&quot;&quot;<br/>    <br/>        assert not pass_fds, &quot;pass_fds not supported on Windows.&quot;<br/>    <br/>        if isinstance(args, str):<br/>            pass<br/>        elif isinstance(args, bytes):<br/>            if shell:<br/>                raise TypeError(&#x27;bytes args is not allowed on Windows&#x27;)<br/>            args = list2cmdline([args])<br/>        elif isinstance(args, os.PathLike):<br/>            if shell:<br/>                raise TypeError(&#x27;path-like args is not allowed when &#x27;<br/>                                &#x27;shell is true&#x27;)<br/>            args = list2cmdline([args])<br/>        else:<br/>            args = list2cmdline(args)<br/>    <br/>        if executable is not None:<br/>            executable = os.fsdecode(executable)<br/>    <br/>        # Process startup details<br/>        if startupinfo is None:<br/>            startupinfo = STARTUPINFO()<br/>        else:<br/>            # bpo-34044: Copy STARTUPINFO since it is modified above,<br/>            # so the caller can reuse it multiple times.<br/>            startupinfo = startupinfo.copy()<br/>    <br/>        use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)<br/>        if use_std_handles:<br/>            startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES<br/>            startupinfo.hStdInput = p2cread<br/>            startupinfo.hStdOutput = c2pwrite<br/>            startupinfo.hStdError = errwrite<br/>    <br/>        attribute_list = startupinfo.lpAttributeList<br/>        have_handle_list = bool(attribute_list and<br/>                                &quot;handle_list&quot; in attribute_list and<br/>                                attribute_list[&quot;handle_list&quot;])<br/>    <br/>        # If we were given an handle_list or need to create one<br/>        if have_handle_list or (use_std_handles and close_fds):<br/>            if attribute_list is None:<br/>                attribute_list = startupinfo.lpAttributeList = {}<br/>            handle_list = attribute_list[&quot;handle_list&quot;] = \<br/>                list(attribute_list.get(&quot;handle_list&quot;, []))<br/>    <br/>            if use_std_handles:<br/>                handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]<br/>    <br/>            handle_list[:] = self._filter_handle_list(handle_list)<br/>    <br/>            if handle_list:<br/>                if not close_fds:<br/>                    warnings.warn(&quot;startupinfo.lpAttributeList[&#x27;handle_list&#x27;] &quot;<br/>                                  &quot;overriding close_fds&quot;, RuntimeWarning)<br/>    <br/>                # When using the handle_list we always request to inherit<br/>                # handles but the only handles that will be inherited are<br/>                # the ones in the handle_list<br/>                close_fds = False<br/>    <br/>        if shell:<br/>            startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW<br/>            startupinfo.wShowWindow = _winapi.SW_HIDE<br/>            comspec = os.environ.get(&quot;COMSPEC&quot;, &quot;cmd.exe&quot;)<br/>            args = &#x27;{} /c &quot;{}&quot;&#x27;.format (comspec, args)<br/>    <br/>        if cwd is not None:<br/>            cwd = os.fsdecode(cwd)<br/>    <br/>        sys.audit(&quot;subprocess.Popen&quot;, executable, args, cwd, env)<br/>    <br/>        # Start the process<br/>        try:<br/>&gt;           hp, ht, pid, tid = _winapi.CreateProcess(executable, args,<br/>                                     # no special security<br/>                                     None, None,<br/>                                     int(not close_fds),<br/>                                     creationflags,<br/>                                     env,<br/>                                     cwd,<br/>                                     startupinfo)<br/><span class="error">E                                    FileNotFoundError: [WinError 2] The system cannot find the file specified</span><br/><br/>C:\Program Files\Python39\lib\subprocess.py:1420: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>request = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/>scenario = Scenario(feature=Feature(scenarios=OrderedDict([(&#x27;Verify PPC - Buttons and Anchor - Loading Button&#x27;, ScenarioTemplate(...eyword=&#x27;Then&#x27;, failed=None, scenario=None, background=None, lines=[])], tags={&#x27;TR-C393228&#x27;, &#x27;automated&#x27;, &#x27;regression&#x27;})<br/>step = Step(type=&#x27;given&#x27;, _name=&quot;I am on the page &#x27;/&#x27;&quot;, line_number=5, indent=8, keyword=&#x27;Given&#x27;, failed=True, scenario=None,...closeIcon&#x27;&quot;, line_number=8, indent=8, keyword=&#x27;And&#x27;, failed=None, scenario=None, background=..., lines=[])]), lines=[])<br/>context = StepFunctionContext(type=&#x27;given&#x27;, step_func=&lt;function open_webpage at 0x0000015C7A412820&gt;, parser=&lt;pytest_bdd.parsers....t at 0x0000015C7A40F7C0&gt;, converters={&#x27;page_url&#x27;: &lt;function env_formatted at 0x0000015C78B20700&gt;}, target_fixture=None)<br/><br/>    def _execute_step_function(<br/>        request: FixtureRequest, scenario: Scenario, step: Step, context: StepFunctionContext<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;Execute step function.&quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        kw = {<br/>            &quot;request&quot;: request,<br/>            &quot;feature&quot;: scenario.feature,<br/>            &quot;scenario&quot;: scenario,<br/>            &quot;step&quot;: step,<br/>            &quot;step_func&quot;: context.step_func,<br/>            &quot;step_func_args&quot;: {},<br/>        }<br/>    <br/>        request.config.hook.pytest_bdd_before_step(**kw)<br/>    <br/>        # Get the step argument values.<br/>        converters = context.converters<br/>        kwargs = {}<br/>        args = get_args(context.step_func)<br/>    <br/>        try:<br/>            parsed_args = context.parser.parse_arguments(step.name)<br/>            assert parsed_args is not None, (<br/>                f&quot;Unexpected `NoneType` returned from &quot; f&quot;parse_arguments(...) in parser: {context.parser!r}&quot;<br/>            )<br/>            for arg, value in parsed_args.items():<br/>                if arg in converters:<br/>                    value = converters[arg](value)<br/>                kwargs[arg] = value<br/>    <br/>&gt;           kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}<br/><br/>venv\lib\site-packages\pytest_bdd\scenario.py:154: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>.0 = &lt;list_iterator object at 0x0000015C7BBCD4C0&gt;<br/><br/>&gt;   kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}<br/><br/>venv\lib\site-packages\pytest_bdd\scenario.py:154: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/>argname = &#x27;selenium_generics&#x27;<br/><br/>    def getfixturevalue(self, argname: str) -&gt; Any:<br/>        &quot;&quot;&quot;Dynamically run a named fixture function.<br/>    <br/>        Declaring fixtures via function argument is recommended where possible.<br/>        But if you can only decide whether to use another fixture at test<br/>        setup time, you may use this function to retrieve it inside a fixture<br/>        or test function body.<br/>    <br/>        :raises pytest.FixtureLookupError:<br/>            If the given fixture could not be found.<br/>        &quot;&quot;&quot;<br/>&gt;       fixturedef = self._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:581: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/>argname = &#x27;selenium_generics&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium_generics&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium_generics&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/>argname = &#x27;selenium&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/>argname = &#x27;selenium&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/>argname = &#x27;driver&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>            fixturedef = request._get_active_fixturedef(argname)<br/>            if argname != &quot;request&quot;:<br/>                # PseudoFixtureDef is only for &quot;request&quot;.<br/>                assert isinstance(fixturedef, FixtureDef)<br/>                fixturedef.addfinalizer(functools.partial(self.finish, request=request))<br/>    <br/>        my_cache_key = self.cache_key(request)<br/>        if self.cached_result is not None:<br/>            # note: comparison with `==` can fail (or be expensive) for e.g.<br/>            # numpy arrays (#6497).<br/>            cache_key = self.cached_result[1]<br/>            if my_cache_key is cache_key:<br/>                if self.cached_result[2] is not None:<br/>                    _, val, tb = self.cached_result[2]<br/>                    raise val.with_traceback(tb)<br/>                else:<br/>                    result = self.cached_result[0]<br/>                    return result<br/>            # We have a previous but differently parametrized fixture instance<br/>            # so we need to tear it down before creating a new one.<br/>            self.finish(request)<br/>            assert self.cached_result is None<br/>    <br/>        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)<br/>&gt;       result = hook.pytest_fixture_setup(fixturedef=self, request=request)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1072: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_HookCaller &#x27;pytest_fixture_setup&#x27;&gt;<br/>kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def __call__(self, **kwargs: object) -&gt; Any:<br/>        assert (<br/>            not self.is_historic()<br/>        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;<br/>        self._verify_all_args_are_provided(kwargs)<br/>        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False<br/>&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_hooks.py:433: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_pytest.config.PytestPluginManager object at 0x0000015C7034A250&gt;, hook_name = &#x27;pytest_fixture_setup&#x27;<br/>methods = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _hookexec(<br/>        self,<br/>        hook_name: str,<br/>        methods: Sequence[HookImpl],<br/>        kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        # called from all hookcaller instances.<br/>        # enable_tracing will set its own wrapping function at self._inner_hookexec<br/>&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_manager.py:112: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_name = &#x27;pytest_fixture_setup&#x27;<br/>hook_impls = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>caller_kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _multicall(<br/>        hook_name: str,<br/>        hook_impls: Sequence[HookImpl],<br/>        caller_kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        results: list[object] = []<br/>        exception = None<br/>        only_new_style_wrappers = True<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns: list[Teardown] = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    f&quot;hook call must provide argument {argname!r}&quot;<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        only_new_style_wrappers = False<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            wrapper_gen = cast(Generator[None, _Result[object], None], res)<br/>                            next(wrapper_gen)  # first yield<br/>                            teardowns.append((wrapper_gen,))<br/>                        except StopIteration:<br/>                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)<br/>                    elif hook_impl.wrapper:<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            function_gen = cast(Generator[None, object, object], res)<br/>                            next(function_gen)  # first yield<br/>                            teardowns.append(function_gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)<br/>                    else:<br/>                        res = hook_impl.function(*args)<br/>                        if res is not None:<br/>                            results.append(res)<br/>                            if firstresult:  # halt further impl calls<br/>                                break<br/>            except BaseException as exc:<br/>                exception = exc<br/>        finally:<br/>            # Fast path - only new-style wrappers, no _Result.<br/>            if only_new_style_wrappers:<br/>                if firstresult:  # first result hooks return a single value<br/>                    result = results[0] if results else None<br/>                else:<br/>                    result = results<br/>    <br/>                # run all wrapper post-yield blocks<br/>                for teardown in reversed(teardowns):<br/>                    try:<br/>                        if exception is not None:<br/>                            teardown.throw(exception)  # type: ignore[union-attr]<br/>                        else:<br/>                            teardown.send(result)  # type: ignore[union-attr]<br/>                        # Following is unreachable for a well behaved hook wrapper.<br/>                        # Try to force finalizers otherwise postponed till GC action.<br/>                        # Note: close() may raise if generator handles GeneratorExit.<br/>                        teardown.close()  # type: ignore[union-attr]<br/>                    except StopIteration as si:<br/>                        result = si.value<br/>                        exception = None<br/>                        continue<br/>                    except BaseException as e:<br/>                        exception = e<br/>                        continue<br/>                    _raise_wrapfail(teardown, &quot;has second yield&quot;)  # type: ignore[arg-type]<br/>    <br/>                if exception is not None:<br/>                    raise exception.with_traceback(exception.__traceback__)<br/>                else:<br/>                    return result<br/>    <br/>            # Slow path - need to support old-style wrappers.<br/>            else:<br/>                if firstresult:  # first result hooks return a single value<br/>                    outcome: _Result[object | list[object]] = _Result(<br/>                        results[0] if results else None, exception<br/>                    )<br/>                else:<br/>                    outcome = _Result(results, exception)<br/>    <br/>                # run all wrapper post-yield blocks<br/>                for teardown in reversed(teardowns):<br/>                    if isinstance(teardown, tuple):<br/>                        try:<br/>                            teardown[0].send(outcome)<br/>                            _raise_wrapfail(teardown[0], &quot;has second yield&quot;)<br/>                        except StopIteration:<br/>                            pass<br/>                    else:<br/>                        try:<br/>                            if outcome._exception is not None:<br/>                                teardown.throw(outcome._exception)<br/>                            else:<br/>                                teardown.send(outcome._result)<br/>                            # Following is unreachable for a well behaved hook wrapper.<br/>                            # Try to force finalizers otherwise postponed till GC action.<br/>                            # Note: close() may raise if generator handles GeneratorExit.<br/>                            teardown.close()<br/>                        except StopIteration as si:<br/>                            outcome.force_result(si.value)<br/>                            continue<br/>                        except BaseException as e:<br/>                            outcome.force_exception(e)<br/>                            continue<br/>                        _raise_wrapfail(teardown, &quot;has second yield&quot;)<br/>    <br/>&gt;               return outcome.get_result()<br/><br/>venv\lib\site-packages\pluggy\_callers.py:155: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;pluggy._result._Result object at 0x0000015C7BA27190&gt;<br/><br/>    def get_result(self) -&gt; _T:<br/>        &quot;&quot;&quot;Get the result(s) for this hook call.<br/>    <br/>        If the hook was marked as a ``firstresult`` only a single value<br/>        will be returned, otherwise a list of results.<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        exc = self._exception<br/>        if exc is None:<br/>            return cast(_T, self._result)<br/>        else:<br/>&gt;           raise exc.with_traceback(exc.__traceback__)<br/><br/>venv\lib\site-packages\pluggy\_result.py:108: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_name = &#x27;pytest_fixture_setup&#x27;<br/>hook_impls = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>caller_kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _multicall(<br/>        hook_name: str,<br/>        hook_impls: Sequence[HookImpl],<br/>        caller_kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        results: list[object] = []<br/>        exception = None<br/>        only_new_style_wrappers = True<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns: list[Teardown] = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    f&quot;hook call must provide argument {argname!r}&quot;<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        only_new_style_wrappers = False<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            wrapper_gen = cast(Generator[None, _Result[object], None], res)<br/>                            next(wrapper_gen)  # first yield<br/>                            teardowns.append((wrapper_gen,))<br/>                        except StopIteration:<br/>                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)<br/>                    elif hook_impl.wrapper:<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            function_gen = cast(Generator[None, object, object], res)<br/>                            next(function_gen)  # first yield<br/>                            teardowns.append(function_gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)<br/>                    else:<br/>&gt;                       res = hook_impl.function(*args)<br/><br/>venv\lib\site-packages\pluggy\_callers.py:80: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fixturedef = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/><br/>    def pytest_fixture_setup(<br/>        fixturedef: FixtureDef[_FixtureValue], request: SubRequest<br/>    ) -&gt; _FixtureValue:<br/>        &quot;&quot;&quot;Execution of fixture setup.&quot;&quot;&quot;<br/>        kwargs = {}<br/>        for argname in fixturedef.argnames:<br/>            fixdef = request._get_active_fixturedef(argname)<br/>            assert fixdef.cached_result is not None<br/>            result, arg_cache_key, exc = fixdef.cached_result<br/>            request._check_scope(argname, request.scope, fixdef.scope)<br/>            kwargs[argname] = result<br/>    <br/>        fixturefunc = resolve_fixture_function(fixturedef, request)<br/>        my_cache_key = fixturedef.cache_key(request)<br/>        try:<br/>&gt;           result = call_fixture_func(fixturefunc, request, kwargs)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1126: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fixturefunc = &lt;function driver at 0x0000015C787C44C0&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/>kwargs = {&#x27;driver_class&#x27;: &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;, &#x27;driver_kwargs&#x27;: {&#x27;desired_capabilities&#x27;: {&#x27;...r &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;}<br/><br/>    def call_fixture_func(<br/>        fixturefunc: &quot;_FixtureFunc[_FixtureValue]&quot;, request: FixtureRequest, kwargs<br/>    ) -&gt; _FixtureValue:<br/>        if is_generator(fixturefunc):<br/>            fixturefunc = cast(<br/>                Callable[..., Generator[_FixtureValue, None, None]], fixturefunc<br/>            )<br/>            generator = fixturefunc(**kwargs)<br/>            try:<br/>&gt;               fixture_result = next(generator)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:925: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/>driver_class = &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;<br/>driver_kwargs = {&#x27;desired_capabilities&#x27;: {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}, &#x27;executable_path&#x27;: &#x27;....\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a5\\driver.log&#x27;}<br/><br/>    @pytest.fixture<br/>    def driver(request, driver_class, driver_kwargs):<br/>        &quot;&quot;&quot;Returns a WebDriver instance based on options and capabilities&quot;&quot;&quot;<br/>    <br/>        retries = int(request.config.getini(&quot;max_driver_init_attempts&quot;))<br/>&gt;       for retry in Retrying(<br/>            stop=stop_after_attempt(retries), wait=wait_exponential(), reraise=True<br/>        ):<br/><br/>venv\lib\site-packages\pytest_selenium\pytest_selenium.py:201: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Retrying object at 0x15c7ba27fd0 (stop=&lt;tenacity.stop.stop_after_attempt object at 0x0000015C7BA276A0&gt;, wait=&lt;tenacit...631370&gt;, before=&lt;function before_nothing at 0x0000015C7861BB80&gt;, after=&lt;function after_nothing at 0x0000015C7862F700&gt;)&gt;<br/><br/>    def __iter__(self):<br/>        self.begin(None)<br/>    <br/>        retry_state = RetryCallState(self, fn=None, args=(), kwargs={})<br/>        while True:<br/>&gt;           do = self.iter(retry_state=retry_state)<br/><br/>venv\lib\site-packages\tenacity\__init__.py:394: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Retrying object at 0x15c7ba27fd0 (stop=&lt;tenacity.stop.stop_after_attempt object at 0x0000015C7BA276A0&gt;, wait=&lt;tenacit...631370&gt;, before=&lt;function before_nothing at 0x0000015C7861BB80&gt;, after=&lt;function after_nothing at 0x0000015C7862F700&gt;)&gt;<br/>retry_state = &lt;tenacity.RetryCallState object at 0x0000015C7BA27DF0&gt;<br/><br/>    def iter(self, retry_state):  # noqa<br/>        fut = retry_state.outcome<br/>        if fut is None:<br/>            if self.before is not None:<br/>                self.before(retry_state)<br/>            return DoAttempt()<br/>    <br/>        is_explicit_retry = retry_state.outcome.failed \<br/>            and isinstance(retry_state.outcome.exception(), TryAgain)<br/>        if not (is_explicit_retry or self.retry(retry_state=retry_state)):<br/>            return fut.result()<br/>    <br/>        if self.after is not None:<br/>            self.after(retry_state=retry_state)<br/>    <br/>        self.statistics[&#x27;delay_since_first_attempt&#x27;] = \<br/>            retry_state.seconds_since_start<br/>        if self.stop(retry_state=retry_state):<br/>            if self.retry_error_callback:<br/>                return self.retry_error_callback(retry_state=retry_state)<br/>            retry_exc = self.retry_error_cls(fut)<br/>            if self.reraise:<br/>&gt;               raise retry_exc.reraise()<br/><br/>venv\lib\site-packages\tenacity\__init__.py:372: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = RetryError(&lt;Future at 0x15c7ba27e80 state=finished raised WebDriverException&gt;)<br/><br/>    def reraise(self):<br/>        if self.last_attempt.failed:<br/>&gt;           raise self.last_attempt.result()<br/><br/>venv\lib\site-packages\tenacity\__init__.py:189: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = None, timeout = None<br/><br/>    def result(self, timeout=None):<br/>        &quot;&quot;&quot;Return the result of the call that the future represents.<br/>    <br/>        Args:<br/>            timeout: The number of seconds to wait for the result if the future<br/>                isn&#x27;t done. If None, then there is no limit on the wait time.<br/>    <br/>        Returns:<br/>            The result of the call that the future represents.<br/>    <br/>        Raises:<br/>            CancelledError: If the future was cancelled.<br/>            TimeoutError: If the future didn&#x27;t finish executing before the given<br/>                timeout.<br/>            Exception: If the call raised then that exception will be raised.<br/>        &quot;&quot;&quot;<br/>        try:<br/>            with self._condition:<br/>                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:<br/>                    raise CancelledError()<br/>                elif self._state == FINISHED:<br/>&gt;                   return self.__get_result()<br/><br/>C:\Program Files\Python39\lib\concurrent\futures\_base.py:439: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = None<br/><br/>    def __get_result(self):<br/>        if self._exception:<br/>            try:<br/>&gt;               raise self._exception<br/><br/>C:\Program Files\Python39\lib\concurrent\futures\_base.py:391: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button-padding-bottom-12px]&gt;&gt;<br/>driver_class = &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;<br/>driver_kwargs = {&#x27;desired_capabilities&#x27;: {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}, &#x27;executable_path&#x27;: &#x27;....\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a5\\driver.log&#x27;}<br/><br/>    @pytest.fixture<br/>    def driver(request, driver_class, driver_kwargs):<br/>        &quot;&quot;&quot;Returns a WebDriver instance based on options and capabilities&quot;&quot;&quot;<br/>    <br/>        retries = int(request.config.getini(&quot;max_driver_init_attempts&quot;))<br/>        for retry in Retrying(<br/>            stop=stop_after_attempt(retries), wait=wait_exponential(), reraise=True<br/>        ):<br/>            with retry:<br/>                LOGGER.info(<br/>                    f&quot;Driver init, attempt {retry.retry_state.attempt_number}/{retries}&quot;<br/>                )<br/>&gt;               driver = driver_class(**driver_kwargs)<br/><br/>venv\lib\site-packages\pytest_selenium\pytest_selenium.py:208: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[AttributeError(&quot;&#x27;WebDriver&#x27; object has no attribute &#x27;session_id&#x27;&quot;) raised in repr()] WebDriver object at 0x15c7ba27e50&gt;<br/>executable_path = &#x27;./binaries/webdriver/chromedriver.exe&#x27;, port = 0, options = &lt;selenium.webdriver.chrome.options.Options object at 0x0000015C7BA27070&gt;<br/>service_args = None, desired_capabilities = {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}<br/>service_log_path = &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a5\\driver.log&#x27;<br/>chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BA27EB0&gt;, keep_alive = True<br/><br/>    def __init__(self, executable_path=DEFAULT_EXECUTABLE_PATH, port=DEFAULT_PORT,<br/>                 options: Options = None, service_args=None,<br/>                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,<br/>                 chrome_options=None, service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):<br/>        &quot;&quot;&quot;<br/>        Creates a new instance of the chrome driver.<br/>        Starts the service and then creates new instance of chrome driver.<br/>    <br/>        :Args:<br/>         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH<br/>         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.<br/>         - options - this takes an instance of ChromeOptions<br/>         - service - Service object for handling the browser driver if you need to pass extra details<br/>         - service_args - Deprecated: List of args to pass to the driver service<br/>         - desired_capabilities - Deprecated: Dictionary object with non-browser specific<br/>           capabilities only, such as &quot;proxy&quot; or &quot;loggingPref&quot;.<br/>         - service_log_path - Deprecated: Where to log information from the driver.<br/>         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.<br/>        &quot;&quot;&quot;<br/>        if executable_path != &#x27;chromedriver&#x27;:<br/>            warnings.warn(&#x27;executable_path has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if chrome_options:<br/>            warnings.warn(&#x27;use options instead of chrome_options&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>            options = chrome_options<br/>        if keep_alive != DEFAULT_KEEP_ALIVE:<br/>            warnings.warn(&#x27;keep_alive has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        else:<br/>            keep_alive = True<br/>        if not service:<br/>            service = Service(executable_path, port, service_args, service_log_path)<br/>    <br/>&gt;       super(WebDriver, self).__init__(DesiredCapabilities.CHROME[&#x27;browserName&#x27;], &quot;goog&quot;,<br/>                                        port, options,<br/>                                        service_args, desired_capabilities,<br/>                                        service_log_path, service, keep_alive)<br/><br/>venv\lib\site-packages\selenium\webdriver\chrome\webdriver.py:70: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[AttributeError(&quot;&#x27;WebDriver&#x27; object has no attribute &#x27;session_id&#x27;&quot;) raised in repr()] WebDriver object at 0x15c7ba27e50&gt;, browser_name = &#x27;chrome&#x27;<br/>vendor_prefix = &#x27;goog&#x27;, port = 0, options = &lt;selenium.webdriver.chrome.options.Options object at 0x0000015C7BA27070&gt;, service_args = None<br/>desired_capabilities = {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}<br/>service_log_path = &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a5\\driver.log&#x27;<br/>service = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BA27EB0&gt;, keep_alive = True<br/><br/>    def __init__(self, browser_name, vendor_prefix,<br/>                 port=DEFAULT_PORT, options: BaseOptions = None, service_args=None,<br/>                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,<br/>                 service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):<br/>        &quot;&quot;&quot;<br/>        Creates a new WebDriver instance of the ChromiumDriver.<br/>        Starts the service and then creates new WebDriver instance of ChromiumDriver.<br/>    <br/>        :Args:<br/>         - browser_name - Browser name used when matching capabilities.<br/>         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.<br/>         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.<br/>         - options - this takes an instance of ChromiumOptions<br/>         - service_args - Deprecated: List of args to pass to the driver service<br/>         - desired_capabilities - Deprecated: Dictionary object with non-browser specific<br/>           capabilities only, such as &quot;proxy&quot; or &quot;loggingPref&quot;.<br/>         - service_log_path - Deprecated: Where to log information from the driver.<br/>         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.<br/>        &quot;&quot;&quot;<br/>        if desired_capabilities:<br/>            warnings.warn(&#x27;desired_capabilities has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if port != DEFAULT_PORT:<br/>            warnings.warn(&#x27;port has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        self.port = port<br/>        if service_log_path != DEFAULT_SERVICE_LOG_PATH:<br/>            warnings.warn(&#x27;service_log_path has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:<br/>            warnings.warn(&#x27;keep_alive has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        else:<br/>            keep_alive = True<br/>    <br/>        self.vendor_prefix = vendor_prefix<br/>    <br/>        _ignore_proxy = None<br/>        if not options:<br/>            options = self.create_options()<br/>    <br/>        if desired_capabilities:<br/>            for key, value in desired_capabilities.items():<br/>                options.set_capability(key, value)<br/>    <br/>        if options._ignore_local_proxy:<br/>            _ignore_proxy = options._ignore_local_proxy<br/>    <br/>        if not service:<br/>            raise AttributeError(&#x27;service cannot be None&#x27;)<br/>    <br/>        self.service = service<br/>&gt;       self.service.start()<br/><br/>venv\lib\site-packages\selenium\webdriver\chromium\webdriver.py:90: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BA27EB0&gt;<br/><br/>    def start(self):<br/>        &quot;&quot;&quot;<br/>        Starts the Service.<br/>    <br/>        :Exceptions:<br/>         - WebDriverException : Raised either when it can&#x27;t start the service<br/>           or when it can&#x27;t connect to the service<br/>        &quot;&quot;&quot;<br/>        try:<br/>            cmd = [self.path]<br/>            cmd.extend(self.command_line_args())<br/>            self.process = subprocess.Popen(cmd, env=self.env,<br/>                                            close_fds=system() != &#x27;Windows&#x27;,<br/>                                            stdout=self.log_file,<br/>                                            stderr=self.log_file,<br/>                                            stdin=PIPE,<br/>                                            creationflags=self.creationflags)<br/>        except TypeError:<br/>            raise<br/>        except OSError as err:<br/>            if err.errno == errno.ENOENT:<br/>&gt;               raise WebDriverException(<br/>                    &quot;&#x27;%s&#x27; executable needs to be in PATH. %s&quot; % (<br/>                        os.path.basename(self.path), self.start_error_message)<br/><span class="error">E                       selenium.common.exceptions.WebDriverException: Message: &#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.chromium.org/home</span><br/><br/>venv\lib\site-packages\selenium\webdriver\common\service.py:81: WebDriverException<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;_HookCaller &#x27;pytest_bdd_step_error&#x27;&gt;<br/>kwargs = {&#x27;exception&#x27;: WebDriverException(&quot;&#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.c...=&#x27;Then&#x27;, failed=None, scenario=None, background=None, lines=[])], tags={&#x27;TR-C393228&#x27;, &#x27;automated&#x27;, &#x27;regression&#x27;}), ...}<br/>firstresult = False<br/><br/>    def __call__(self, **kwargs: object) -&gt; Any:<br/>        assert (<br/>            not self.is_historic()<br/>        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;<br/>        self._verify_all_args_are_provided(kwargs)<br/>        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False<br/>&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_hooks.py:433: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv\lib\site-packages\pluggy\_manager.py:112: in _hookexec<br/>    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)<br/>venv\lib\site-packages\enhanced_reports\core.py:493: in pytest_bdd_step_error<br/>    __capture_js_logs(current_state, driver, op_name)<br/>venv\lib\site-packages\enhanced_reports\core.py:234: in __capture_js_logs<br/>    logs = browser_console_manager.get_js_logs(driver)<br/>venv\lib\site-packages\enhanced_reports\browser_console_manager.py:13: in get_js_logs<br/>    logs = _capture_output(driver)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>driver = None<br/><br/>    def _capture_output(driver: WebDriver):<br/>&gt;       return driver.get_log(&quot;browser&quot;)<br/><span class="error">E       AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;get_log&#x27;</span><br/><br/>venv\lib\site-packages\enhanced_reports\browser_console_manager.py:18: AttributeError<br/> -----------------------------Captured stderr setup------------------------------ <br/>2023-06-22 05:35:37 [info     ] current param_value False
<br/> -------------------------------Captured log setup------------------------------- <br/>2023-06-22 11:05:37 INFO current param_value False<br/> ------------------------------Captured stderr call------------------------------ <br/>

2023-06-22 05:35:37 [info     ] Scenario Execution Started.    feature=Galaxy automated regression - button and anchor components scenario_name=Verify PPC - Buttons and Anchor - Loading Button
2023-06-22 05:35:37 [info     ] Capabilities from markers: {}
2023-06-22 05:35:37 [info     ] Driver init, attempt 1/3
2023-06-22 05:35:38 [info     ] Driver init, attempt 2/3
2023-06-22 05:35:40 [info     ] Driver init, attempt 3/3
2023-06-22 05:35:40 [error    ] Step FAILED.                   step=I am on the page &#x27;/&#x27;
Traceback (most recent call last):
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\common\service.py&quot;, line 71, in start
    self.process = subprocess.Popen(cmd, env=self.env,
  File &quot;C:\Program Files\Python39\lib\subprocess.py&quot;, line 951, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File &quot;C:\Program Files\Python39\lib\subprocess.py&quot;, line 1420, in _execute_child
    hp, ht, pid, tid = _winapi.CreateProcess(executable, args,
FileNotFoundError: [WinError 2] The system cannot find the file specified

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_bdd\scenario.py&quot;, line 154, in _execute_step_function
    kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_bdd\scenario.py&quot;, line 154, in &lt;dictcomp&gt;
    kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 581, in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1072, in execute
    result = hook.pytest_fixture_setup(fixturedef=self, request=request)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_hooks.py&quot;, line 433, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_manager.py&quot;, line 112, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_callers.py&quot;, line 155, in _multicall
    return outcome.get_result()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_result.py&quot;, line 108, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_callers.py&quot;, line 80, in _multicall
    res = hook_impl.function(*args)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1126, in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 925, in call_fixture_func
    fixture_result = next(generator)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_selenium\pytest_selenium.py&quot;, line 201, in driver
    for retry in Retrying(
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 394, in __iter__
    do = self.iter(retry_state=retry_state)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 372, in iter
    raise retry_exc.reraise()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 189, in reraise
    raise self.last_attempt.result()
  File &quot;C:\Program Files\Python39\lib\concurrent\futures\_base.py&quot;, line 439, in result
    return self.__get_result()
  File &quot;C:\Program Files\Python39\lib\concurrent\futures\_base.py&quot;, line 391, in __get_result
    raise self._exception
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_selenium\pytest_selenium.py&quot;, line 208, in driver
    driver = driver_class(**driver_kwargs)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\chrome\webdriver.py&quot;, line 70, in __init__
    super(WebDriver, self).__init__(DesiredCapabilities.CHROME[&#x27;browserName&#x27;], &quot;goog&quot;,
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\chromium\webdriver.py&quot;, line 90, in __init__
    self.service.start()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\common\service.py&quot;, line 81, in start
    raise WebDriverException(
selenium.common.exceptions.WebDriverException: Message: &#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.chromium.org/home

2023-06-22 05:35:40 [info     ] current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 05:35:40 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
2023-06-22 05:35:40 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
2023-06-22 05:35:40 [info     ] Scenario Execution Completed.  feature=Galaxy automated regression - button and anchor components scenario_name=Verify PPC - Buttons and Anchor - Loading Button
2023-06-22 05:35:40 [info     ] current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 05:35:40 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
<br/></div></td></tr></tbody>
      <tbody class="failed results-table-row">
        <tr>
          <td class="col-section">Galaxy automated regression -&gt; button and anchor components</td>
          <td class="col-tags">TR-C393228</td>
          <td class="col-name">Verify PPC - Buttons and Anchor - Loading Button  locator: helixComponent &gt; loading_button_icon, attribute: color, value: rgba(255, 255, 255, 1)</td>
          <td class="col-result">Failed</td>
          <td class="col-duration">00:03.04</td>
          <td class="col-links"></td></tr>
        <tr>
          <td class="extra" colspan="6">
            <div class="log">self = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BB2A7F0&gt;<br/><br/>    def start(self):<br/>        &quot;&quot;&quot;<br/>        Starts the Service.<br/>    <br/>        :Exceptions:<br/>         - WebDriverException : Raised either when it can&#x27;t start the service<br/>           or when it can&#x27;t connect to the service<br/>        &quot;&quot;&quot;<br/>        try:<br/>            cmd = [self.path]<br/>            cmd.extend(self.command_line_args())<br/>&gt;           self.process = subprocess.Popen(cmd, env=self.env,<br/>                                            close_fds=system() != &#x27;Windows&#x27;,<br/>                                            stdout=self.log_file,<br/>                                            stderr=self.log_file,<br/>                                            stdin=PIPE,<br/>                                            creationflags=self.creationflags)<br/><br/>venv\lib\site-packages\selenium\webdriver\common\service.py:71: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Popen: returncode: None args: [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--...&gt;<br/>args = [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--port=52316&#x27;, &#x27;--log-path=C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a6\\driver.log&#x27;]<br/>bufsize = -1, executable = None, stdin = -1, stdout = -3, stderr = -3, preexec_fn = None, close_fds = False, shell = False, cwd = None<br/>env = environ({&#x27;__INTELLIJ_COMMAND_HISTFILE__&#x27;: &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\terminal\\...fy_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)] (call)&#x27;})<br/>universal_newlines = None, startupinfo = None, creationflags = 0, restore_signals = True, start_new_session = False, pass_fds = ()<br/><br/>    def __init__(self, args, bufsize=-1, executable=None,<br/>                 stdin=None, stdout=None, stderr=None,<br/>                 preexec_fn=None, close_fds=True,<br/>                 shell=False, cwd=None, env=None, universal_newlines=None,<br/>                 startupinfo=None, creationflags=0,<br/>                 restore_signals=True, start_new_session=False,<br/>                 pass_fds=(), *, user=None, group=None, extra_groups=None,<br/>                 encoding=None, errors=None, text=None, umask=-1):<br/>        &quot;&quot;&quot;Create new Popen instance.&quot;&quot;&quot;<br/>        _cleanup()<br/>        # Held while anything is calling waitpid before returncode has been<br/>        # updated to prevent clobbering returncode if wait() or poll() are<br/>        # called from multiple threads at once.  After acquiring the lock,<br/>        # code must re-check self.returncode to see if another thread just<br/>        # finished a waitpid() call.<br/>        self._waitpid_lock = threading.Lock()<br/>    <br/>        self._input = None<br/>        self._communication_started = False<br/>        if bufsize is None:<br/>            bufsize = -1  # Restore default<br/>        if not isinstance(bufsize, int):<br/>            raise TypeError(&quot;bufsize must be an integer&quot;)<br/>    <br/>        if _mswindows:<br/>            if preexec_fn is not None:<br/>                raise ValueError(&quot;preexec_fn is not supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>        else:<br/>            # POSIX<br/>            if pass_fds and not close_fds:<br/>                warnings.warn(&quot;pass_fds overriding close_fds.&quot;, RuntimeWarning)<br/>                close_fds = True<br/>            if startupinfo is not None:<br/>                raise ValueError(&quot;startupinfo is only supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>            if creationflags != 0:<br/>                raise ValueError(&quot;creationflags is only supported on Windows &quot;<br/>                                 &quot;platforms&quot;)<br/>    <br/>        self.args = args<br/>        self.stdin = None<br/>        self.stdout = None<br/>        self.stderr = None<br/>        self.pid = None<br/>        self.returncode = None<br/>        self.encoding = encoding<br/>        self.errors = errors<br/>    <br/>        # Validate the combinations of text and universal_newlines<br/>        if (text is not None and universal_newlines is not None<br/>            and bool(universal_newlines) != bool(text)):<br/>            raise SubprocessError(&#x27;Cannot disambiguate when both text &#x27;<br/>                                  &#x27;and universal_newlines are supplied but &#x27;<br/>                                  &#x27;different. Pass one or the other.&#x27;)<br/>    <br/>        # Input and output objects. The general principle is like<br/>        # this:<br/>        #<br/>        # Parent                   Child<br/>        # ------                   -----<br/>        # p2cwrite   ---stdin---&gt;  p2cread<br/>        # c2pread    &lt;--stdout---  c2pwrite<br/>        # errread    &lt;--stderr---  errwrite<br/>        #<br/>        # On POSIX, the child objects are file descriptors.  On<br/>        # Windows, these are Windows file handles.  The parent objects<br/>        # are file descriptors on both platforms.  The parent objects<br/>        # are -1 when not using PIPEs. The child objects are -1<br/>        # when not redirecting.<br/>    <br/>        (p2cread, p2cwrite,<br/>         c2pread, c2pwrite,<br/>         errread, errwrite) = self._get_handles(stdin, stdout, stderr)<br/>    <br/>        # We wrap OS handles *before* launching the child, otherwise a<br/>        # quickly terminating child could make our fds unwrappable<br/>        # (see #8458).<br/>    <br/>        if _mswindows:<br/>            if p2cwrite != -1:<br/>                p2cwrite = msvcrt.open_osfhandle(p2cwrite.Detach(), 0)<br/>            if c2pread != -1:<br/>                c2pread = msvcrt.open_osfhandle(c2pread.Detach(), 0)<br/>            if errread != -1:<br/>                errread = msvcrt.open_osfhandle(errread.Detach(), 0)<br/>    <br/>        self.text_mode = encoding or errors or text or universal_newlines<br/>    <br/>        # How long to resume waiting on a child after the first ^C.<br/>        # There is no right value for this.  The purpose is to be polite<br/>        # yet remain good for interactive users trying to exit a tool.<br/>        self._sigint_wait_secs = 0.25  # 1/xkcd221.getRandomNumber()<br/>    <br/>        self._closed_child_pipe_fds = False<br/>    <br/>        if self.text_mode:<br/>            if bufsize == 1:<br/>                line_buffering = True<br/>                # Use the default buffer size for the underlying binary streams<br/>                # since they don&#x27;t support line buffering.<br/>                bufsize = -1<br/>            else:<br/>                line_buffering = False<br/>    <br/>        gid = None<br/>        if group is not None:<br/>            if not hasattr(os, &#x27;setregid&#x27;):<br/>                raise ValueError(&quot;The &#x27;group&#x27; parameter is not supported on the &quot;<br/>                                 &quot;current platform&quot;)<br/>    <br/>            elif isinstance(group, str):<br/>                if grp is None:<br/>                    raise ValueError(&quot;The group parameter cannot be a string &quot;<br/>                                     &quot;on systems without the grp module&quot;)<br/>    <br/>                gid = grp.getgrnam(group).gr_gid<br/>            elif isinstance(group, int):<br/>                gid = group<br/>            else:<br/>                raise TypeError(&quot;Group must be a string or an integer, not {}&quot;<br/>                                .format(type(group)))<br/>    <br/>            if gid &lt; 0:<br/>                raise ValueError(f&quot;Group ID cannot be negative, got {gid}&quot;)<br/>    <br/>        gids = None<br/>        if extra_groups is not None:<br/>            if not hasattr(os, &#x27;setgroups&#x27;):<br/>                raise ValueError(&quot;The &#x27;extra_groups&#x27; parameter is not &quot;<br/>                                 &quot;supported on the current platform&quot;)<br/>    <br/>            elif isinstance(extra_groups, str):<br/>                raise ValueError(&quot;Groups must be a list, not a string&quot;)<br/>    <br/>            gids = []<br/>            for extra_group in extra_groups:<br/>                if isinstance(extra_group, str):<br/>                    if grp is None:<br/>                        raise ValueError(&quot;Items in extra_groups cannot be &quot;<br/>                                         &quot;strings on systems without the &quot;<br/>                                         &quot;grp module&quot;)<br/>    <br/>                    gids.append(grp.getgrnam(extra_group).gr_gid)<br/>                elif isinstance(extra_group, int):<br/>                    gids.append(extra_group)<br/>                else:<br/>                    raise TypeError(&quot;Items in extra_groups must be a string &quot;<br/>                                    &quot;or integer, not {}&quot;<br/>                                    .format(type(extra_group)))<br/>    <br/>            # make sure that the gids are all positive here so we can do less<br/>            # checking in the C code<br/>            for gid_check in gids:<br/>                if gid_check &lt; 0:<br/>                    raise ValueError(f&quot;Group ID cannot be negative, got {gid_check}&quot;)<br/>    <br/>        uid = None<br/>        if user is not None:<br/>            if not hasattr(os, &#x27;setreuid&#x27;):<br/>                raise ValueError(&quot;The &#x27;user&#x27; parameter is not supported on &quot;<br/>                                 &quot;the current platform&quot;)<br/>    <br/>            elif isinstance(user, str):<br/>                if pwd is None:<br/>                    raise ValueError(&quot;The user parameter cannot be a string &quot;<br/>                                     &quot;on systems without the pwd module&quot;)<br/>    <br/>                uid = pwd.getpwnam(user).pw_uid<br/>            elif isinstance(user, int):<br/>                uid = user<br/>            else:<br/>                raise TypeError(&quot;User must be a string or an integer&quot;)<br/>    <br/>            if uid &lt; 0:<br/>                raise ValueError(f&quot;User ID cannot be negative, got {uid}&quot;)<br/>    <br/>        try:<br/>            if p2cwrite != -1:<br/>                self.stdin = io.open(p2cwrite, &#x27;wb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stdin = io.TextIOWrapper(self.stdin, write_through=True,<br/>                            line_buffering=line_buffering,<br/>                            encoding=encoding, errors=errors)<br/>            if c2pread != -1:<br/>                self.stdout = io.open(c2pread, &#x27;rb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stdout = io.TextIOWrapper(self.stdout,<br/>                            encoding=encoding, errors=errors)<br/>            if errread != -1:<br/>                self.stderr = io.open(errread, &#x27;rb&#x27;, bufsize)<br/>                if self.text_mode:<br/>                    self.stderr = io.TextIOWrapper(self.stderr,<br/>                            encoding=encoding, errors=errors)<br/>    <br/>&gt;           self._execute_child(args, executable, preexec_fn, close_fds,<br/>                                pass_fds, cwd, env,<br/>                                startupinfo, creationflags, shell,<br/>                                p2cread, p2cwrite,<br/>                                c2pread, c2pwrite,<br/>                                errread, errwrite,<br/>                                restore_signals,<br/>                                gid, gids, uid, umask,<br/>                                start_new_session)<br/><br/>C:\Program Files\Python39\lib\subprocess.py:951: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Popen: returncode: None args: [&#x27;./binaries/webdriver/chromedriver.exe&#x27;, &#x27;--...&gt;<br/>args = &#x27;./binaries/webdriver/chromedriver.exe --port=52316 --log-path=C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a6\\driver.log&#x27;<br/>executable = None, preexec_fn = None, close_fds = False, pass_fds = (), cwd = None<br/>env = environ({&#x27;__INTELLIJ_COMMAND_HISTFILE__&#x27;: &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\JetBrains\\PyCharmCE2021.3\\terminal\\...fy_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)] (call)&#x27;})<br/>startupinfo = &lt;subprocess.STARTUPINFO object at 0x0000015C7BB2A160&gt;, creationflags = 0, shell = False, p2cread = Handle(1652), p2cwrite = 16, c2pread = -1<br/>c2pwrite = Handle(1636), errread = -1, errwrite = Handle(1660), unused_restore_signals = True, unused_gid = None, unused_gids = None, unused_uid = None<br/>unused_umask = -1, unused_start_new_session = False<br/><br/>    def _execute_child(self, args, executable, preexec_fn, close_fds,<br/>                       pass_fds, cwd, env,<br/>                       startupinfo, creationflags, shell,<br/>                       p2cread, p2cwrite,<br/>                       c2pread, c2pwrite,<br/>                       errread, errwrite,<br/>                       unused_restore_signals,<br/>                       unused_gid, unused_gids, unused_uid,<br/>                       unused_umask,<br/>                       unused_start_new_session):<br/>        &quot;&quot;&quot;Execute program (MS Windows version)&quot;&quot;&quot;<br/>    <br/>        assert not pass_fds, &quot;pass_fds not supported on Windows.&quot;<br/>    <br/>        if isinstance(args, str):<br/>            pass<br/>        elif isinstance(args, bytes):<br/>            if shell:<br/>                raise TypeError(&#x27;bytes args is not allowed on Windows&#x27;)<br/>            args = list2cmdline([args])<br/>        elif isinstance(args, os.PathLike):<br/>            if shell:<br/>                raise TypeError(&#x27;path-like args is not allowed when &#x27;<br/>                                &#x27;shell is true&#x27;)<br/>            args = list2cmdline([args])<br/>        else:<br/>            args = list2cmdline(args)<br/>    <br/>        if executable is not None:<br/>            executable = os.fsdecode(executable)<br/>    <br/>        # Process startup details<br/>        if startupinfo is None:<br/>            startupinfo = STARTUPINFO()<br/>        else:<br/>            # bpo-34044: Copy STARTUPINFO since it is modified above,<br/>            # so the caller can reuse it multiple times.<br/>            startupinfo = startupinfo.copy()<br/>    <br/>        use_std_handles = -1 not in (p2cread, c2pwrite, errwrite)<br/>        if use_std_handles:<br/>            startupinfo.dwFlags |= _winapi.STARTF_USESTDHANDLES<br/>            startupinfo.hStdInput = p2cread<br/>            startupinfo.hStdOutput = c2pwrite<br/>            startupinfo.hStdError = errwrite<br/>    <br/>        attribute_list = startupinfo.lpAttributeList<br/>        have_handle_list = bool(attribute_list and<br/>                                &quot;handle_list&quot; in attribute_list and<br/>                                attribute_list[&quot;handle_list&quot;])<br/>    <br/>        # If we were given an handle_list or need to create one<br/>        if have_handle_list or (use_std_handles and close_fds):<br/>            if attribute_list is None:<br/>                attribute_list = startupinfo.lpAttributeList = {}<br/>            handle_list = attribute_list[&quot;handle_list&quot;] = \<br/>                list(attribute_list.get(&quot;handle_list&quot;, []))<br/>    <br/>            if use_std_handles:<br/>                handle_list += [int(p2cread), int(c2pwrite), int(errwrite)]<br/>    <br/>            handle_list[:] = self._filter_handle_list(handle_list)<br/>    <br/>            if handle_list:<br/>                if not close_fds:<br/>                    warnings.warn(&quot;startupinfo.lpAttributeList[&#x27;handle_list&#x27;] &quot;<br/>                                  &quot;overriding close_fds&quot;, RuntimeWarning)<br/>    <br/>                # When using the handle_list we always request to inherit<br/>                # handles but the only handles that will be inherited are<br/>                # the ones in the handle_list<br/>                close_fds = False<br/>    <br/>        if shell:<br/>            startupinfo.dwFlags |= _winapi.STARTF_USESHOWWINDOW<br/>            startupinfo.wShowWindow = _winapi.SW_HIDE<br/>            comspec = os.environ.get(&quot;COMSPEC&quot;, &quot;cmd.exe&quot;)<br/>            args = &#x27;{} /c &quot;{}&quot;&#x27;.format (comspec, args)<br/>    <br/>        if cwd is not None:<br/>            cwd = os.fsdecode(cwd)<br/>    <br/>        sys.audit(&quot;subprocess.Popen&quot;, executable, args, cwd, env)<br/>    <br/>        # Start the process<br/>        try:<br/>&gt;           hp, ht, pid, tid = _winapi.CreateProcess(executable, args,<br/>                                     # no special security<br/>                                     None, None,<br/>                                     int(not close_fds),<br/>                                     creationflags,<br/>                                     env,<br/>                                     cwd,<br/>                                     startupinfo)<br/><span class="error">E                                    FileNotFoundError: [WinError 2] The system cannot find the file specified</span><br/><br/>C:\Program Files\Python39\lib\subprocess.py:1420: FileNotFoundError<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>request = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>scenario = Scenario(feature=Feature(scenarios=OrderedDict([(&#x27;Verify PPC - Buttons and Anchor - Loading Button&#x27;, ScenarioTemplate(...eyword=&#x27;Then&#x27;, failed=None, scenario=None, background=None, lines=[])], tags={&#x27;TR-C393228&#x27;, &#x27;automated&#x27;, &#x27;regression&#x27;})<br/>step = Step(type=&#x27;given&#x27;, _name=&quot;I am on the page &#x27;/&#x27;&quot;, line_number=5, indent=8, keyword=&#x27;Given&#x27;, failed=True, scenario=None,...closeIcon&#x27;&quot;, line_number=8, indent=8, keyword=&#x27;And&#x27;, failed=None, scenario=None, background=..., lines=[])]), lines=[])<br/>context = StepFunctionContext(type=&#x27;given&#x27;, step_func=&lt;function open_webpage at 0x0000015C7A412820&gt;, parser=&lt;pytest_bdd.parsers....t at 0x0000015C7A40F7C0&gt;, converters={&#x27;page_url&#x27;: &lt;function env_formatted at 0x0000015C78B20700&gt;}, target_fixture=None)<br/><br/>    def _execute_step_function(<br/>        request: FixtureRequest, scenario: Scenario, step: Step, context: StepFunctionContext<br/>    ) -&gt; None:<br/>        &quot;&quot;&quot;Execute step function.&quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        kw = {<br/>            &quot;request&quot;: request,<br/>            &quot;feature&quot;: scenario.feature,<br/>            &quot;scenario&quot;: scenario,<br/>            &quot;step&quot;: step,<br/>            &quot;step_func&quot;: context.step_func,<br/>            &quot;step_func_args&quot;: {},<br/>        }<br/>    <br/>        request.config.hook.pytest_bdd_before_step(**kw)<br/>    <br/>        # Get the step argument values.<br/>        converters = context.converters<br/>        kwargs = {}<br/>        args = get_args(context.step_func)<br/>    <br/>        try:<br/>            parsed_args = context.parser.parse_arguments(step.name)<br/>            assert parsed_args is not None, (<br/>                f&quot;Unexpected `NoneType` returned from &quot; f&quot;parse_arguments(...) in parser: {context.parser!r}&quot;<br/>            )<br/>            for arg, value in parsed_args.items():<br/>                if arg in converters:<br/>                    value = converters[arg](value)<br/>                kwargs[arg] = value<br/>    <br/>&gt;           kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}<br/><br/>venv\lib\site-packages\pytest_bdd\scenario.py:154: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>.0 = &lt;list_iterator object at 0x0000015C7BB37490&gt;<br/><br/>&gt;   kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}<br/><br/>venv\lib\site-packages\pytest_bdd\scenario.py:154: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>argname = &#x27;selenium_generics&#x27;<br/><br/>    def getfixturevalue(self, argname: str) -&gt; Any:<br/>        &quot;&quot;&quot;Dynamically run a named fixture function.<br/>    <br/>        Declaring fixtures via function argument is recommended where possible.<br/>        But if you can only decide whether to use another fixture at test<br/>        setup time, you may use this function to retrieve it inside a fixture<br/>        or test function body.<br/>    <br/>        :raises pytest.FixtureLookupError:<br/>            If the given fixture could not be found.<br/>        &quot;&quot;&quot;<br/>&gt;       fixturedef = self._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:581: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>argname = &#x27;selenium_generics&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureRequest for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium_generics&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium_generics&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>argname = &#x27;selenium&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium_generics&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>argname = &#x27;selenium&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;selenium&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>&gt;           fixturedef = request._get_active_fixturedef(argname)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1048: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>argname = &#x27;driver&#x27;<br/><br/>    def _get_active_fixturedef(<br/>        self, argname: str<br/>    ) -&gt; Union[&quot;FixtureDef[object]&quot;, PseudoFixtureDef[object]]:<br/>        try:<br/>            return self._fixture_defs[argname]<br/>        except KeyError:<br/>            try:<br/>                fixturedef = self._getnextfixturedef(argname)<br/>            except FixtureLookupError:<br/>                if argname == &quot;request&quot;:<br/>                    cached_result = (self, [0], None)<br/>                    scope: _Scope = &quot;function&quot;<br/>                    return PseudoFixtureDef(cached_result, scope)<br/>                raise<br/>        # Remove indent to prevent the python3 exception<br/>        # from leaking into the call.<br/>&gt;       self._compute_fixture_value(fixturedef)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:601: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;SubRequest &#x27;selenium&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>fixturedef = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/><br/>    def _compute_fixture_value(self, fixturedef: &quot;FixtureDef[object]&quot;) -&gt; None:<br/>        &quot;&quot;&quot;Create a SubRequest based on &quot;self&quot; and call the execute method<br/>        of the given FixtureDef object.<br/>    <br/>        This will force the FixtureDef object to throw away any previous<br/>        results and compute a new fixture value, which will be stored into<br/>        the FixtureDef object itself.<br/>        &quot;&quot;&quot;<br/>        # prepare a subrequest object before calling fixture function<br/>        # (latter managed by fixturedef)<br/>        argname = fixturedef.argname<br/>        funcitem = self._pyfuncitem<br/>        scope = fixturedef.scope<br/>        try:<br/>            param = funcitem.callspec.getparam(argname)<br/>        except (AttributeError, ValueError):<br/>            param = NOTSET<br/>            param_index = 0<br/>            has_params = fixturedef.params is not None<br/>            fixtures_not_supported = getattr(funcitem, &quot;nofuncargs&quot;, False)<br/>            if has_params and fixtures_not_supported:<br/>                msg = (<br/>                    &quot;{name} does not support fixtures, maybe unittest.TestCase subclass?\n&quot;<br/>                    &quot;Node id: {nodeid}\n&quot;<br/>                    &quot;Function type: {typename}&quot;<br/>                ).format(<br/>                    name=funcitem.name,<br/>                    nodeid=funcitem.nodeid,<br/>                    typename=type(funcitem).__name__,<br/>                )<br/>                fail(msg, pytrace=False)<br/>            if has_params:<br/>                frame = inspect.stack()[3]<br/>                frameinfo = inspect.getframeinfo(frame[0])<br/>                source_path = py.path.local(frameinfo.filename)<br/>                source_lineno = frameinfo.lineno<br/>                rel_source_path = source_path.relto(funcitem.config.rootdir)<br/>                if rel_source_path:<br/>                    source_path_str = rel_source_path<br/>                else:<br/>                    source_path_str = str(source_path)<br/>                msg = (<br/>                    &quot;The requested fixture has no parameter defined for test:\n&quot;<br/>                    &quot;    {}\n\n&quot;<br/>                    &quot;Requested fixture &#x27;{}&#x27; defined in:\n{}&quot;<br/>                    &quot;\n\nRequested here:\n{}:{}&quot;.format(<br/>                        funcitem.nodeid,<br/>                        fixturedef.argname,<br/>                        getlocation(fixturedef.func, funcitem.config.rootdir),<br/>                        source_path_str,<br/>                        source_lineno,<br/>                    )<br/>                )<br/>                fail(msg, pytrace=False)<br/>        else:<br/>            param_index = funcitem.callspec.indices[argname]<br/>            # If a parametrize invocation set a scope it will override<br/>            # the static scope defined with the fixture function.<br/>            paramscopenum = funcitem.callspec._arg2scopenum.get(argname)<br/>            if paramscopenum is not None:<br/>                scope = scopes[paramscopenum]<br/>    <br/>        subrequest = SubRequest(<br/>            self, scope, param, param_index, fixturedef, _ispytest=True<br/>        )<br/>    <br/>        # Check if a higher-level scoped fixture accesses a lower level one.<br/>        subrequest._check_scope(argname, self.scope, scope)<br/>        try:<br/>            # Call the fixture function.<br/>&gt;           fixturedef.execute(request=subrequest)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:687: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/><br/>    def execute(self, request: SubRequest) -&gt; _FixtureValue:<br/>        # Get required arguments and register our own finish()<br/>        # with their finalization.<br/>        for argname in self.argnames:<br/>            fixturedef = request._get_active_fixturedef(argname)<br/>            if argname != &quot;request&quot;:<br/>                # PseudoFixtureDef is only for &quot;request&quot;.<br/>                assert isinstance(fixturedef, FixtureDef)<br/>                fixturedef.addfinalizer(functools.partial(self.finish, request=request))<br/>    <br/>        my_cache_key = self.cache_key(request)<br/>        if self.cached_result is not None:<br/>            # note: comparison with `==` can fail (or be expensive) for e.g.<br/>            # numpy arrays (#6497).<br/>            cache_key = self.cached_result[1]<br/>            if my_cache_key is cache_key:<br/>                if self.cached_result[2] is not None:<br/>                    _, val, tb = self.cached_result[2]<br/>                    raise val.with_traceback(tb)<br/>                else:<br/>                    result = self.cached_result[0]<br/>                    return result<br/>            # We have a previous but differently parametrized fixture instance<br/>            # so we need to tear it down before creating a new one.<br/>            self.finish(request)<br/>            assert self.cached_result is None<br/>    <br/>        hook = self._fixturemanager.session.gethookproxy(request.node.fspath)<br/>&gt;       result = hook.pytest_fixture_setup(fixturedef=self, request=request)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1072: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_HookCaller &#x27;pytest_fixture_setup&#x27;&gt;<br/>kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;}<br/>firstresult = True<br/><br/>    def __call__(self, **kwargs: object) -&gt; Any:<br/>        assert (<br/>            not self.is_historic()<br/>        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;<br/>        self._verify_all_args_are_provided(kwargs)<br/>        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False<br/>&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_hooks.py:433: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;_pytest.config.PytestPluginManager object at 0x0000015C7034A250&gt;, hook_name = &#x27;pytest_fixture_setup&#x27;<br/>methods = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _hookexec(<br/>        self,<br/>        hook_name: str,<br/>        methods: Sequence[HookImpl],<br/>        kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        # called from all hookcaller instances.<br/>        # enable_tracing will set its own wrapping function at self._inner_hookexec<br/>&gt;       return self._inner_hookexec(hook_name, methods, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_manager.py:112: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_name = &#x27;pytest_fixture_setup&#x27;<br/>hook_impls = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>caller_kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _multicall(<br/>        hook_name: str,<br/>        hook_impls: Sequence[HookImpl],<br/>        caller_kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        results: list[object] = []<br/>        exception = None<br/>        only_new_style_wrappers = True<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns: list[Teardown] = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    f&quot;hook call must provide argument {argname!r}&quot;<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        only_new_style_wrappers = False<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            wrapper_gen = cast(Generator[None, _Result[object], None], res)<br/>                            next(wrapper_gen)  # first yield<br/>                            teardowns.append((wrapper_gen,))<br/>                        except StopIteration:<br/>                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)<br/>                    elif hook_impl.wrapper:<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            function_gen = cast(Generator[None, object, object], res)<br/>                            next(function_gen)  # first yield<br/>                            teardowns.append(function_gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)<br/>                    else:<br/>                        res = hook_impl.function(*args)<br/>                        if res is not None:<br/>                            results.append(res)<br/>                            if firstresult:  # halt further impl calls<br/>                                break<br/>            except BaseException as exc:<br/>                exception = exc<br/>        finally:<br/>            # Fast path - only new-style wrappers, no _Result.<br/>            if only_new_style_wrappers:<br/>                if firstresult:  # first result hooks return a single value<br/>                    result = results[0] if results else None<br/>                else:<br/>                    result = results<br/>    <br/>                # run all wrapper post-yield blocks<br/>                for teardown in reversed(teardowns):<br/>                    try:<br/>                        if exception is not None:<br/>                            teardown.throw(exception)  # type: ignore[union-attr]<br/>                        else:<br/>                            teardown.send(result)  # type: ignore[union-attr]<br/>                        # Following is unreachable for a well behaved hook wrapper.<br/>                        # Try to force finalizers otherwise postponed till GC action.<br/>                        # Note: close() may raise if generator handles GeneratorExit.<br/>                        teardown.close()  # type: ignore[union-attr]<br/>                    except StopIteration as si:<br/>                        result = si.value<br/>                        exception = None<br/>                        continue<br/>                    except BaseException as e:<br/>                        exception = e<br/>                        continue<br/>                    _raise_wrapfail(teardown, &quot;has second yield&quot;)  # type: ignore[arg-type]<br/>    <br/>                if exception is not None:<br/>                    raise exception.with_traceback(exception.__traceback__)<br/>                else:<br/>                    return result<br/>    <br/>            # Slow path - need to support old-style wrappers.<br/>            else:<br/>                if firstresult:  # first result hooks return a single value<br/>                    outcome: _Result[object | list[object]] = _Result(<br/>                        results[0] if results else None, exception<br/>                    )<br/>                else:<br/>                    outcome = _Result(results, exception)<br/>    <br/>                # run all wrapper post-yield blocks<br/>                for teardown in reversed(teardowns):<br/>                    if isinstance(teardown, tuple):<br/>                        try:<br/>                            teardown[0].send(outcome)<br/>                            _raise_wrapfail(teardown[0], &quot;has second yield&quot;)<br/>                        except StopIteration:<br/>                            pass<br/>                    else:<br/>                        try:<br/>                            if outcome._exception is not None:<br/>                                teardown.throw(outcome._exception)<br/>                            else:<br/>                                teardown.send(outcome._result)<br/>                            # Following is unreachable for a well behaved hook wrapper.<br/>                            # Try to force finalizers otherwise postponed till GC action.<br/>                            # Note: close() may raise if generator handles GeneratorExit.<br/>                            teardown.close()<br/>                        except StopIteration as si:<br/>                            outcome.force_result(si.value)<br/>                            continue<br/>                        except BaseException as e:<br/>                            outcome.force_exception(e)<br/>                            continue<br/>                        _raise_wrapfail(teardown, &quot;has second yield&quot;)<br/>    <br/>&gt;               return outcome.get_result()<br/><br/>venv\lib\site-packages\pluggy\_callers.py:155: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;pluggy._result._Result object at 0x0000015C7BB2AFA0&gt;<br/><br/>    def get_result(self) -&gt; _T:<br/>        &quot;&quot;&quot;Get the result(s) for this hook call.<br/>    <br/>        If the hook was marked as a ``firstresult`` only a single value<br/>        will be returned, otherwise a list of results.<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        exc = self._exception<br/>        if exc is None:<br/>            return cast(_T, self._result)<br/>        else:<br/>&gt;           raise exc.with_traceback(exc.__traceback__)<br/><br/>venv\lib\site-packages\pluggy\_result.py:108: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>hook_name = &#x27;pytest_fixture_setup&#x27;<br/>hook_impls = [&lt;HookImpl plugin_name=&#x27;fixtures&#x27;, plugin=&lt;module &#x27;_pytest.fixtures&#x27; from &#x27;c:\\users\\dixita19\\hcpsolutionstesting\\h...onstesting\\hcp-solutions-testing-main\\hcp-solutions-testing-main\\venv\\lib\\site-packages\\_pytest\\setuponly.py&#x27;&gt;&gt;]<br/>caller_kwargs = {&#x27;fixturedef&#x27;: &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;, &#x27;request&#x27;: &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;}<br/>firstresult = True<br/><br/>    def _multicall(<br/>        hook_name: str,<br/>        hook_impls: Sequence[HookImpl],<br/>        caller_kwargs: Mapping[str, object],<br/>        firstresult: bool,<br/>    ) -&gt; object | list[object]:<br/>        &quot;&quot;&quot;Execute a call into multiple python functions/methods and return the<br/>        result(s).<br/>    <br/>        ``caller_kwargs`` comes from _HookCaller.__call__().<br/>        &quot;&quot;&quot;<br/>        __tracebackhide__ = True<br/>        results: list[object] = []<br/>        exception = None<br/>        only_new_style_wrappers = True<br/>        try:  # run impl and wrapper setup functions in a loop<br/>            teardowns: list[Teardown] = []<br/>            try:<br/>                for hook_impl in reversed(hook_impls):<br/>                    try:<br/>                        args = [caller_kwargs[argname] for argname in hook_impl.argnames]<br/>                    except KeyError:<br/>                        for argname in hook_impl.argnames:<br/>                            if argname not in caller_kwargs:<br/>                                raise HookCallError(<br/>                                    f&quot;hook call must provide argument {argname!r}&quot;<br/>                                )<br/>    <br/>                    if hook_impl.hookwrapper:<br/>                        only_new_style_wrappers = False<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            wrapper_gen = cast(Generator[None, _Result[object], None], res)<br/>                            next(wrapper_gen)  # first yield<br/>                            teardowns.append((wrapper_gen,))<br/>                        except StopIteration:<br/>                            _raise_wrapfail(wrapper_gen, &quot;did not yield&quot;)<br/>                    elif hook_impl.wrapper:<br/>                        try:<br/>                            # If this cast is not valid, a type error is raised below,<br/>                            # which is the desired response.<br/>                            res = hook_impl.function(*args)<br/>                            function_gen = cast(Generator[None, object, object], res)<br/>                            next(function_gen)  # first yield<br/>                            teardowns.append(function_gen)<br/>                        except StopIteration:<br/>                            _raise_wrapfail(function_gen, &quot;did not yield&quot;)<br/>                    else:<br/>&gt;                       res = hook_impl.function(*args)<br/><br/>venv\lib\site-packages\pluggy\_callers.py:80: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fixturedef = &lt;FixtureDef argname=&#x27;driver&#x27; scope=&#x27;function&#x27; baseid=&#x27;&#x27;&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/><br/>    def pytest_fixture_setup(<br/>        fixturedef: FixtureDef[_FixtureValue], request: SubRequest<br/>    ) -&gt; _FixtureValue:<br/>        &quot;&quot;&quot;Execution of fixture setup.&quot;&quot;&quot;<br/>        kwargs = {}<br/>        for argname in fixturedef.argnames:<br/>            fixdef = request._get_active_fixturedef(argname)<br/>            assert fixdef.cached_result is not None<br/>            result, arg_cache_key, exc = fixdef.cached_result<br/>            request._check_scope(argname, request.scope, fixdef.scope)<br/>            kwargs[argname] = result<br/>    <br/>        fixturefunc = resolve_fixture_function(fixturedef, request)<br/>        my_cache_key = fixturedef.cache_key(request)<br/>        try:<br/>&gt;           result = call_fixture_func(fixturefunc, request, kwargs)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:1126: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>fixturefunc = &lt;function driver at 0x0000015C787C44C0&gt;<br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>kwargs = {&#x27;driver_class&#x27;: &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;, &#x27;driver_kwargs&#x27;: {&#x27;desired_capabilities&#x27;: {&#x27;...st_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;}<br/><br/>    def call_fixture_func(<br/>        fixturefunc: &quot;_FixtureFunc[_FixtureValue]&quot;, request: FixtureRequest, kwargs<br/>    ) -&gt; _FixtureValue:<br/>        if is_generator(fixturefunc):<br/>            fixturefunc = cast(<br/>                Callable[..., Generator[_FixtureValue, None, None]], fixturefunc<br/>            )<br/>            generator = fixturefunc(**kwargs)<br/>            try:<br/>&gt;               fixture_result = next(generator)<br/><br/>venv\lib\site-packages\_pytest\fixtures.py:925: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>driver_class = &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;<br/>driver_kwargs = {&#x27;desired_capabilities&#x27;: {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}, &#x27;executable_path&#x27;: &#x27;....\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a6\\driver.log&#x27;}<br/><br/>    @pytest.fixture<br/>    def driver(request, driver_class, driver_kwargs):<br/>        &quot;&quot;&quot;Returns a WebDriver instance based on options and capabilities&quot;&quot;&quot;<br/>    <br/>        retries = int(request.config.getini(&quot;max_driver_init_attempts&quot;))<br/>&gt;       for retry in Retrying(<br/>            stop=stop_after_attempt(retries), wait=wait_exponential(), reraise=True<br/>        ):<br/><br/>venv\lib\site-packages\pytest_selenium\pytest_selenium.py:201: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Retrying object at 0x15c7bb2ad60 (stop=&lt;tenacity.stop.stop_after_attempt object at 0x0000015C7BB2AD90&gt;, wait=&lt;tenacit...631370&gt;, before=&lt;function before_nothing at 0x0000015C7861BB80&gt;, after=&lt;function after_nothing at 0x0000015C7862F700&gt;)&gt;<br/><br/>    def __iter__(self):<br/>        self.begin(None)<br/>    <br/>        retry_state = RetryCallState(self, fn=None, args=(), kwargs={})<br/>        while True:<br/>&gt;           do = self.iter(retry_state=retry_state)<br/><br/>venv\lib\site-packages\tenacity\__init__.py:394: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;Retrying object at 0x15c7bb2ad60 (stop=&lt;tenacity.stop.stop_after_attempt object at 0x0000015C7BB2AD90&gt;, wait=&lt;tenacit...631370&gt;, before=&lt;function before_nothing at 0x0000015C7861BB80&gt;, after=&lt;function after_nothing at 0x0000015C7862F700&gt;)&gt;<br/>retry_state = &lt;tenacity.RetryCallState object at 0x0000015C7BB2ACD0&gt;<br/><br/>    def iter(self, retry_state):  # noqa<br/>        fut = retry_state.outcome<br/>        if fut is None:<br/>            if self.before is not None:<br/>                self.before(retry_state)<br/>            return DoAttempt()<br/>    <br/>        is_explicit_retry = retry_state.outcome.failed \<br/>            and isinstance(retry_state.outcome.exception(), TryAgain)<br/>        if not (is_explicit_retry or self.retry(retry_state=retry_state)):<br/>            return fut.result()<br/>    <br/>        if self.after is not None:<br/>            self.after(retry_state=retry_state)<br/>    <br/>        self.statistics[&#x27;delay_since_first_attempt&#x27;] = \<br/>            retry_state.seconds_since_start<br/>        if self.stop(retry_state=retry_state):<br/>            if self.retry_error_callback:<br/>                return self.retry_error_callback(retry_state=retry_state)<br/>            retry_exc = self.retry_error_cls(fut)<br/>            if self.reraise:<br/>&gt;               raise retry_exc.reraise()<br/><br/>venv\lib\site-packages\tenacity\__init__.py:372: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = RetryError(&lt;Future at 0x15c7bb2ae80 state=finished raised WebDriverException&gt;)<br/><br/>    def reraise(self):<br/>        if self.last_attempt.failed:<br/>&gt;           raise self.last_attempt.result()<br/><br/>venv\lib\site-packages\tenacity\__init__.py:189: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = None, timeout = None<br/><br/>    def result(self, timeout=None):<br/>        &quot;&quot;&quot;Return the result of the call that the future represents.<br/>    <br/>        Args:<br/>            timeout: The number of seconds to wait for the result if the future<br/>                isn&#x27;t done. If None, then there is no limit on the wait time.<br/>    <br/>        Returns:<br/>            The result of the call that the future represents.<br/>    <br/>        Raises:<br/>            CancelledError: If the future was cancelled.<br/>            TimeoutError: If the future didn&#x27;t finish executing before the given<br/>                timeout.<br/>            Exception: If the call raised then that exception will be raised.<br/>        &quot;&quot;&quot;<br/>        try:<br/>            with self._condition:<br/>                if self._state in [CANCELLED, CANCELLED_AND_NOTIFIED]:<br/>                    raise CancelledError()<br/>                elif self._state == FINISHED:<br/>&gt;                   return self.__get_result()<br/><br/>C:\Program Files\Python39\lib\concurrent\futures\_base.py:439: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = None<br/><br/>    def __get_result(self):<br/>        if self._exception:<br/>            try:<br/>&gt;               raise self._exception<br/><br/>C:\Program Files\Python39\lib\concurrent\futures\_base.py:391: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>request = &lt;SubRequest &#x27;driver&#x27; for &lt;Function test_verify_ppc__buttons_and_anchor__loading_button[helixComponent &gt; loading_button_icon-color-rgba(255, 255, 255, 1)]&gt;&gt;<br/>driver_class = &lt;class &#x27;selenium.webdriver.chrome.webdriver.WebDriver&#x27;&gt;<br/>driver_kwargs = {&#x27;desired_capabilities&#x27;: {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}, &#x27;executable_path&#x27;: &#x27;....\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a6\\driver.log&#x27;}<br/><br/>    @pytest.fixture<br/>    def driver(request, driver_class, driver_kwargs):<br/>        &quot;&quot;&quot;Returns a WebDriver instance based on options and capabilities&quot;&quot;&quot;<br/>    <br/>        retries = int(request.config.getini(&quot;max_driver_init_attempts&quot;))<br/>        for retry in Retrying(<br/>            stop=stop_after_attempt(retries), wait=wait_exponential(), reraise=True<br/>        ):<br/>            with retry:<br/>                LOGGER.info(<br/>                    f&quot;Driver init, attempt {retry.retry_state.attempt_number}/{retries}&quot;<br/>                )<br/>&gt;               driver = driver_class(**driver_kwargs)<br/><br/>venv\lib\site-packages\pytest_selenium\pytest_selenium.py:208: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[AttributeError(&quot;&#x27;WebDriver&#x27; object has no attribute &#x27;session_id&#x27;&quot;) raised in repr()] WebDriver object at 0x15c7bb2ae50&gt;<br/>executable_path = &#x27;./binaries/webdriver/chromedriver.exe&#x27;, port = 0, options = &lt;selenium.webdriver.chrome.options.Options object at 0x0000015C7BB2AAF0&gt;<br/>service_args = None, desired_capabilities = {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}<br/>service_log_path = &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a6\\driver.log&#x27;<br/>chrome_options = None, service = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BB2A7F0&gt;, keep_alive = True<br/><br/>    def __init__(self, executable_path=DEFAULT_EXECUTABLE_PATH, port=DEFAULT_PORT,<br/>                 options: Options = None, service_args=None,<br/>                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,<br/>                 chrome_options=None, service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):<br/>        &quot;&quot;&quot;<br/>        Creates a new instance of the chrome driver.<br/>        Starts the service and then creates new instance of chrome driver.<br/>    <br/>        :Args:<br/>         - executable_path - Deprecated: path to the executable. If the default is used it assumes the executable is in the $PATH<br/>         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.<br/>         - options - this takes an instance of ChromeOptions<br/>         - service - Service object for handling the browser driver if you need to pass extra details<br/>         - service_args - Deprecated: List of args to pass to the driver service<br/>         - desired_capabilities - Deprecated: Dictionary object with non-browser specific<br/>           capabilities only, such as &quot;proxy&quot; or &quot;loggingPref&quot;.<br/>         - service_log_path - Deprecated: Where to log information from the driver.<br/>         - keep_alive - Deprecated: Whether to configure ChromeRemoteConnection to use HTTP keep-alive.<br/>        &quot;&quot;&quot;<br/>        if executable_path != &#x27;chromedriver&#x27;:<br/>            warnings.warn(&#x27;executable_path has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if chrome_options:<br/>            warnings.warn(&#x27;use options instead of chrome_options&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>            options = chrome_options<br/>        if keep_alive != DEFAULT_KEEP_ALIVE:<br/>            warnings.warn(&#x27;keep_alive has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        else:<br/>            keep_alive = True<br/>        if not service:<br/>            service = Service(executable_path, port, service_args, service_log_path)<br/>    <br/>&gt;       super(WebDriver, self).__init__(DesiredCapabilities.CHROME[&#x27;browserName&#x27;], &quot;goog&quot;,<br/>                                        port, options,<br/>                                        service_args, desired_capabilities,<br/>                                        service_log_path, service, keep_alive)<br/><br/>venv\lib\site-packages\selenium\webdriver\chrome\webdriver.py:70: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;[AttributeError(&quot;&#x27;WebDriver&#x27; object has no attribute &#x27;session_id&#x27;&quot;) raised in repr()] WebDriver object at 0x15c7bb2ae50&gt;, browser_name = &#x27;chrome&#x27;<br/>vendor_prefix = &#x27;goog&#x27;, port = 0, options = &lt;selenium.webdriver.chrome.options.Options object at 0x0000015C7BB2AAF0&gt;, service_args = None<br/>desired_capabilities = {&#x27;browserName&#x27;: &#x27;chrome&#x27;, &#x27;goog:loggingPrefs&#x27;: {&#x27;performance&#x27;: &#x27;ALL&#x27;}}<br/>service_log_path = &#x27;C:\\Users\\DIXITA19\\AppData\\Local\\Temp\\pytest-of-DIXITA19\\pytest-1021\\test_verify_ppc__buttons_and_a6\\driver.log&#x27;<br/>service = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BB2A7F0&gt;, keep_alive = True<br/><br/>    def __init__(self, browser_name, vendor_prefix,<br/>                 port=DEFAULT_PORT, options: BaseOptions = None, service_args=None,<br/>                 desired_capabilities=None, service_log_path=DEFAULT_SERVICE_LOG_PATH,<br/>                 service: Service = None, keep_alive=DEFAULT_KEEP_ALIVE):<br/>        &quot;&quot;&quot;<br/>        Creates a new WebDriver instance of the ChromiumDriver.<br/>        Starts the service and then creates new WebDriver instance of ChromiumDriver.<br/>    <br/>        :Args:<br/>         - browser_name - Browser name used when matching capabilities.<br/>         - vendor_prefix - Company prefix to apply to vendor-specific WebDriver extension commands.<br/>         - port - Deprecated: port you would like the service to run, if left as 0, a free port will be found.<br/>         - options - this takes an instance of ChromiumOptions<br/>         - service_args - Deprecated: List of args to pass to the driver service<br/>         - desired_capabilities - Deprecated: Dictionary object with non-browser specific<br/>           capabilities only, such as &quot;proxy&quot; or &quot;loggingPref&quot;.<br/>         - service_log_path - Deprecated: Where to log information from the driver.<br/>         - keep_alive - Deprecated: Whether to configure ChromiumRemoteConnection to use HTTP keep-alive.<br/>        &quot;&quot;&quot;<br/>        if desired_capabilities:<br/>            warnings.warn(&#x27;desired_capabilities has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if port != DEFAULT_PORT:<br/>            warnings.warn(&#x27;port has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        self.port = port<br/>        if service_log_path != DEFAULT_SERVICE_LOG_PATH:<br/>            warnings.warn(&#x27;service_log_path has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        if keep_alive != DEFAULT_KEEP_ALIVE and type(self) == __class__:<br/>            warnings.warn(&#x27;keep_alive has been deprecated, please pass in a Service object&#x27;,<br/>                          DeprecationWarning, stacklevel=2)<br/>        else:<br/>            keep_alive = True<br/>    <br/>        self.vendor_prefix = vendor_prefix<br/>    <br/>        _ignore_proxy = None<br/>        if not options:<br/>            options = self.create_options()<br/>    <br/>        if desired_capabilities:<br/>            for key, value in desired_capabilities.items():<br/>                options.set_capability(key, value)<br/>    <br/>        if options._ignore_local_proxy:<br/>            _ignore_proxy = options._ignore_local_proxy<br/>    <br/>        if not service:<br/>            raise AttributeError(&#x27;service cannot be None&#x27;)<br/>    <br/>        self.service = service<br/>&gt;       self.service.start()<br/><br/>venv\lib\site-packages\selenium\webdriver\chromium\webdriver.py:90: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>self = &lt;selenium.webdriver.chrome.service.Service object at 0x0000015C7BB2A7F0&gt;<br/><br/>    def start(self):<br/>        &quot;&quot;&quot;<br/>        Starts the Service.<br/>    <br/>        :Exceptions:<br/>         - WebDriverException : Raised either when it can&#x27;t start the service<br/>           or when it can&#x27;t connect to the service<br/>        &quot;&quot;&quot;<br/>        try:<br/>            cmd = [self.path]<br/>            cmd.extend(self.command_line_args())<br/>            self.process = subprocess.Popen(cmd, env=self.env,<br/>                                            close_fds=system() != &#x27;Windows&#x27;,<br/>                                            stdout=self.log_file,<br/>                                            stderr=self.log_file,<br/>                                            stdin=PIPE,<br/>                                            creationflags=self.creationflags)<br/>        except TypeError:<br/>            raise<br/>        except OSError as err:<br/>            if err.errno == errno.ENOENT:<br/>&gt;               raise WebDriverException(<br/>                    &quot;&#x27;%s&#x27; executable needs to be in PATH. %s&quot; % (<br/>                        os.path.basename(self.path), self.start_error_message)<br/><span class="error">E                       selenium.common.exceptions.WebDriverException: Message: &#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.chromium.org/home</span><br/><br/>venv\lib\site-packages\selenium\webdriver\common\service.py:81: WebDriverException<br/><br/>During handling of the above exception, another exception occurred:<br/><br/>self = &lt;_HookCaller &#x27;pytest_bdd_step_error&#x27;&gt;<br/>kwargs = {&#x27;exception&#x27;: WebDriverException(&quot;&#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.c...=&#x27;Then&#x27;, failed=None, scenario=None, background=None, lines=[])], tags={&#x27;TR-C393228&#x27;, &#x27;automated&#x27;, &#x27;regression&#x27;}), ...}<br/>firstresult = False<br/><br/>    def __call__(self, **kwargs: object) -&gt; Any:<br/>        assert (<br/>            not self.is_historic()<br/>        ), &quot;Cannot directly call a historic hook - use call_historic instead.&quot;<br/>        self._verify_all_args_are_provided(kwargs)<br/>        firstresult = self.spec.opts.get(&quot;firstresult&quot;, False) if self.spec else False<br/>&gt;       return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)<br/><br/>venv\lib\site-packages\pluggy\_hooks.py:433: <br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/>venv\lib\site-packages\pluggy\_manager.py:112: in _hookexec<br/>    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)<br/>venv\lib\site-packages\enhanced_reports\core.py:493: in pytest_bdd_step_error<br/>    __capture_js_logs(current_state, driver, op_name)<br/>venv\lib\site-packages\enhanced_reports\core.py:234: in __capture_js_logs<br/>    logs = browser_console_manager.get_js_logs(driver)<br/>venv\lib\site-packages\enhanced_reports\browser_console_manager.py:13: in get_js_logs<br/>    logs = _capture_output(driver)<br/>_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ <br/><br/>driver = None<br/><br/>    def _capture_output(driver: WebDriver):<br/>&gt;       return driver.get_log(&quot;browser&quot;)<br/><span class="error">E       AttributeError: &#x27;NoneType&#x27; object has no attribute &#x27;get_log&#x27;</span><br/><br/>venv\lib\site-packages\enhanced_reports\browser_console_manager.py:18: AttributeError<br/> -----------------------------Captured stderr setup------------------------------ <br/>2023-06-22 05:35:41 [info     ] current param_value False
<br/> -------------------------------Captured log setup------------------------------- <br/>2023-06-22 11:05:41 INFO current param_value False<br/> ------------------------------Captured stderr call------------------------------ <br/>

2023-06-22 05:35:41 [info     ] Scenario Execution Started.    feature=Galaxy automated regression - button and anchor components scenario_name=Verify PPC - Buttons and Anchor - Loading Button
2023-06-22 05:35:41 [info     ] Capabilities from markers: {}
2023-06-22 05:35:41 [info     ] Driver init, attempt 1/3
2023-06-22 05:35:42 [info     ] Driver init, attempt 2/3
2023-06-22 05:35:44 [info     ] Driver init, attempt 3/3
2023-06-22 05:35:44 [error    ] Step FAILED.                   step=I am on the page &#x27;/&#x27;
Traceback (most recent call last):
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\common\service.py&quot;, line 71, in start
    self.process = subprocess.Popen(cmd, env=self.env,
  File &quot;C:\Program Files\Python39\lib\subprocess.py&quot;, line 951, in __init__
    self._execute_child(args, executable, preexec_fn, close_fds,
  File &quot;C:\Program Files\Python39\lib\subprocess.py&quot;, line 1420, in _execute_child
    hp, ht, pid, tid = _winapi.CreateProcess(executable, args,
FileNotFoundError: [WinError 2] The system cannot find the file specified

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_bdd\scenario.py&quot;, line 154, in _execute_step_function
    kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_bdd\scenario.py&quot;, line 154, in &lt;dictcomp&gt;
    kwargs = {arg: kwargs[arg] if arg in kwargs else request.getfixturevalue(arg) for arg in args}
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 581, in getfixturevalue
    fixturedef = self._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1048, in execute
    fixturedef = request._get_active_fixturedef(argname)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 601, in _get_active_fixturedef
    self._compute_fixture_value(fixturedef)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 687, in _compute_fixture_value
    fixturedef.execute(request=subrequest)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1072, in execute
    result = hook.pytest_fixture_setup(fixturedef=self, request=request)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_hooks.py&quot;, line 433, in __call__
    return self._hookexec(self.name, self._hookimpls, kwargs, firstresult)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_manager.py&quot;, line 112, in _hookexec
    return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_callers.py&quot;, line 155, in _multicall
    return outcome.get_result()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_result.py&quot;, line 108, in get_result
    raise exc.with_traceback(exc.__traceback__)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pluggy\_callers.py&quot;, line 80, in _multicall
    res = hook_impl.function(*args)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 1126, in pytest_fixture_setup
    result = call_fixture_func(fixturefunc, request, kwargs)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\_pytest\fixtures.py&quot;, line 925, in call_fixture_func
    fixture_result = next(generator)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_selenium\pytest_selenium.py&quot;, line 201, in driver
    for retry in Retrying(
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 394, in __iter__
    do = self.iter(retry_state=retry_state)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 372, in iter
    raise retry_exc.reraise()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\tenacity\__init__.py&quot;, line 189, in reraise
    raise self.last_attempt.result()
  File &quot;C:\Program Files\Python39\lib\concurrent\futures\_base.py&quot;, line 439, in result
    return self.__get_result()
  File &quot;C:\Program Files\Python39\lib\concurrent\futures\_base.py&quot;, line 391, in __get_result
    raise self._exception
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\pytest_selenium\pytest_selenium.py&quot;, line 208, in driver
    driver = driver_class(**driver_kwargs)
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\chrome\webdriver.py&quot;, line 70, in __init__
    super(WebDriver, self).__init__(DesiredCapabilities.CHROME[&#x27;browserName&#x27;], &quot;goog&quot;,
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\chromium\webdriver.py&quot;, line 90, in __init__
    self.service.start()
  File &quot;c:\users\dixita19\hcpsolutionstesting\hcp-solutions-testing-main\hcp-solutions-testing-main\venv\lib\site-packages\selenium\webdriver\common\service.py&quot;, line 81, in start
    raise WebDriverException(
selenium.common.exceptions.WebDriverException: Message: &#x27;chromedriver.exe&#x27; executable needs to be in PATH. Please see https://chromedriver.chromium.org/home

2023-06-22 05:35:44 [info     ] current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 05:35:44 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
2023-06-22 05:35:44 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
2023-06-22 05:35:44 [info     ] Scenario Execution Completed.  feature=Galaxy automated regression - button and anchor components scenario_name=Verify PPC - Buttons and Anchor - Loading Button
2023-06-22 05:35:44 [info     ] current param_value EnhancedReportOperationFrequency.EACH_UI_OPERATION
2023-06-22 05:35:44 [info     ] current param_value EnhancedReportOperationFrequency.FAILED_TEST_ONLY
<br/></div></td></tr></tbody></table></body></html>